#+TITLE:      Java 接口和继承

* 目录                                                    :TOC_4_gh:noexport:
- [[#语法相关][语法相关]]
- [[#接口][接口]]
- [[#继承和多态][继承和多态]]
- [[#抽象类与抽象方法][抽象类与抽象方法]]
- [[#多态相关][多态相关]]

* 语法相关
  声明抽象方法必须省略方法主体：
  #+BEGIN_SRC java
    public abstract void method();
  #+END_SRC

  声明类和其他方法不能省略主体， 即使主体为空：
  #+BEGIN_SRC java
    public abstract class AbstractClass {
      public void method() {}
    }
  #+END_SRC

* 接口
  1. Java 不允许多重继承
  2. 替代方案是使用接口 ~Interface~

  接口的特点：
  1. 接口不能被实例化， 但是可以被实现
  2. 接口没有构造方法
  3. 接口中所有的方法默认(必须)为 ~public abstract~
  4. 允许一个类同时实现多个接口， 因为所有的接口方法都是抽象的

  #+BEGIN_SRC java
    interface Actor {
      void methodA();
      void methodB();
    }
  #+END_SRC

  接口的继承使用关键字： ~implements~.

  #+BEGIN_SRC java
    public class Dog implements ...
  #+END_SRC

  如果继承接口的类是抽象类， 那么可以不实现接口的方法， 留待子类实现。
  
  需要某些类的特殊化版本时继承它们。

  需要某些类扮演一个角色时， 定义一个接口

* 继承和多态
  子类会自动继承父类的 *实例变量* 与 *方法*, 可以在子类中覆盖父类的方法， 但不能覆盖 *实例变量*,
  因为不需要， 实例变量并没有什么特殊的行为。

  方法调用会调用与该对象最接近的方法， 即在继承层次最下方。

  执行时 java 虚拟机不关心方法来自那个类。

  父类不能调用子类的方法。

  使用关键字 ~super~ 调用父类的方法。

  覆盖父类方法： 重写那个方法即可。 ~@Override~ 的作用： [[https://blog.csdn.net/zht666/article/details/7869383][Java中@Override的作用]]

  继承使用关键字 ~extends~: ~class son extends father~.

  继承会继承 ~public~ 类型的方法和实例变量， 但不会继承 ~private~ 的。

  *引用类型可以是实际对象类型的父类*. 定义变量， 函数传参， 返回值时都可以如此。 即： *多态*.

  除了 *内部类* 以外， 没有 *私有类* 的说法。

  防止类被继承：
  1. 非公有类只能被同一个包的类继承
  2. 使用 final 修饰符修饰的类无法被继承
  3. 让类拥有 private 的构造函数

  使用 final 修饰的方法不会被覆盖。

  同时， 类的 private 方法会隐式地被指定为 final 方法。
  
  覆盖的基本原则：
  1. 参数和返回值类型必须要一样
  2. 不能降低方法的存取权限， 只能保持一样或更加开放

  + [[https://www.polarxiong.com/archives/JAVA-%E5%AD%90%E7%B1%BB-%E8%A6%86%E7%9B%96-%E7%88%B6%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F.html][JAVA: 子类覆盖父类的成员变量]]

* 抽象类与抽象方法
  1. 抽象类与抽象方法使用关键字 abstract 修饰
  2. 抽象类不能被实例化
  3. 抽象方法在具体类中必须被实现， 但可以在抽象类中传递
  4. 抽象方法只能在抽象类中定义
     
  *AbstractClass.java*:
  #+BEGIN_SRC java
    public abstract class AbstractClass {
      public abstract void method();
    }
  #+END_SRC

  *AbstractSubClass.java*:
  #+BEGIN_SRC java
    public abstract class AbstractSubClass extends AbstractClass {}
  #+END_SRC

  *NotAbstractClass.java*:
  #+BEGIN_SRC java
    public class NotAbstractClass extends AbstractSubClass{
      public void method() {}
    }
  #+END_SRC

* 多态相关
  1. 使用父类类型的引用指向子类的对象
  2. 该引用只能调用父类中定义的方法和变量

  编译器根据 *引用类型* 来判断有哪些 ~method~ 可以调用， 而不是 ~Object~ 确实的类型。
