#+SETUPFILE:  ./_style/style.setup
#+TITLE:      Python 笔记

* 目录                                                    :TOC_4_gh:noexport:
- [[#调试][调试]]
- [[#兼容][兼容]]
- [[#乘方][乘方]]
- [[#元类][元类]]
- [[#type][*type()*]]
- [[#__slots__][*__slots__*]]
- [[#正负无穷][正负无穷]]
- [[#翻转序列][翻转序列]]
- [[#魔术方法][魔术方法]]
- [[#变量保护][变量保护]]
- [[#应用方向][应用方向]]
  - [[#web-开发][WEB 开发]]
  - [[#网络爬虫][网络爬虫]]
  - [[#人工智能与机器学习][人工智能与机器学习]]
  - [[#数据分析处理][数据分析处理]]
  - [[#服务器运维及其它小工具][服务器运维及其它小工具]]
  - [[#桌面程序][桌面程序]]
  - [[#多媒体应用][多媒体应用]]
- [[#命令行参数][命令行参数]]
- [[#类模块包][类、模块、包]]
  - [[#模块][模块]]
  - [[#包][包]]
  - [[#__main__py-和-__init__py][*__main__.py* 和 *__init__.py*]]
- [[#类属性和实例属性][类属性和实例属性]]

* 调试
  + 启动： ~Python -m pdb script.py~
  + 指令：
    - p print
    - n 单步跳过(跳过函数)
    - s 单步(不跳过函数)

* 兼容
  + [[https://segmentfault.com/a/1190000000637180][编写兼容 Python 2 和 Python 3 的代码]]

* 乘方
  #+BEGIN_SRC python
    >>> 2 ** 2
    4
    >>> 2 ** 0.5
    1.4142135623730951
    >>> 2 ** .5
    1.4142135623730951
  #+END_SRC

* 元类
  + *创建元类* --> *创建类* --> *创建实例*

  #+BEGIN_SRC python
    # metaclass 是创建类，所以必须从`type`类型派生：
    class ListMetaclass(type):
        def __new__(cls, name, bases, attrs):
            attrs['add'] = lambda self, value: self.append(value)
            return type.__new__(cls, name, bases, attrs)

    class MyList(list):
        __metaclass__ = ListMetaclass # 指示使用ListMetaclass来定制类
  #+END_SRC

  ~__metaclass__ = ListMetaclass~ 表名在创建 ~MyList~ 时， 要通过 ~ListMetaclass.__new__()~ 来创建。

  ~__new__()~ 方法接受到的参数依次为：
  1. 当前准备创建的类的对象
  2. 类的名字
  3. 类继承的父类集合
  4. 类的方法集合

* *type()*
  ~type()~ 的两个作用：
  1. 查看一个类型或变量的类型
  2. 创建出新的类型（Python 解释器也是调用 type 创建类）

  创建类：
  #+BEGIN_SRC python
    def fn(self, name='world'): # 先定义函数
        print('Hello, %s.' % name)

    Hello = type('Hello', (object,), dict(hello=fn)) # 创建Hello class
  #+END_SRC

  参数：
  1. class 的名称
  2. 继承的父类集合， Python 支持多重继承， 因此这个参数应该是一个元组
  3. class 的方法名称与函数绑定， 这里把函数 ~fn~ 绑定到方法名 ~hello~ 上

* *__slots__*
  在 ~Python~ 中，每个类都有实例属性。默认情况下 ~Python~ 用一个字典来保存一个对象的实例属性。这非常有用，因为它允许我们在运行时去 *设置任意的新属性*

  然而，对于有着已知属性的小类来说，它可能是个瓶颈。这个字典浪费了很多内存。 ~Python~ 不能在对象创建时直接分配一个固定量的内存来保存所有的属性。
  因此如果你创建许多对象（我指的是成千上万个），它会消耗掉很多内存。

  不过还是有一个方法来规避这个问题。这个方法需要使用 ~__slots__~ 来告诉 ~Python~ 不要使用字典，而且只给一个固定集合的属性分配空间。

  此时， ~__slots__~ 将为已声明的变量保留空间并阻止为每个实例自动创建 ~__dict__~ 和 ~__weakref__~

  简单来说， ~__slots__~ 的一个直接的作用便是减少内存消耗。

  使用方式：
  #+BEGIN_SRC python
    class MyClass(object):
        __slots__ = ['name', 'identifier']
        def __init__(self, name, identifier):
            self.name = name
            self.identifier = identifier
            self.set_up()
            # ...
  #+END_SRC

  注意事项：
  + 当从没有 ~__slots__~ 的类继承时， 该类的 ~__dict__~ 属性将始终可访问，因此子类中的 ~__slots__~ 定义没有意义
  + 没有 ~__dict__~ 变量时， 实例不能被分配 ~__slots__~ 定义中未列出的新变量。 即不能随意设置变量
  + 没有 ~__weakref__~ 变量， 定义 ~__slots__~ 的类不支持对其实例的弱引用。 如果需要弱引用支持， 则将 ~__weakref__~
    添加到 ~__slots__~ 声明的字符串序列中
  + 类属性不能用于为由 ~__slots__~ 定义的实例变量设置默认值
  + ~__slots__~ 声明的操作仅限于定义它的类， 子类将由一个 ~__dict__~, 除非定义 ~__slots__~


  文档： [[https://docs.python.org/2/reference/datamodel.html?highlight=__slots__#slots][ __slots__]]

* 正负无穷
  #+BEGIN_SRC python
    >>> float('inf')  # 正无穷
    inf
    >>> float('-inf')  # 负无穷
    -inf
    >>> 1 + float('inf')
    inf
    >>> 1 - float('inf')
    -inf
    >>> 0 * float('inf')
    nan  #  not a number
  #+END_SRC

* 翻转序列
  : s[::-1]

* 魔术方法
  + [[http://pycoders-weekly-chinese.readthedocs.io/en/latest/issue6/a-guide-to-pythons-magic-methods.html][Python 魔术方法指南]]

* 变量保护
  + ~__xxx__~ 系统定义名字
  + ~_xxx~ 保护变量， 只有类对象和子类对象自己能访问到这些变量
  + ~__xxx~ 私有成员， 只有类对象自己能访问，连子类对象也不能访问到这个数据

* 应用方向
** WEB 开发

   主要技术栈:
   1. Django :: 适合快速开发一个网站, 兼顾APP客户端的API调用请求
   2. Flask :: 适合配合手机客户端开发后台API服务, 优势是后端、API，不适合构建全功能网站

** 网络爬虫
   工具积累:
   1. Requests :: 模拟HTTP请求
   2. PyQuery/BeautifulSoup :: HTML DOM 解析
   3. Scrapy :: 自动化分布式爬取任务
   4. 最简化数据库访问的各种ORM

** 人工智能与机器学习
** 数据分析处理
** 服务器运维及其它小工具
** 桌面程序
** 多媒体应用
* 命令行参数
  + [[http://blog.xiayf.cn/2013/03/30/argparse/][argparse 教程]]

* 类、模块、包
** 模块
   模块，在 ~Python~ 可理解为对应于一个文件。在创建了一个脚本文件后，定义了某些函数和变量。你在其他需要这些功能的文件中，导入这模块，就可重用这些函数和变量。

   一般用 ~module_name.fun_name~, 和 ~module_name.var_name~ 进行使用。这样的语义用法使模块看起来很像类或者名字空间，可将 ~module_name~ 理解为名字限定符。模块名就是文件名去掉 ~.py~ 后缀。

   模块属性 ~__name__~, 它的值由 ~Python~ 解释器设定。如果脚本文件是作为主程序调用，其值就设为 ~__main__~, 如果是作为模块被其他文件导入，它的值就是其文件名。

   模块能像包含函数定义一样，可包含一些可执行语句。这些可执行语句通常用来进行模块的初始化工作。这些语句 *只在模块第一次被导入时* 被执行。
   这非常重要，有些人以为这些语句会多次导入多次执行，其实不然。

   模块在被导入执行时, ~python~ 解释器为加快程序的启动速度，会在与模块文件同一目录下生成 ~.pyc~ 文件。
   我们知道 ~python~ 是解释性的脚本语言，而 ~.pyc~ 是经过编译后的字节码，这一工作会自动完成，而无需程序员手动执行。

** 包
   通常包总是一个目录，可以使用 ~import~ 导入包，或者 ~from + import~ 来导入包中的部分模块。包目录下为首的一个文件便是 ~__init__.py~.
   然后是一些模块文件和子目录，假如子目录中也有 ~__init__.py~ 那么它就是这个包的子包了。

   创建许许多多模块后，我们可能希望将某些功能相近的文件组织在同一文件夹下，这里就需要运用包的概念了。
   包对应于文件夹，使用包的方式跟模块也类似，唯一需要注意的是，当文件夹当作包使用时，文件夹需要包含 ~__init__.py~ 文件，主要是为了避免将文件夹名当作普通的字符串。
   ~__init__.py~ 的内容可以为空，一般用来进行包的某些初始化工作或者设置 ~__all__~ 值， ~__all__~ 是在 ~from package-name import *~ 这语句使用的，全部导出定义过的模块。

   可以从包中导入单独的模块:
   1). ~import PackageA.SubPackageA.ModuleA~, 使用时必须用全路径名
   2). 变种: ~from PackageA.SubPackageA import ModuleA~, 可以直接使用模块名而不用加上包前缀。
   3). 也可以直接导入模块中的函数或变量： ~from PackageA.SubPackageA.ModuleA import functionA~

   ~import~ 语句语法：
   1. 当使用 ~from package import item~ 时, ~item~ 可以是 ~package~ 的子模块或子包，或是其他的定义在包中的名字（比如一个函数、类或变量）。
      首先检查 ~item~ 是否定义在包中，不过没找到，就认为 ~item~ 是一个模块并尝试加载它，失败时会抛出一个 ~ImportError~ 异常。

   2. 当使用 ~import item.subitem.subsubitem~ 语法时，最后一个 ~item~ 之前的 ~item~ 必须是包，最后一个 ~item~ 可以是一个模块或包，但不能是类、函数和变量

   3. ~from pacakge import *~

      如果包的 ~__init__.py~ 定义了一个名为 ~__all__~ 的列表变量，它包含的模块名字的列表将作为被导入的模块列表。
      如果没有定义 ~__all__~, 这条语句不会导入所有的 ~package~ 的子模块，它只保证包 ~package~ 被导入，然后导入定义在包中的所有名字。

   包是一个有层次的文件目录结构，它定义了由 n 个模块或 n 个子包组成的 python 应用程序执行环境。

   通俗一点：包是一个包含 ~__init__.py~ 文件的目录，该目录下一定得有这个 ~__init__.py~ 文件和其它模块或子包

** *__main__.py* 和 *__init__.py*

   如果你希望 ~python~ 将一个文件夹作为 ~package~ 对待，那么这个文件夹中必须包含一个名为 ~__init__.py~ 的文件，即使它是空的

   如果你需要 ~python~ 讲一个文件夹作为 ~package~ 执行，那么这个文件夹中必须包含一个名为 ~__main__.py~ 的文件，
   当执行 ~python -m pkg~ 或者 ~python pkg~ 的时候，这个文件中的代码都会被执行
* 类属性和实例属性
  #+BEGIN_SRC python :results output
    class OneClass(object):
        num = 10


    A = OneClass()
    B = OneClass()
    print(A.num, B.num, OneClass.num)

    A.num += 2
    print(A.num, B.num, OneClass.num)

    OneClass.num += 2
    print(A.num, B.num, OneClass.num)
  #+END_SRC

  + *RESULTS:*
    : 10 10 10
    : 12 10 10
    : 12 12 12

  [[https://segmentfault.com/a/1190000002671941][关于Python类属性与实例属性的讨论]]

