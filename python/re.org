#+SETUPFILE: ./_style/style.setup
#+OPTIONS:    H:3 num:nil toc:t \n:nil ::t |:t ^:nil -:t f:t *:t tex:t d:(HIDE) tags:not-in-toc
#+TITLE:      Python 正则表达式
#+AUTHOR:     rgb_24bit

* 模式字符串
  正则表达式中的 ~'\'~ 和 Python 的 ~'\'~ 相冲突， 因此， 正则表达式中的 ~'\'~
  应该写作 ~'\\'~

  当然， 也可以用原始字符串： ~r'\'~
  
* 正则表达式语法
  基本语法： [[https://github.com/rgb-24bit/blog/blob/master/2018/regex.org][正则表达式]]

  Python 对正则表达式的扩展：
  + ~(?iLmsux)~ :: 用于更改解析表达的方式。 它应使用在表达式字符串的开始，或一个或多个空白字符之后。
                   对应： ~re.I(忽略大小写)~, ~re.L(依赖区域设置)~, ~re.M(多行)~, ~re.S(点号匹配所有字符)~, ~re.U(依赖Unicode)~,
                   ~re.X(详细模式)~.

  + ~(?P<name>...)~ :: 对元组命名， 回溯引用可以通过命名引用

  + ~(?P=name)~ :: 回溯引用， 引用命名元组(替换使用 ~\g<name>~)

  + ~(?#...)~ :: 注释

* re 模块方法
  + re.compile(pattern, flags=0) :: 将正则表达式模式编译成一个 *正则表达式对象* ，它可以用于匹配它的 ~match()~ 和 ~search()~ 方法。

       #+BEGIN_SRC python
         prog = re.compile(pattern)
         result = prog.match(string)

         # 等价于
         result = re.match(pattern, string)
       #+END_SRC

  + re.search(pattern, string, flags=0) :: 扫描字符串， 寻找的第一个由该正则表达式模式产生匹配的位置， 并返回相应的 ~MatchObject~ 实例。
       
       匹配失败返回 ~None~

  + re.match(pattern, string, flags=0) :: 在字符串开头匹配模式， 返回相应的 ~MatchObject~ 实例，  匹配失败返回 ~None~

  + re.split(pattern, string, maxsplit=0, flags=0) :: 根据模式 *拆分* 字符串

       #+BEGIN_SRC python
         # \W 非单词字符
         >>> re.split('\W+', 'Words, words, words.')  # 模式不分组
         ['Words', 'words', 'words', '']
         >>> re.split('(\W+)', 'Words, words, words.')  # 模式分组， 返回所有分组
         ['Words', ', ', 'words', ', ', 'words', '.', '']
         >>> re.split('\W+', 'Words, words, words.', 1)  # maxsplit != 0， 最多进行 maxsplit 次分组
         ['Words', 'words, words.']
         >>> re.split('[a-f]+', '0a3B9', flags=re.IGNORECASE)
         ['0', '3', '9']

         >>> re.split('(\W+)', '...words, words...')
         ['', '...', 'words', ', ', 'words', '...', '']
       #+END_SRC

       匹配失败则不进行拆分

  + re.findall(pattern, string, flags=0) :: 从左到右扫描， 返回所有非重叠匹配的模式， 如果模式存在元组， 则返回匹配成功的元组列表

       #+BEGIN_SRC python
         >>> s
         'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
         >>> re.findall(r'a.+', s)
         ['abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ']
         >>> re.findall(r'a(.+)', s)
         ['bcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ']
       #+END_SRC

  + re.finditer(pattern, string, flags) :: 同 ~re.findall~, 不过返回迭代器

  + re.sub(pattern, repl, string, count=0, flags=0) :: 替换操作

       *count* 是替换的最大次数

  + re.subn(pattern, repl, string, count=0, flags=0) :: 同 ~re.sub~, 
       但返回一个元组 ~(new_string, number_of_subs_made)~

  + re.escape(string) :: 将文本中的所有会在正则表达式成为元字符的字符转义为普通字符

       #+BEGIN_SRC python
         re.escape('1234@gmail.com')
         # result
         1234\\@gmai\\.com
       #+END_SRC
       
  + re.purge() :: 清除正则表达式缓存

  + re.error :: 异常

* 正则表达式对象
  除了上一节的函数外， 正则表达式对象还支持：
  + flags :: 正则表达式匹配的标志
  + groups :: 模式中的元组数
  + groupindex :: 模式中的命名元组对应的位置
  + pattern :: 模式字符串

* Match Object
  ~Match Object~ 有一个始终为 ~True~ 的值， 可用于 ~bool~ 判断。 匹配失败返回 ~None~.

  #+BEGIN_SRC python
    match = re.search(pattern, string)
    if match:
        process(match)
  #+END_SRC

** 方法和属性
   - expand(template) :: 对 ~template~ 进行替换操作， 结果和 ~re.sub~ 相同
   
   - group([group1, ...]) :: 返回对应模式分组的字符串， 默认为 ~0~, 即整个分组。 对于命名元组， 可以用字符串获取。
        
        #+BEGIN_SRC python
          >>> m = re.match(r"(\w+) (\w+)", "Isaac Newton, physicist")
          >>> m.group(0)       # The entire match
          'Isaac Newton'
          >>> m.group(1)       # The first parenthesized subgroup.
          'Isaac'
          >>> m.group(2)       # The second parenthesized subgroup.
          'Newton'
          >>> m.group(1, 2)    # Multiple arguments give us a tuple.
          ('Isaac', 'Newton')

          >>> m = re.match(r"(?P<first_name>\w+) (?P<last_name>\w+)", "Malcolm Reynolds")
          >>> m.group('first_name')
          'Malcolm'
          >>> m.group('last_name')
          'Reynolds'

          >>> m.group(1)
          'Malcolm'
          >>> m.group(2)
          'Reynolds'


          # 如果一组匹配多次，只有最后一个匹配可访问
          >>> m = re.match(r"(..)+", "a1b2c3")  # Matches 3 times.
          >>> m.group(1)                        # Returns only the last match.
          'c3'
        #+END_SRC

   - groups([default]) :: 类似 ~group~, 返回所有子组， 默认从 ~1~ 开始

   - groupdict([default]) :: 返回命名元组对应的匹配值

   [[http://usyiyi.cn/translate/python_278/library/re.html][更多]]

