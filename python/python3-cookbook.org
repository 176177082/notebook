#+TITLE:      Python3-cookbook 阅读笔记

* 目录                                                    :TOC_4_gh:noexport:
- [[#第一章-数据结构和算法][第一章: 数据结构和算法]]
  - [[#解压序列赋值给多个变量][解压序列赋值给多个变量]]
  - [[#解压可迭代对象赋值给多个变量][解压可迭代对象赋值给多个变量]]
  - [[#保留最后-n-个元素][保留最后 N 个元素]]
  - [[#查找最大或最小的-n-个元素][查找最大或最小的 N 个元素]]
  - [[#实现一个优先级队列][实现一个优先级队列]]
  - [[#字典中的键映射多个值][字典中的键映射多个值]]
  - [[#查找两字典的相同点][查找两字典的相同点]]

* 第一章: 数据结构和算法
** 解压序列赋值给多个变量
   *任何* 可迭代的对象都可以通过下面的方式进行 *解压赋值*:
   #+BEGIN_SRC python
     >>> a, b, c, d, e = 'Hello'
   #+END_SRC

   *PS:* 变量的数量必须跟序列元素的数量一样

** 解压可迭代对象赋值给多个变量
   变量的数量和序列元素的数量不一样是可以通过下面的方式进行 *解压赋值*:
   #+BEGIN_SRC python
     >>> record = ('Dave', 'dave@example.com', '773-555-1212', '847-555-1212')
     >>> name, email, *phone_numbers = record
     >>> name
     'Dave'
     >>> email
     'dave@example.com'
     >>> phone_numbers
     ['773-555-1212', '847-555-1212']
   #+END_SRC

** 保留最后 N 个元素
   使用 ~collections.deque~ 保留迭代操作或者其他操作的最后有限的几个元素的历史记录：
   #+BEGIN_SRC python
     >>> from collections import deque
     >>> q = deque(maxlen=5)
     >>> q.extend([1,2,3,4,5,6,7,8,9,0])
     >>> q
     deque([6, 7, 8, 9, 0], maxlen=5)
   #+END_SRC

** 查找最大或最小的 N 个元素
   使用 ~heapq.nlargest()~ 和 ~heapq.nsmallest()~ 从一个集合中获得最大或者最小的 N 个元素列表：
   #+BEGIN_SRC python
     portfolio = [
         {'name': 'IBM', 'shares': 100, 'price': 91.1},
         {'name': 'AAPL', 'shares': 50, 'price': 543.22},
         {'name': 'FB', 'shares': 200, 'price': 21.09},
         {'name': 'HPQ', 'shares': 35, 'price': 31.75},
         {'name': 'YHOO', 'shares': 45, 'price': 16.35},
         {'name': 'ACME', 'shares': 75, 'price': 115.65}
     ]
     cheap = heapq.nsmallest(3, portfolio, key=lambda s: s['price'])
     expensive = heapq.nlargest(3, portfolio, key=lambda s: s['price'])
   #+END_SRC

   *PS:* 可以通过调用 ~heapq.heapify()~ 对一个序列进行 *堆排序*
   
   堆中， ~heap[0]~ 永远是最小的元素， 而 ~heapq.heappop()~ 会将第一个元素弹出，
   后面的元素补上。

** 实现一个优先级队列
   利用 ~heapq~ 模块实现一个简单的优先级队列:
   #+BEGIN_SRC python
     import heapq

     class PriorityQueue:
         def __init__(self):
             self._queue = []
             self._index = 0

         def push(self, item, priority):
             heapq.heappush(self._queue, (-priority, self._index, item))
             self._index += 1

         def pop(self):
             return heapq.heappop(self._queue)[-1]


     # use

     >>> class Item:
     ...     def __init__(self, name):
     ...         self.name = name
     ...     def __repr__(self):
     ...         return 'Item({!r})'.format(self.name)
     ...
     >>> q = PriorityQueue()
     >>> q.push(Item('foo'), 1)
     >>> q.push(Item('bar'), 5)
     >>> q.push(Item('spam'), 4)
     >>> q.push(Item('grok'), 1)
     >>> q.pop()
     Item('bar')
     >>> q.pop()
     Item('spam')
     >>> q.pop()
     Item('foo')
     >>> q.pop()
     Item('grok')
   #+END_SRC

   核心 ~(-priority, self._index, item)~: ~-priority~ 保证排序为优先级 高 ==> 低,
   因为 ~priority~ 越大, ~-priority~ 越小， 而堆中越小的元素越靠前。

   递增的 ~_index~ 保证同一优先级的情况下按插入元素的顺序排序。

   ~item~ 是要储存或获取的元素。

** 字典中的键映射多个值
   实用 ~defaultdict~ 简洁的实现多值映射：
   #+BEGIN_SRC python
     d = {} # 一个普通的字典
     d.setdefault('a', []).append(1)
     d.setdefault('a', []).append(2)
     d.setdefault('b', []).append(4)

     d = defaultdict(list)
     d['a'].append(1)
     d['a'].append(2)
     d['b'].append(4)
   #+END_SRC

** 查找两字典的相同点
   为了寻找两个字典的相同点，可以简单的在两字典的 keys() 或者 items() 方法
   返回结果上执行集合操作. items() 也支持集合操作。

   #+BEGIN_SRC python
     a = {
         'x' : 1,
         'y' : 2,
         'z' : 3
     }

     b = {
         'w' : 10,
         'x' : 11,
         'y' : 2
     }

     # Find keys in common
     a.keys() & b.keys() # { 'x', 'y' }

     # Find keys in a that are not in b
     a.keys() - b.keys() # { 'z' }

     # Find (key,value) pairs in common
     a.items() & b.items() # { ('y', 2) }

     # Make a new dictionary with certain keys removed
     c = {key:a[key] for key in a.keys() - {'z', 'w'}}
     # c is {'x': 1, 'y': 2}
   #+END_SRC

   *PS:* ~python2~ 可以使用 ~viewkeys()~, ~viewitems()~ 和 ~viewvalues()~.

