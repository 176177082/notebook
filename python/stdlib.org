#+TITLE:      Python 标准库笔记

* 目录                                                    :TOC_4_gh:noexport:
- [[#调试和分析][调试和分析]]
- [[#通用操作系统服务][通用操作系统服务]]
- [[#功能编程模块][功能编程模块]]
- [[#开发工具][开发工具]]
- [[#数据类型][数据类型]]
- [[#文件和目录访问][文件和目录访问]]
- [[#数据压缩和存档][数据压缩和存档]]
- [[#python-语言服务][Python 语言服务]]
- [[#python-运行时服务][Python 运行时服务]]

* 调试和分析
  + pdb :: Python 调试器
    + [[https://www.ibm.com/developerworks/cn/linux/l-cn-pythondebugger/index.html][Python 代码调试技巧]]

  + traceback :: 打印或检索堆栈回溯

* 通用操作系统服务
  + argparse :: 命令行参数解析                
    + [[http://blog.xiayf.cn/2013/03/30/argparse/][argparse - 命令行选项与参数解析（译）]]

  + logging :: 日志记录
    + [[http://python.jobbole.com/81666/][每个 Python 程序员都要知道的日志实践]]
    + [[http://blog.jobbole.com/113413/][日志的艺术（The art of logging）]]
    + [[https://www.cnblogs.com/yyds/p/6901864.html][Python之日志处理（logging模块）]]
    + [[http://python.jobbole.com/86887/][Python 中的 logging 模块]]
  
  + io :: 包含 ~StringIO~ 和 ~BytesIO~

* 功能编程模块
  + itertools ::  为高效循环创建迭代器
    + [[http://wklken.me/posts/2013/08/20/python-extra-itertools.html][http://wklken.me/posts/2013/08/20/python-extra-itertools.html]]

* 开发工具
  + doctest :: 通过 *文档字符串* 进行测试
    + [[https://docs.python.org/2/library/doctest.html][doctest — Test interactive Python examples]]
      #+BEGIN_SRC python
        if __name__ == "__main__":
            import doctest
            doctest.testmod()
      #+END_SRC

      参数 ~-v~ 列出详细的测试用例: ~python script.py -v~

  + unittest :: 单元测试框架
    + [[https://docs.python.org/3.6/library/unittest.html][unittest — Unit testing framework]]
      #+BEGIN_SRC python
        import unittest

        class TestStringMethods(unittest.TestCase):

            def test_upper(self):
                self.assertEqual('foo'.upper(), 'FOO')

            def test_isupper(self):
                self.assertTrue('FOO'.isupper())
                self.assertFalse('Foo'.isupper())

            def test_split(self):
                s = 'hello world'
                self.assertEqual(s.split(), ['hello', 'world'])
                # check that s.split fails when the separator is not a string
                with self.assertRaises(TypeError):
                    s.split(2)

        if __name__ == '__main__':
            unittest.main()
      #+END_SRC

* 数据类型
  + heapq :: 为 ~Python~ 提供 *堆* 数据类型的支持
    + [[https://docs.python.org/3/library/heapq.html][heapq — Heap queue algorithm]]
      #+BEGIN_SRC python
        >>> def heapsort(iterable):
        ...     h = []
        ...     for value in iterable:
        ...         heappush(h, value)
        ...     return [heappop(h) for i in range(len(h))]
        ...
        >>> heapsort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0])
        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
      #+END_SRC

      堆数据结构最重要的特征是 ~heap[0]~ 永远是最小的元素

* 文件和目录访问
  [[http://www.cnblogs.com/funsion/p/4017989.html][Python 默认模块 os 和 shutil 实用函数]].

  + os.path :: 常见的路径名操作

  + shutil :: 高级文件操作

  + pathlib :: 面向对象的文件系统路径
    + [[https://docs.python.org/3/library/pathlib.html][pathlib — Object-oriented filesystem paths]]

  + glob :: Unix 样式路径名模式扩展
    + [[https://docs.python.org/3/library/glob.html][glob — Unix style pathname pattern expansion]]

* 数据压缩和存档
  + gzip :: 支持 ~gzip~ 文件
    + [[https://docs.python.org/3/library/gzip.html][gzip — Support for gzip files]]
 
* Python 语言服务
  + ast :: 解析 ~Python~ 语句可以保存为抽象语法树
    + [[https://docs.python.org/3/library/ast.html][ast — Abstract Syntax Trees]]
      
    可以通过继承 ~ast.NodeVisitor~ 定义在访问到指定节点是的行为， 访问
    指定节点时调用的方法为 ~visit_NodeClass~.

    #+BEGIN_SRC python
      class ImportVisitor(ast.NodeVisitor):
          def __init__(self):
              super(ast.NodeVisitor, self).__init__()

          def visit_Import(self, node):
              pass

          def visit_ImportFrom(self, node):
              pass
    #+END_SRC
* Python 运行时服务
  + contextlib :: 上下文管理器的使用工具
    + [[https://docs.python.org/3/library/contextlib.html][contextlib — Utilities for with-statement contexts]]
      #+BEGIN_SRC python
        from contextlib import contextmanager

        @contextmanager
        def tag(name):
            print("<%s>" % name)
            yield
            print("</%s>" % name)

        >>> with tag("h1"):
        ...    print("foo")
        ...
        <h1>
        foo
        </h1>
      #+END_SRC
      
      ~__enter__~ 执行到 ~yield~, ~__exit__~ 执行 ~yield~ 后的部分
