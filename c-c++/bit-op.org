#+TITLE:      位运算笔记

* 目录                                                    :TOC_4_gh:noexport:
- [[#字符][字符]]
- [[#移位][移位]]
- [[#掩码运算][掩码运算]]
- [[#进制转化][进制转化]]
- [[#简单的技巧][简单的技巧]]
- [[#加减乘除][加减乘除]]
- [[#字节对齐][字节对齐]]

* 字符
  ASCII 码：
  + ~0-9~: ~0x30~ - ~0x39~
  + ~a-z~: ~0x61~ - ~0x7A~

* 移位
  + 左移位： 补 0
  + 逻辑右移： 补 0 (无符号数)
  + 算术右移： 补最高位有效值 (有符号数)

* 掩码运算
  掩码 ~0xFF~ 获取一个二进制数据的最低 8 位数据， 其他位置为 0
  
* 进制转化
  当 ~x = 2ⁿ~, ~n = i + 4j(0 ≤ i ≤ 3)~.
  
  可以把 ~x~ 写成十六进制数字 ~1(i=0), 4(i=2), 8(i=3)~ 开头， 后面紧跟 ~j~ 个十六进制 ~0~.

  例： ~2014 = 2**11, n = 11 = 3 + 4·2, hex = 0x800~

* 简单的技巧
  + 判断奇偶: ~num & 1 = 0~ 为偶, ~num & 1 = 1~ 为奇.
  + int 型最大值: ~(1 << 31) - 1~ 或 =~(1 << 31)=.
  + int 型最小值: ~1 << 31~.
  + 乘2: ~num << 1~.
  + 除2: ~num >> 1~.
  + 乘2的n次方: ~num << n~.
  + 除2的n次方: ~num >> n~.
  + 异或： ~a ^ a = 0~, ~a ^ b ^ a = b(a != b)~
  + 不会零除: ~num && 5 / num~

* 加减乘除 
  #+BEGIN_SRC C
    /* 位运算 + */
    int add(int a, int b) {
      int sum = a;
      int carry = n;

      while (carry) {
        int tmp = sum;
        sum = tmp ^ carry;
        carry = (tmp & carry) << 1;
      }

      return sum;
    }


    /* 位运算 - */
    int sub(int a, int b) {
      int diff = add(~b, 1);

      diff = add(a, diff);

      return diff;
    }
  #+END_SRC

  乘除: [[http://www.cnblogs.com/kiven-code/archive/2012/09/15/2686922.html][博客园]]
  
  两数之和：
  #+BEGIN_SRC C
    int getSum(int a, int b) {
      while (b != 0) {
        int c = a ^ b;
        b = (a & b) << 1;
        a = c;
      }
      return a;
    }
  #+END_SRC

* 字节对齐
  + 4 字节对齐
    #+BEGIN_SRC C
      size_t alingn4(size_t size) {
        if (size & 0x3 == 0) {
          return size;
        }
        return ((size >> 2) + 1) << 2;
      }
    #+END_SRC
    
    4 的倍数最后两位必然为 0, 0x3 为 11.

  + 8 字节对齐
    #+BEGIN_SRC C
      size_t align8(size_t size) {
        if (size & 0x7 == 0) {
          return size;
        }
        return ((size >> 3) + 1) << 3;
      }
    #+END_SRC

    8 的倍数最后三位必然为 0, 0x7 为 111.
