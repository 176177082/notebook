#+SETUPFILE:  ./_style/style.setup
#+OPTIONS:    H:3 num:nil toc:t \n:nil ::t |:t ^:nil -:t f:t *:t tex:t d:(HIDE) tags:not-in-toc
#+TITLE:      位运算
#+AUTHOR:     rgb_24bit
#+EMAIL:      rgb_24bit@foxmail.com
#+DATE:       <2018-02-05 周一>

* 字符
  ASCII 码：
  + ~0-9~: ~0x30~ - ~0x39~
  + ~a-z~: ~0x61~ - ~0x7A~

* 移位
  + 左移位： 补 0
  + 逻辑右移： 补 0 (无符号数)
  + 算术右移： 补最高位有效值 (有符号数)

* 掩码运算
  掩码 ~0xFF~ 获取一个二进制数据的最低 8 位数据， 其他位置为 0

* 进制转化
  当 ~x = 2ⁿ~, ~n = i + 4j(0 ≤ i ≤ 3)~.
  
  可以把 ~x~ 写成十六进制数字 ~1(i=0), 4(i=2), 8(i=3)~ 开头， 后面紧跟 ~j~ 个十六进制 ~0~.

  例： ~2014 = 2**11, n = 11 = 3 + 4·2, hex = 0x800~

* 简单的技巧
  + 判断奇偶: ~num & 1 = 0~ 为偶, ~num & 1 = 1~ 为奇.
  + int 型最大值: ~(1 << 31) - 1~ 或 =~(1 << 31)=.
  + int 型最小值: ~1 << 31~.
  + 乘2: ~num << 1~.
  + 除2: ~num >> 1~.
  + 乘2的n次方: ~num << n~.
  + 除2的n次方: ~num >> n~.
  + 异或： ~a ^ a = 0~, ~a ^ b ^ a = b(a != b)~
  + 不会零除: ~num && 5 / num~

* 加减乘除 
  #+BEGIN_SRC C
    /* 位运算 + */
    int add(int a, int b) {
      int sum = a;
      int carry = n;

      while (carry) {
        int tmp = sum;
        sum = tmp ^ carry;
        carry = (tmp & carry) << 1;
      }

      return sum;
    }


    /* 位运算 - */
    int sub(int a, int b) {
      int diff = add(~b, 1);

      diff = add(a, diff);

      return diff;
    }
  #+END_SRC

  乘除: [[http://www.cnblogs.com/kiven-code/archive/2012/09/15/2686922.html][博客园]]
  
