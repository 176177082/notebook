#+SETUPFILE:  ./_style/style.setup
#+TITLE:      LeetCode 笔记

* 目录                                                    :TOC_4_gh:noexport:
- [[#回文数---题-9][回文数 - 题 9]]
- [[#罗马数字转整数---题-13][罗马数字转整数 - 题 13]]
- [[#最大子序和---题-53][最大子序和 - 题 53]]
- [[#使用最小花费爬楼梯---题-746][使用最小花费爬楼梯 - 题 746]]

* 回文数 - 题 9
  + [[https://leetcode-cn.com/problems/palindrome-number/description/][Question]]

  Python:
  #+BEGIN_SRC python
    class Solution:
        def isPalindrome(self, x):
            """
            :type x: int
            :rtype: bool
            """
            if x < 0 or (x % 10 == 0 and x != 0):
                return False
        
            revertedNumber = 0
            while x > revertedNumber:
                revertedNumber = revertedNumber * 10 + x % 10
                x = x // 10
        
            return revertedNumber == x or x == revertedNumber // 10
  #+END_SRC

* 罗马数字转整数 - 题 13
  + [[https://leetcode-cn.com/problems/roman-to-integer/description/][Question]]

  *思路:* 从前向后遍历罗马数字，如果某个数比前一个数小，则加上该数。
  反之，减去前一个数的两倍然后加上该数。

  Python:
  #+BEGIN_SRC python
    class Solution:
        def romanToInt(self, s):
            """
            :type s: str
            :rtype: int
            """
            roman = dict(I=1, V=5, X=10, L=50, C=100, D=500, M=1000)
            pre = res = roman[s[0]]
            for n in s[1:]:
                if roman[n] <= pre:
                    res += roman[n]
                else:
                    res = res - 2*pre + roman[n]
                pre = roman[n]
            return res
  #+END_SRC

* 最大子序和 - 题 53
  + [[https://leetcode-cn.com/problems/maximum-subarray/description/][Question]]

  Python:
  #+BEGIN_SRC python
    class Solution:
        def maxSubArray(self, nums):
            """
            :type nums: List[int]
            :rtype: int
            """
            maxSub = maxCur = nums[0]
            for num in nums[1:]:
                maxCur = max(maxCur + num, num)
                maxSub = max(maxCur, maxSub)
            return maxSub
    #+END_SRC
    
* 使用最小花费爬楼梯 - 题 746
  + [[https://leetcode-cn.com/problems/min-cost-climbing-stairs/description/][Question]]

  Python:
  #+BEGIN_SRC python
    class Solution:
        def minCostClimbingStairs(self, cost):
            """
            :type cost: List[int]
            :rtype: int
            """
            f1 = f2 = 0
            for x in reversed(cost):
                f1, f2 = x + min(f1, f2), f1
            return min(f1, f2)
  #+END_SRC

  C:
  #+BEGIN_SRC C
    int minCostClimbingStairs(int* cost, int costSize) {
      int f1 = 0, f2 = 0;

      for (int i = costSize - 1; i >= 0; --i) {
        int tmp = f1;
        f1 = cost[i] + (f1 > f2 ? f2 : f1);
        f2 = tmp;
      }

      return f1 > f2 ? f2 : f1;
    }
  #+END_SRC

