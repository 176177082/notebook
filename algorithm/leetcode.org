#+SETUPFILE:  ./_style/style.setup
#+TITLE:      LeetCode 笔记

* 目录                                                    :TOC_4_gh:noexport:
- [[#回文数---题-9][回文数 - 题 9]]
- [[#罗马数字转整数---题-13][罗马数字转整数 - 题 13]]
- [[#最大子序和---题-53][最大子序和 - 题 53]]
- [[#使用最小花费爬楼梯---题-746][使用最小花费爬楼梯 - 题 746]]
- [[#重复叠加字符串匹配---题-686][重复叠加字符串匹配 - 题 686]]
- [[#计数二进制子串---题-696][计数二进制子串 - 题 696]]

* 回文数 - 题 9
  + [[https://leetcode-cn.com/problems/palindrome-number/description/][Question]]

  Python:
  #+BEGIN_SRC python
    class Solution:
        def isPalindrome(self, x):
            """
            :type x: int
            :rtype: bool
            """
            if x < 0 or (x % 10 == 0 and x != 0):
                return False
        
            revertedNumber = 0
            while x > revertedNumber:
                revertedNumber = revertedNumber * 10 + x % 10
                x = x // 10
        
            return revertedNumber == x or x == revertedNumber // 10
  #+END_SRC

* 罗马数字转整数 - 题 13
  + [[https://leetcode-cn.com/problems/roman-to-integer/description/][Question]]

  *思路:* 从前向后遍历罗马数字，如果某个数比前一个数小，则加上该数。
  反之，减去前一个数的两倍然后加上该数。

  Python:
  #+BEGIN_SRC python
    class Solution:
        def romanToInt(self, s):
            """
            :type s: str
            :rtype: int
            """
            roman = dict(I=1, V=5, X=10, L=50, C=100, D=500, M=1000)
            pre = res = roman[s[0]]
            for n in s[1:]:
                if roman[n] <= pre:
                    res += roman[n]
                else:
                    res = res - 2*pre + roman[n]
                pre = roman[n]
            return res
  #+END_SRC

* 最大子序和 - 题 53
  + [[https://leetcode-cn.com/problems/maximum-subarray/description/][Question]]

  Python:
  #+BEGIN_SRC python
    class Solution:
        def maxSubArray(self, nums):
            """
            :type nums: List[int]
            :rtype: int
            """
            maxSub = maxCur = nums[0]
            for num in nums[1:]:
                maxCur = max(maxCur + num, num)
                maxSub = max(maxCur, maxSub)
            return maxSub
    #+END_SRC
    
* 使用最小花费爬楼梯 - 题 746
  + [[https://leetcode-cn.com/problems/min-cost-climbing-stairs/description/][Question]]

  Python:
  #+BEGIN_SRC python
    class Solution:
        def minCostClimbingStairs(self, cost):
            """
            :type cost: List[int]
            :rtype: int
            """
            f1 = f2 = 0
            for x in reversed(cost):
                f1, f2 = x + min(f1, f2), f1
            return min(f1, f2)
  #+END_SRC

  C:
  #+BEGIN_SRC C
    int minCostClimbingStairs(int* cost, int costSize) {
      int f1 = 0, f2 = 0;

      for (int i = costSize - 1; i >= 0; --i) {
        int tmp = f1;
        f1 = cost[i] + (f1 > f2 ? f2 : f1);
        f2 = tmp;
      }

      return f1 > f2 ? f2 : f1;
    }
  #+END_SRC

* 重复叠加字符串匹配 - 题 686
  + [[https://leetcode-cn.com/problems/repeated-string-match/description/][Question]]

  #+BEGIN_SRC python
    class Solution(object):
        def repeatedStringMatch(self, A, B):
            q = (len(B) - 1) // len(A) + 1
            for i in range(2):
                if B in A * (q+i): return q+i
            return -1
  #+END_SRC

* 计数二进制子串 - 题 696
  + [[https://leetcode-cn.com/problems/count-binary-substrings/description/][Question]]

  Python:
  #+BEGIN_SRC python
    class Solution:
        def countBinarySubstrings(self, s):
            """
            :type s: str
            :rtype: int
            """
            group = [1]
            for i in range(1, len(s)):
                if s[i] != s[i - 1]:
                    group.append(1)
                else:
                    group[-1] += 1
                
            ans = 0
            for i in range(1, len(group)):
                ans += min(group[i], group[i - 1])
        
            return ans
  #+END_SRC

  C:
  #+BEGIN_SRC C
    int countBinarySubstrings(char* s) {
      int ans = 0, prev = 0, cur = 1;
    
      for (int i = 1; s[i] != '\0'; ++i) {
        if (s[i] != s[i - 1]) {
          ans += prev < cur ? prev : cur;
          prev = cur;
          cur = 1;
        }
        else {
          cur += 1;
        }
      }
    
      return ans + (prev < cur ? prev : cur);
    }
  #+END_SRC

