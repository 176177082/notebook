#+SETUPFILE:  ./_style/style.setup
#+TITLE:      LeetCode 笔记

* 目录                                                    :TOC_4_gh:noexport:
- [[#回文数---题-9][回文数 - 题 9]]
- [[#罗马数字转整数---题-13][罗马数字转整数 - 题 13]]
- [[#最大子序和---题-53][最大子序和 - 题 53]]
- [[#x-的平方根---题-69][x 的平方根 - 题 69]]
- [[#使用最小花费爬楼梯---题-746][使用最小花费爬楼梯 - 题 746]]
- [[#重复叠加字符串匹配---题-686][重复叠加字符串匹配 - 题 686]]
- [[#计数二进制子串---题-696][计数二进制子串 - 题 696]]
- [[#数组的度---题-697][数组的度 - 题 697]]
- [[#1-比特与-2-比特字符---题-317][1 比特与 2 比特字符 - 题 317]]
- [[#词典中最长的单词---题-720][词典中最长的单词 - 题 720]]
- [[#寻找数组的中心索引---题-724][寻找数组的中心索引 - 题 724]]

* 回文数 - 题 9
  + [[https://leetcode-cn.com/problems/palindrome-number/description/][Question]]

  Python:
  #+BEGIN_SRC python
    class Solution:
        def isPalindrome(self, x):
            """
            :type x: int
            :rtype: bool
            """
            if x < 0 or (x % 10 == 0 and x != 0):
                return False
        
            revertedNumber = 0
            while x > revertedNumber:
                revertedNumber = revertedNumber * 10 + x % 10
                x = x // 10
        
            return revertedNumber == x or x == revertedNumber // 10
  #+END_SRC

* 罗马数字转整数 - 题 13
  + [[https://leetcode-cn.com/problems/roman-to-integer/description/][Question]]

  *思路:* 从前向后遍历罗马数字，如果某个数比前一个数小，则加上该数。
  反之，减去前一个数的两倍然后加上该数。

  Python:
  #+BEGIN_SRC python
    class Solution:
        def romanToInt(self, s):
            """
            :type s: str
            :rtype: int
            """
            roman = dict(I=1, V=5, X=10, L=50, C=100, D=500, M=1000)
            pre = res = roman[s[0]]
            for n in s[1:]:
                if roman[n] <= pre:
                    res += roman[n]
                else:
                    res = res - 2*pre + roman[n]
                pre = roman[n]
            return res
  #+END_SRC

* 最大子序和 - 题 53
  + [[https://leetcode-cn.com/problems/maximum-subarray/description/][Question]]

  Python:
  #+BEGIN_SRC python
    class Solution:
        def maxSubArray(self, nums):
            """
            :type nums: List[int]
            :rtype: int
            """
            maxSub = maxCur = nums[0]
            for num in nums[1:]:
                maxCur = max(maxCur + num, num)
                maxSub = max(maxCur, maxSub)
            return maxSub
    #+END_SRC
    
* x 的平方根 - 题 69
  + [[https://leetcode-cn.com/problems/sqrtx/description/][Question]]
    
  Python:
  #+BEGIN_SRC python
    class Solution:
        def mySqrt(self, x):
            if x == 0: return 0
            left, right = 1, x
            while True:
                mid = (left + right) // 2
                if mid > (x // mid):
                    right = mid - 1
                else:
                    if (mid + 1) > (x // (mid + 1)):
                        return mid
                    left = mid + 1
  #+END_SRC

  C:
  #+BEGIN_SRC C
    int mySqrt(int x) {
      if (x == 0) {
        return 0;
      }

      int left = 1, right = x;
      while (true) {
        int mid = left + (right - left) / 2;  /* 防止溢出 */

        if (mid > (x / mid)) {
          right = mid - 1;
        }
        else {
          if ((mid + 1) > (x / (mid + 1))) {
            return mid;
          }
          left = mid + 1;
        }
      }

      return 0;
    }
  #+END_SRC

* 使用最小花费爬楼梯 - 题 746
  + [[https://leetcode-cn.com/problems/min-cost-climbing-stairs/description/][Question]]

  Python:
  #+BEGIN_SRC python
    class Solution:
        def minCostClimbingStairs(self, cost):
            """
            :type cost: List[int]
            :rtype: int
            """
            f1 = f2 = 0
            for x in reversed(cost):
                f1, f2 = x + min(f1, f2), f1
            return min(f1, f2)
  #+END_SRC

  C:
  #+BEGIN_SRC C
    int minCostClimbingStairs(int* cost, int costSize) {
      int f1 = 0, f2 = 0;

      for (int i = costSize - 1; i >= 0; --i) {
        int tmp = f1;
        f1 = cost[i] + (f1 > f2 ? f2 : f1);
        f2 = tmp;
      }

      return f1 > f2 ? f2 : f1;
    }
  #+END_SRC

* 重复叠加字符串匹配 - 题 686
  + [[https://leetcode-cn.com/problems/repeated-string-match/description/][Question]]

  #+BEGIN_SRC python
    class Solution(object):
        def repeatedStringMatch(self, A, B):
            q = (len(B) - 1) // len(A) + 1
            for i in range(2):
                if B in A * (q+i): return q+i
            return -1
  #+END_SRC

* 计数二进制子串 - 题 696
  + [[https://leetcode-cn.com/problems/count-binary-substrings/description/][Question]]

  Python:
  #+BEGIN_SRC python
    class Solution:
        def countBinarySubstrings(self, s):
            """
            :type s: str
            :rtype: int
            """
            group = [1]
            for i in range(1, len(s)):
                if s[i] != s[i - 1]:
                    group.append(1)
                else:
                    group[-1] += 1
                
            ans = 0
            for i in range(1, len(group)):
                ans += min(group[i], group[i - 1])
        
            return ans
  #+END_SRC

  C:
  #+BEGIN_SRC C
    int countBinarySubstrings(char* s) {
      int ans = 0, prev = 0, cur = 1;
    
      for (int i = 1; s[i] != '\0'; ++i) {
        if (s[i] != s[i - 1]) {
          ans += prev < cur ? prev : cur;
          prev = cur;
          cur = 1;
        }
        else {
          cur += 1;
        }
      }
    
      return ans + (prev < cur ? prev : cur);
    }
  #+END_SRC

* 数组的度 - 题 697
  + [[https://leetcode-cn.com/problems/degree-of-an-array/description/][Question]]

  Python:
  #+BEGIN_SRC python
    # https://leetcode.com/problems/degree-of-an-array/solution/
    class Solution(object):
        def findShortestSubArray(self, nums):
            left, right, count = {}, {}, {}
            for i, x in enumerate(nums):
                if x not in left: left[x] = i
                right[x] = i
                count[x] = count.get(x, 0) + 1

            ans = len(nums)
            degree = max(count.values())
            for x in count:
                if count[x] == degree:
                    ans = min(ans, right[x] - left[x] + 1)

            return ans
  #+END_SRC

* 1 比特与 2 比特字符 - 题 317
  + [[https://leetcode-cn.com/problems/1-bit-and-2-bit-characters/description/][Question]]

  Python:
  #+BEGIN_SRC python
    class Solution:
        def isOneBitCharacter(self, bits):
            index = 0
            while index < len(bits) - 1:
                if bits[index] == 1:
                    index += 2
                else:
                    index += 1
            return index == len(bits) - 1
  #+END_SRC

  C:
  #+BEGIN_SRC C
    bool isOneBitCharacter(int* bits, int bitsSize) {
      for (int i = 0; i < bitsSize; ++i) {
        if (bits[i] == 1) {
          if ((i + 2) == bitsSize) {
            return false;
          }
          i += 1;  /* 循环会自动加 1 */
        }
      }
      return true;
    }
  #+END_SRC

* 词典中最长的单词 - 题 720
  + [[https://leetcode-cn.com/problems/longest-word-in-dictionary/description/][Question]]

  Python:
  #+BEGIN_SRC python
    class Solution:
        def longestWord(self, words):
            ans, wordset = str(), set(words)
            for word in words:
                if len(word) > len(ans) or (len(word) == len(ans) and word < ans):
                    if all(word[:k] in wordset for k in range(1, len(word))):
                        ans = word
            return ans
  #+END_SRC

* 寻找数组的中心索引 - 题 724
  + [[https://leetcode-cn.com/problems/find-pivot-index/description/][Question]]
    
  Python:
  #+BEGIN_SRC python
    class Solution:
        def pivotIndex(self, nums):
            nsum, leftSum = sum(nums), 0
            for i, num in enumerate(nums):
                if leftSum == (nsum - num - leftSum):
                    return i
                leftSum += num
            return -1
  #+END_SRC

  C:
  #+BEGIN_SRC C
    int pivotIndex(int* nums, int numsSize) {
      int sum = 0;
      for (int i = 0; i < numsSize; ++i) {
        sum += nums[i];
      }

      int leftSum = 0;
      for (int i = 0; i < numsSize; ++i) {
        if (leftSum == (sum - nums[i] - leftSum)) {
          return i;
        }
        leftSum += nums[i];
      }

      return -1;
    }
  #+END_SRC
