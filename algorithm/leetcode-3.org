#+TITLE:      LeetCode 601-800

* 目录                                                    :TOC_4_gh:noexport:
- [[#重复叠加字符串匹配---题-686][重复叠加字符串匹配 - 题 686]]
- [[#计数二进制子串---题-696][计数二进制子串 - 题 696]]
- [[#数组的度---题-697][数组的度 - 题 697]]
- [[#词典中最长的单词---题-720][词典中最长的单词 - 题 720]]
- [[#寻找数组的中心索引---题-724][寻找数组的中心索引 - 题 724]]
- [[#使用最小花费爬楼梯---题-746][使用最小花费爬楼梯 - 题 746]]

* 重复叠加字符串匹配 - 题 686
  + [[https://leetcode-cn.com/problems/repeated-string-match/description/][Question]]

  #+BEGIN_SRC python
    class Solution(object):
        def repeatedStringMatch(self, A, B):
            q = (len(B) - 1) // len(A) + 1
            for i in range(2):
                if B in A * (q+i): return q+i
            return -1
  #+END_SRC

* 计数二进制子串 - 题 696
  + [[https://leetcode-cn.com/problems/count-binary-substrings/description/][Question]]

  Python:
  #+BEGIN_SRC python
    class Solution:
        def countBinarySubstrings(self, s):
            """
            :type s: str
            :rtype: int
            """
            group = [1]
            for i in range(1, len(s)):
                if s[i] != s[i - 1]:
                    group.append(1)
                else:
                    group[-1] += 1
                
            ans = 0
            for i in range(1, len(group)):
                ans += min(group[i], group[i - 1])
        
            return ans
  #+END_SRC

  C:
  #+BEGIN_SRC C
    int countBinarySubstrings(char* s) {
      int ans = 0, prev = 0, cur = 1;
    
      for (int i = 1; s[i] != '\0'; ++i) {
        if (s[i] != s[i - 1]) {
          ans += prev < cur ? prev : cur;
          prev = cur;
          cur = 1;
        }
        else {
          cur += 1;
        }
      }
    
      return ans + (prev < cur ? prev : cur);
    }
  #+END_SRC

* 数组的度 - 题 697
  + [[https://leetcode-cn.com/problems/degree-of-an-array/description/][Question]]

  Python:
  #+BEGIN_SRC python
    # https://leetcode.com/problems/degree-of-an-array/solution/
    class Solution(object):
        def findShortestSubArray(self, nums):
            left, right, count = {}, {}, {}
            for i, x in enumerate(nums):
                if x not in left: left[x] = i
                right[x] = i
                count[x] = count.get(x, 0) + 1

            ans = len(nums)
            degree = max(count.values())
            for x in count:
                if count[x] == degree:
                    ans = min(ans, right[x] - left[x] + 1)

            return ans
  #+END_SRC

* 词典中最长的单词 - 题 720
  + [[https://leetcode-cn.com/problems/longest-word-in-dictionary/description/][Question]]

  Python:
  #+BEGIN_SRC python
    class Solution:
        def longestWord(self, words):
            ans, wordset = str(), set(words)
            for word in words:
                if len(word) > len(ans) or (len(word) == len(ans) and word < ans):
                    if all(word[:k] in wordset for k in range(1, len(word))):
                        ans = word
            return ans
  #+END_SRC

* 寻找数组的中心索引 - 题 724
  + [[https://leetcode-cn.com/problems/find-pivot-index/description/][Question]]
    
  Python:
  #+BEGIN_SRC python
    class Solution:
        def pivotIndex(self, nums):
            nsum, leftSum = sum(nums), 0
            for i, num in enumerate(nums):
                if leftSum == (nsum - num - leftSum):
                    return i
                leftSum += num
            return -1
  #+END_SRC

  C:
  #+BEGIN_SRC C
    int pivotIndex(int* nums, int numsSize) {
      int sum = 0;
      for (int i = 0; i < numsSize; ++i) {
        sum += nums[i];
      }

      int leftSum = 0;
      for (int i = 0; i < numsSize; ++i) {
        if (leftSum == (sum - nums[i] - leftSum)) {
          return i;
        }
        leftSum += nums[i];
      }

      return -1;
    }
  #+END_SRC
* 使用最小花费爬楼梯 - 题 746
  + [[https://leetcode-cn.com/problems/min-cost-climbing-stairs/description/][Question]]

  Python:
  #+BEGIN_SRC python
    class Solution:
        def minCostClimbingStairs(self, cost):
            """
            :type cost: List[int]
            :rtype: int
            """
            f1 = f2 = 0
            for x in reversed(cost):
                f1, f2 = x + min(f1, f2), f1
            return min(f1, f2)
  #+END_SRC

  C:
  #+BEGIN_SRC C
    int minCostClimbingStairs(int* cost, int costSize) {
      int f1 = 0, f2 = 0;

      for (int i = costSize - 1; i >= 0; --i) {
        int tmp = f1;
        f1 = cost[i] + (f1 > f2 ? f2 : f1);
        f2 = tmp;
      }

      return f1 > f2 ? f2 : f1;
    }
  #+END_SRC

