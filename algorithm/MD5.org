#+SETUPFILE:  ./_style/style.setup
#+TITLE:      MD5 算法笔记
#+AUTHOR:     rgb_24bit

* 基本思路
  将信息分为 *N个分组*, 每组 *64个字节* (一个字节8位), 对每个分组进行摘要运算.

  当一个分组的摘要运算完毕后, 将 _上一个分组的结果用于下一个分组的运算_.

** 注意事项
   1. 信息的长度(注意是 *bit位* 长度, 不是字节长度)用 *64位* 表示, 也要参加信息摘要运算.
      信息长度放在最后一个分组的末尾, 所以 *长度信息要占据8个字节*.

      如果数据的最后一个分组的长度 *小于64个字节*, 便在其后添加 =0x80= 标志结束.
      此时:
      1. 数据 + 结束标志 <= 56 byte:
         在 结束标志 到 第56个字节 补0. 然后放入长度数据.

      2. 数据 + 结束标志 > 56 byte:
         在这个分组后面 补0, 进行一次摘要运算.
         新建一个分组, 前面全部补0, 最后16字节添加长度学习, 再进行一次摘要运算.

   2. MD5最后生成的摘要信息是16个字节，SHA1是20个字节

   3. MD5和SHA1的分组信息运算，分组里面的的数据都会被视为16个DWORD(4个字节)，
      而MD5算法认为这些DWORD的字节序列是LITTLE-ENDIAN,而SHA1的算法认为DWORD是BIG-ENDIAN的。
      所以在不同字节序的主机上要进行转换.

   4. 放入最后一个分组的长度信息，是原始数据长度，而且是BIT位长度，其是一个uint64_t，而
      MD5算法要求放入的长度是LITTLE-ENDIAN的，而SHA1算法则要求这个长度是BIG-ENDIAN的。
      不同的平台要进行转换。

   5. 当然生成的结果，MD5也要求是LITTLE-ENDIAN，SHA1也要求结果是BIG-ENDIAN的.
      不同的平台还是要进行转换.

** UML 图
   #+BEGIN_SRC plantuml :file ./img/md5.png :cmdline -charset utf-8
     @startuml

     start

     : 获取信息 msg;
     : 对 msg 进行分组, 每组 64 byte;

     if (最后一个分组长度 < 64 byte) then (yes)
        : 在最后一个分组后添加 0x80, 表示结束;
        if (最后一个分组长度 <= 56 byte) then (yes)
           : 结束标志到第56个字节补0;
           : 在末尾添加长度信息;
        else
           : 最后一个分组后面补 0, 进行一次摘要运算;
           : 新建一个分组, 前面补 0, 在最后 8 个字节添加长度信息;
        endif
     endif

     end

     @enduml
   #+END_SRC

   #+RESULTS:
   [[file:./img/md5.png]]
   
