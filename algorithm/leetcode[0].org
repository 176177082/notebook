#+TITLE:      LeetCode[1-200]

* 目录                                                    :TOC_4_gh:noexport:
- [[#回文数---题-9][回文数 - 题 9]]
- [[#罗马数字转整数---题-13][罗马数字转整数 - 题 13]]
- [[#最大子序和---题-53][最大子序和 - 题 53]]
- [[#x-的平方根---题-69][x 的平方根 - 题 69]]
- [[#爬楼梯---题-70][爬楼梯 - 题 70]]
- [[#合并两个有序数组---题-88][合并两个有序数组 - 题 88]]
- [[#对称二叉树---题-101][对称二叉树 - 题 101]]
- [[#将有序数组转换为二叉搜索树---题-108][将有序数组转换为二叉搜索树 - 题 108]]
- [[#平衡二叉树][平衡二叉树]]
- [[#杨辉三角---题-118][杨辉三角 - 题 118]]
- [[#买卖股票的最佳时机---题-121][买卖股票的最佳时机 - 题 121]]
- [[#只出现一次的数字---题-136][只出现一次的数字 - 题 136]]
- [[#excel表列名称][Excel表列名称]]
- [[#求众数][求众数]]
- [[#阶乘后的零][阶乘后的零]]
- [[#旋转数组][旋转数组]]
- [[#颠倒二进制串][颠倒二进制串]]
- [[#位-1-的个数][位 1 的个数]]

* 回文数 - 题 9
  + [[https://leetcode-cn.com/problems/palindrome-number/description/][Question]]

  Python:
  #+BEGIN_SRC python
    class Solution:
        def isPalindrome(self, x):
            """
            :type x: int
            :rtype: bool
            """
            if x < 0 or (x % 10 == 0 and x != 0):
                return False
        
            revertedNumber = 0
            while x > revertedNumber:
                revertedNumber = revertedNumber * 10 + x % 10
                x = x // 10
        
            return revertedNumber == x or x == revertedNumber // 10
  #+END_SRC

* 罗马数字转整数 - 题 13
  + [[https://leetcode-cn.com/problems/roman-to-integer/description/][Question]]

  *思路:* 从前向后遍历罗马数字，如果某个数比前一个数小，则加上该数。
  反之，减去前一个数的两倍然后加上该数。

  Python:
  #+BEGIN_SRC python
    class Solution:
        def romanToInt(self, s):
            """
            :type s: str
            :rtype: int
            """
            roman = dict(I=1, V=5, X=10, L=50, C=100, D=500, M=1000)
            pre = res = roman[s[0]]
            for n in s[1:]:
                if roman[n] <= pre:
                    res += roman[n]
                else:
                    res = res - 2*pre + roman[n]
                pre = roman[n]
            return res
  #+END_SRC

* 最大子序和 - 题 53
  + [[https://leetcode-cn.com/problems/maximum-subarray/description/][Question]]

  Python:
  #+BEGIN_SRC python
    class Solution:
        def maxSubArray(self, nums):
            """
            :type nums: List[int]
            :rtype: int
            """
            maxSub = maxCur = nums[0]
            for num in nums[1:]:
                maxCur = max(maxCur + num, num)
                maxSub = max(maxCur, maxSub)
            return maxSub
    #+END_SRC
    
* x 的平方根 - 题 69
  + [[https://leetcode-cn.com/problems/sqrtx/description/][Question]]
    
  Python:
  #+BEGIN_SRC python
    class Solution:
        def mySqrt(self, x):
            if x == 0: return 0
            left, right = 1, x
            while True:
                mid = (left + right) // 2
                if mid > (x // mid):
                    right = mid - 1
                else:
                    if (mid + 1) > (x // (mid + 1)):
                        return mid
                    left = mid + 1
  #+END_SRC

  C:
  #+BEGIN_SRC C
    int mySqrt(int x) {
      if (x == 0) {
        return 0;
      }

      int left = 1, right = x;
      while (true) {
        int mid = left + (right - left) / 2;  /* 防止溢出 */

        if (mid > (x / mid)) {
          right = mid - 1;
        }
        else {
          if ((mid + 1) > (x / (mid + 1))) {
            return mid;
          }
          left = mid + 1;
        }
      }

      return 0;
    }
  #+END_SRC

* 爬楼梯 - 题 70
  + [[https://leetcode-cn.com/problems/climbing-stairs/description/][Question]] - 其实就是斐波那契数列

  Python:
  #+BEGIN_SRC python 
    class Solution:
        def climbStairs(self, n):
            ans, pre, cur = 1, 0, 1
            for i in range(n):
                ans = pre + cur
                pre, cur = cur, ans
            return ans
  #+END_SRC

  C:
  #+BEGIN_SRC C
    int climbStairs(int n) {
      int ans = 1, pre = 0, cur = 1;
      for (int i = 0; i < n; ++i) {
        ans = pre + cur;
        pre = cur;
        cur = ans;
      }
      return ans;
    }
  #+END_SRC

* 合并两个有序数组 - 题 88
  + [[https://leetcode-cn.com/problems/merge-sorted-array/description/][Question]]

  Python:
  #+BEGIN_SRC python
    class Solution:
        def merge(self, nums1, m, nums2, n):
            cur, cur_size = 0, m
            for i in range(n):
                while nums1[cur] < nums2[i] and cur < cur_size:
                    cur += 1
            
                for j in range(cur_size, cur, -1):
                    nums1[j] = nums1[j - 1]
                nums1[cur] = nums2[i]
                cur_size += 1
  #+END_SRC

  Better Python:
  #+BEGIN_SRC python
    class Solution:
        def merge(self, nums1, m, nums2, n):
            while n > 0:
                if m <= 0 or nums2[n - 1] > nums1[m - 1]:
                    nums1[m + n - 1] = nums2[n - 1]
                    n -= 1
                else:
                    nums1[m + n - 1] = nums1[m - 1]
                    m -= 1
  #+END_SRC

  C:
  #+BEGIN_SRC C
    void merge(int* nums1, int m, int* nums2, int n) {
      while (n > 0) {
        if (m <= 0 || nums2[n - 1] > nums1[m - 1]) {
          nums1[m + n - 1] = nums2[n - 1];
          n -= 1;
        }
        else {
          nums1[m + n - 1] = nums1[m - 1];
          m -= 1;
        }
      }
    }
  #+END_SRC

* 对称二叉树 - 题 101
  + [[https://leetcode-cn.com/problems/symmetric-tree/description/][Question]]

  C:
  #+BEGIN_SRC C
    bool judge(struct TreeNode* left, struct TreeNode* right) {
      if (left && right) {
        if (left->val == right->val) {
          return judge(left->left, right->right) && judge(left->right, right->left);
        }
        else {
          return false;
        }
      }

      else if (left || right) {
        return false;
      }

      return true;
    }

    bool isSymmetric(struct TreeNode* root) {
      if (root == NULL) {
        return true;
      }
      return judge(root->left, root->right);
    }
  #+END_SRC

* 将有序数组转换为二叉搜索树 - 题 108
  + [[https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/description/][Question]]

  C:
  #+BEGIN_SRC C
    struct TreeNode* helper(int* nums, int left, int right) {
      if (left > right) {
        return NULL;
      }

      int mid = (left + right) / 2;
      struct TreeNode* node = (struct TreeNode*)malloc(sizeof(struct TreeNode));
      node->val = nums[mid];
      node->left = helper(nums, left, mid - 1);
      node->right = helper(nums, mid + 1, right);

      return node;
    }


    struct TreeNode* sortedArrayToBST(int* nums, int numsSize) {
      return helper(nums, 0, numsSize - 1);
    }
  #+END_SRC

* 平衡二叉树
  + [[https://leetcode-cn.com/problems/balanced-binary-tree/description/][Question]]

  Python:
  #+BEGIN_SRC python
    class Solution:
        def isBalanced(self, root):
            """
            :type root: TreeNode
            :rtype: bool
            """
            def dfsHeight(root):
                if not root:
                    return 0
            
                left = dfsHeight(root.left)
                if left == -1:
                    return -1
            
                right = dfsHeight(root.right)
                if right == -1:
                    return -1
            
                if (abs(left - right) > 1):
                    return -1
            
                return max(left, right) + 1
        
            return dfsHeight(root) != -1
  #+END_SRC

* 杨辉三角 - 题 118
  + [[https://leetcode-cn.com/problems/pascals-triangle/description/][Question]]

  Python:
  #+BEGIN_SRC python
    class Solution:
        def generate(self, numRows):
            ans = [[1]]
            for num in range(1, numRows):
                ans.append(list(map(lambda x, y: x + y, [0] + ans[-1], ans[-1] + [0])))
            return ans[:numRows]
  #+END_SRC

* 买卖股票的最佳时机 - 题 121
  + [[https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/description/][Question]]

  C:
  #+BEGIN_SRC C
    int maxProfit(int* prices, int pricesSize) {
      int profit = 0, min = INT_MAX;

      for (int i = 0; i < pricesSize; ++i) {
        if (prices[i] < min) {
          min = prices[i];
        }
        else {
          if (prices[i] - min > profit) {
            profit = prices[i] - min;
          }
        }
      }

      return profit;
    }
  #+END_SRC

* 只出现一次的数字 - 题 136
  + [[https://leetcode-cn.com/problems/single-number/description/][Question]]
  + [[https://leetcode.com/problems/single-number/solution/][解决方案]]
    
  C:
  #+BEGIN_SRC C
    int singleNumber(int* nums, int numsSize) {
      int ans = 0;

      for (int i = 0; i < numsSize; ++i) {
        ans ^= nums[i];
      }

      return ans;
    }
  #+END_SRC
* Excel表列名称
  + [[https://leetcode-cn.com/problems/excel-sheet-column-title/description/][Quesion]]

  + 本质就是进制转换

  #+BEGIN_SRC python
    class Solution:
        def convertToTitle(self, n):
            capital = list(map(chr, range(65, 91)))
            ans = str()
            while n > 0:
                n -= 1
                ans = capital[n % 26] + ans
                n //= 26
            return ans
  #+END_SRC

* 求众数
  + [[https://leetcode-cn.com/problems/majority-element/description/][Quesion]]

  #+BEGIN_SRC C
    int majorityElement(int* nums, int numsSize) {
      int majority = 0, count = 0;
    
      for (int i = 0; i < numsSize; ++i) {
        if (count == 0) {
          majority = nums[i];
          count++;
        }
        else if (nums[i] == majority) {
          count++;
        }
        else {
          count--;
        }
      }
    
      return majority;
    }
  #+END_SRC

* 阶乘后的零
  + [[https://leetcode-cn.com/problems/factorial-trailing-zeroes/description/][Quesion]]

  #+BEGIN_SRC python
    class Solution:
        def trailingZeroes(self, n):
            ans = 0
            while n:
                n = n // 5
                ans += n
            return ans
  #+END_SRC

* 旋转数组
  + [[https://leetcode-cn.com/problems/rotate-array/description/][Quesion]]
  + [[https://leetcode.com/problems/rotate-array/solution/][Solution]]

  #+BEGIN_SRC python
    class Solution:
        def rotate(self, nums, k):
            def reverse(start, end):
                while start < end:
                    nums[start], nums[end] = nums[end], nums[start]
                    start += 1
                    end -= 1
            length = len(nums)
            k = k % length
            reverse(0, length - 1)
            reverse(0, k - 1)
            reverse(k, length - 1)
  #+END_SRC

* 颠倒二进制串
  + [[https://leetcode-cn.com/problems/reverse-bits/description/][Quesion]]

  #+BEGIN_SRC C
    uint32_t reverseBits(uint32_t n) {
      uint32_t ans = 0;
    
      for (int i = 0; i < 32; ++i) {
        ans = (ans << 1) + (n & 1);
        n = n >> 1;
      }
    
      return ans;
    }
  #+END_SRC

  #+BEGIN_SRC C
    uint32_t reverseBits(uint32_t n) {
      n = ((n >> 1) & 0x55555555) | ((n & 0x55555555) << 1);
      n = ((n >> 2) & 0x33333333) | ((n & 0x33333333) << 2);
      n = ((n >> 4) & 0x0F0F0F0F) | ((n & 0x0F0F0F0F) << 4);
      n = ((n >> 8) & 0x00FF00FF) | ((n & 0x00FF00FF) << 8);
      n = (n >> 16) | (n << 16);

      return n;
    }
  #+END_SRC

* 位 1 的个数
  + [[https://leetcode-cn.com/problems/number-of-1-bits/description/][Quesion]]

  #+BEGIN_SRC C
    int hammingWeight(uint32_t n) {
      int count = 0;
    
      while (n) {
        count += n & 1;
        n = n >> 1;
      }
    
      return count;
    }
  #+END_SRC

  #+BEGIN_SRC python
    class Solution(object):
        def hammingWeight(self, n):
            count = 0
            while n != 0:
                count += 1
                n = n & (n - 1)
            return count
  #+END_SRC

