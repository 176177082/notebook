#+TITLE:      位运算笔记

* 目录                                                    :TOC_4_gh:noexport:
- [[#字符][字符]]
- [[#移位][移位]]
- [[#掩码运算][掩码运算]]
- [[#进制转化][进制转化]]
- [[#简单的技巧][简单的技巧]]
- [[#加减乘除][加减乘除]]
- [[#字节对齐][字节对齐]]
- [[#截取保存单字节数据][截取保存单字节数据]]

* 字符
  ASCII 码：
  + ~0-9~: ~0x30~ - ~0x39~
  + ~a-z~: ~0x61~ - ~0x7A~

* 移位
  + 左移位： 补 0
  + 逻辑右移： 补 0 (无符号数)
  + 算术右移： 补最高位有效值 (有符号数)

  
* 掩码运算
  掩码 ~0xFF~ 获取一个二进制数据的最低 8 位数据， 其他位置为 0
  
* 进制转化
  当 ~x = 2ⁿ~, ~n = i + 4j(0 ≤ i ≤ 3)~.
  
  可以把 ~x~ 写成十六进制数字 ~1(i=0), 4(i=2), 8(i=3)~ 开头， 后面紧跟 ~j~ 个十六进制 ~0~.

  例： ~2014 = 2**11, n = 11 = 3 + 4·2, hex = 0x800~

* 简单的技巧
  + 判断奇偶: ~num & 1 = 0~ 为偶, ~num & 1 = 1~ 为奇.
  + int 型最大值: ~(1 << 31) - 1~ 或 =~(1 << 31)=.
  + int 型最小值: ~1 << 31~.
  + 乘2: ~num << 1~.
  + 除2: ~num >> 1~.
  + 乘2的n次方: ~num << n~.
  + 除2的n次方: ~num >> n~.
  + 异或： ~a ^ a = 0~, ~a ^ b ^ a = b(a != b)~
  + 不会零除: ~num && 5 / num~

* 加减乘除 
  #+BEGIN_SRC C
    /* 位运算 + */
    int add(int a, int b) {
      int sum = a;
      int carry = n;

      while (carry) {
        int tmp = sum;
        sum = tmp ^ carry;
        carry = (tmp & carry) << 1;
      }

      return sum;
    }


    /* 位运算 - */
    int sub(int a, int b) {
      int diff = add(~b, 1);

      diff = add(a, diff);

      return diff;
    }
  #+END_SRC

  乘除: [[http://www.cnblogs.com/kiven-code/archive/2012/09/15/2686922.html][博客园]]
  
  两数之和：
  #+BEGIN_SRC C
    int getSum(int a, int b) {
      while (b != 0) {
        int c = a ^ b;
        b = (a & b) << 1;
        a = c;
      }
      return a;
    }
  #+END_SRC

* 字节对齐
  + 4 字节对齐
    #+BEGIN_SRC C
      size_t alingn4(size_t size) {
        if (size & 0x3 == 0) {
          return size;
        }
        return ((size >> 2) + 1) << 2;
      }
    #+END_SRC
    
    4 的倍数最后两位必然为 0, 0x3 为 11.

  + 8 字节对齐
    #+BEGIN_SRC C
      size_t align8(size_t size) {
        if (size & 0x7 == 0) {
          return size;
        }
        return ((size >> 3) + 1) << 3;
      }
    #+END_SRC

    8 的倍数最后三位必然为 0, 0x7 为 111.

* 截取保存单字节数据
  #+BEGIN_SRC python
    class ByteData(object):
        """Used to save a single byte of data and know the number of bits used.

        Args:
            data: The data to be saved, the default is 0.
            size: The number of bits in the data, the default is 0.
        """
        def __init__(self, data=0, size=0):
            self.data = data
            self.size = size

        def save(self, data, size):
            need_size = self.size + size
            lack_size = need_size - 8 if need_size > 8 else 0
            saved_size = need_size - lack_size - self.size

            self.data = (self.data << saved_size) | (data >> lack_size)
            self.size += saved_size

            data = data & (0xFF >> (8 - size + saved_size))

            return (data, lack_size)
  #+END_SRC

  size 最大为 8

  + need_size: 保存 self.data 和 data 需要的位数
  + lack_size: 保存 self.data 和 data 缺少的位数
  + saved_size: 保存了的 data 的位数
  
  #+BEGIN_SRC python
    self.data = (self.data << saved_size) | (data >> lack_size)
  #+END_SRC

  保存 data 的高几位的数据到 self.data, 其中， data 的原有位数为 size, 移除低 lack_size
  后剩下的就是 saved_size 位数据

  #+BEGIN_SRC python
    data = data & (0xFF >> (8 - size + saved_size))
  #+END_SRC

  截取 data 低 lack_size 位的数据， 8 - size 为无效高位的大小， saved_size 为保存的位数的大小。
