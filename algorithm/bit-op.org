#+TITLE:      位运算

* 目录                                                    :TOC_4_gh:noexport:
- [[#基本概念][基本概念]]
- [[#进制转化][进制转化]]
- [[#简单的技巧][简单的技巧]]
- [[#加减乘除][加减乘除]]
- [[#字节对齐][字节对齐]]
- [[#截取保存单字节数据][截取保存单字节数据]]

* 基本概念
  + 数字 ~0-9~ 的 ~ASCII~ 码为： ~0x30 - 0x39~.
  + 字母 ~a-z~ 的 ~ASCII~ 码为： ~0x61 - 0x7A~.
  + 算术和逻辑左移： 高位遗弃， 低位补 0
  + 算术右移： 低位遗弃， 高位补符号位的值
  + 逻辑右移： 低位遗弃， 高位补 0
  + 掩码运算： 掩码 ~0xFF~ 获取一个二进制数据的最低 8 位数据， 其他位置为 0

* 进制转化
  当 ~x = 2ⁿ~, ~n = i + 4j(0 ≤ i ≤ 3)~.
  
  可以把 ~x~ 写成十六进制数字 ~1(i=0), 4(i=2), 8(i=3)~ 开头， 后面紧跟 ~j~ 个十六进制 ~0~.

  例： ~2014 = 2**11, n = 11 = 3 + 4·2, hex = 0x800~

* 简单的技巧
  |----------------+-----------------------------|
  | 操作           | 解释                        |
  |----------------+-----------------------------|
  | ~num & 1~        | 判断奇偶, 0 为偶, 1 为奇    |
  | ~(1 << 31) - 1~  | 获取 int 型最大值           |
  | ~~(1 << 31)~     | 获取 int 型最大值           |
  | ~1 << 31~        | 获取 int 型最小值           |
  | ~num << n~       | 乘以 2 的 n 次幂            |
  | ~num >> n~       | 除以 2 的 n 次幂            |
  | ~a ^ a = 0~      | 两个相同的数字异或得零      |
  | ~a ^ 0 = a~      | 任意数字和 0 异或得到他它身 |
  | ~num && 5 / num~ | 防止零除                    |
  |----------------+-----------------------------|

* 加减乘除 
  #+BEGIN_SRC C
    int add(int a, int b) {
      int sum = a;
      int carry = n;

      while (carry) {
        int tmp = sum;
        sum = tmp ^ carry;
        carry = (tmp & carry) << 1;
      }

      return sum;
    }

    int sub(int a, int b) {
      int diff = add(~b, 1);

      diff = add(a, diff);

      return diff;
    }
  #+END_SRC

  乘除: [[http://www.cnblogs.com/kiven-code/archive/2012/09/15/2686922.html][博客园]]
  
  两数之和：
  #+BEGIN_SRC C
    int getSum(int a, int b) {
      while (b != 0) {
        int c = a ^ b;
        b = (a & b) << 1;
        a = c;
      }
      return a;
    }
  #+END_SRC

* 字节对齐
  + 4 字节对齐
    #+BEGIN_SRC C
      size_t alingn4(size_t size) {
        if (size & 0x3 == 0) {
          return size;
        }
        return ((size >> 2) + 1) << 2;
      }
    #+END_SRC
    
    4 的倍数最后两位必然为 0, 0x3 为 11.

  + 8 字节对齐
    #+BEGIN_SRC C
      size_t align8(size_t size) {
        if (size & 0x7 == 0) {
          return size;
        }
        return ((size >> 3) + 1) << 3;
      }
    #+END_SRC

    8 的倍数最后三位必然为 0, 0x7 为 111.

* 截取保存单字节数据
  #+BEGIN_SRC python
    class ByteData(object):
        """Used to save a single byte of data and know the number of bits used.

        Args:
            data: The data to be saved, the default is 0.
            size: The number of bits in the data, the default is 0.
        """
        def __init__(self, data=0, size=0):
            self.data = data
            self.size = size

        def save(self, data, size):
            need_size = self.size + size
            lack_size = need_size - 8 if need_size > 8 else 0
            saved_size = need_size - lack_size - self.size

            self.data = (self.data << saved_size) | (data >> lack_size)
            self.size += saved_size

            data = data & (0xFF >> (8 - size + saved_size))

            return (data, lack_size)
  #+END_SRC

  size 最大为 8

  + need_size: 保存 self.data 和 data 需要的位数
  + lack_size: 保存 self.data 和 data 缺少的位数
  + saved_size: 保存了的 data 的位数
  
  #+BEGIN_SRC python
    self.data = (self.data << saved_size) | (data >> lack_size)
  #+END_SRC

  保存 data 的高几位的数据到 self.data, 其中， data 的原有位数为 size, 移除低 lack_size
  后剩下的就是 saved_size 位数据

  #+BEGIN_SRC python
    data = data & (0xFF >> (8 - size + saved_size))
  #+END_SRC

  截取 data 低 lack_size 位的数据， 8 - size 为无效高位的大小， saved_size 为保存的位数的大小。
