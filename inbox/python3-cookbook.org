#+TITLE: Python3-cookbook 阅读笔记

* 第一章: 数据结构和算法
** 解压序列赋值给多个变量
   *任何* 可迭代的对象都可以通过下面的方式进行 *解压赋值*:
   #+BEGIN_SRC python
     >>> a, b, c, d, e = 'Hello'
   #+END_SRC

   *PS:* 变量的数量必须跟序列元素的数量一样

** 解压可迭代对象赋值给多个变量
   变量的数量和序列元素的数量不一样是可以通过下面的方式进行 *解压赋值*:
   #+BEGIN_SRC python
     >>> record = ('Dave', 'dave@example.com', '773-555-1212', '847-555-1212')
     >>> name, email, *phone_numbers = record
     >>> name
     'Dave'
     >>> email
     'dave@example.com'
     >>> phone_numbers
     ['773-555-1212', '847-555-1212']
   #+END_SRC

** 保留最后 N 个元素
   使用 ~collections.deque~ 保留迭代操作或者其他操作的最后有限的几个元素的历史记录：
   #+BEGIN_SRC python
     >>> from collections import deque
     >>> q = deque(maxlen=5)
     >>> q.extend([1,2,3,4,5,6,7,8,9,0])
     >>> q
     deque([6, 7, 8, 9, 0], maxlen=5)
   #+END_SRC

** 查找最大或最小的 N 个元素
   使用 ~heapq.nlargest()~ 和 ~heapq.nsmallest()~ 从一个集合中获得最大或者最小的 N 个元素列表：
   #+BEGIN_SRC python
     portfolio = [
         {'name': 'IBM', 'shares': 100, 'price': 91.1},
         {'name': 'AAPL', 'shares': 50, 'price': 543.22},
         {'name': 'FB', 'shares': 200, 'price': 21.09},
         {'name': 'HPQ', 'shares': 35, 'price': 31.75},
         {'name': 'YHOO', 'shares': 45, 'price': 16.35},
         {'name': 'ACME', 'shares': 75, 'price': 115.65}
     ]
     cheap = heapq.nsmallest(3, portfolio, key=lambda s: s['price'])
     expensive = heapq.nlargest(3, portfolio, key=lambda s: s['price'])
   #+END_SRC

   *PS:* 可以通过调用 ~heapq.heapify()~ 对一个序列进行 *堆排序*
   
   堆中， ~heap[0]~ 永远是最小的元素， 而 ~heapq.heappop()~ 会将第一个元素弹出，
   后面的元素补上。

** 实现一个优先级队列
   利用 ~heapq~ 模块实现一个简单的优先级队列:
   #+BEGIN_SRC python
     import heapq

     class PriorityQueue:
         def __init__(self):
             self._queue = []
             self._index = 0

         def push(self, item, priority):
             heapq.heappush(self._queue, (-priority, self._index, item))
             self._index += 1

         def pop(self):
             return heapq.heappop(self._queue)[-1]


     # use

     >>> class Item:
     ...     def __init__(self, name):
     ...         self.name = name
     ...     def __repr__(self):
     ...         return 'Item({!r})'.format(self.name)
     ...
     >>> q = PriorityQueue()
     >>> q.push(Item('foo'), 1)
     >>> q.push(Item('bar'), 5)
     >>> q.push(Item('spam'), 4)
     >>> q.push(Item('grok'), 1)
     >>> q.pop()
     Item('bar')
     >>> q.pop()
     Item('spam')
     >>> q.pop()
     Item('foo')
     >>> q.pop()
     Item('grok')
   #+END_SRC

   核心 ~(-priority, self._index, item)~: ~-priority~ 保证排序为优先级 高 ==> 低,
   因为 ~priority~ 越大, ~-priority~ 越小， 而堆中越小的元素越靠前。

   递增的 ~_index~ 保证同一优先级的情况下按插入元素的顺序排序。

   ~item~ 是要储存或获取的元素。

