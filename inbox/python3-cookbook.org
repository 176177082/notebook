#+TITLE:      Python3-cookbook 阅读笔记

* 目录                                                    :TOC_4_gh:noexport:
- [[#第一章-数据结构和算法][第一章: 数据结构和算法]]
  - [[#删除序列相同元素并保存顺序][删除序列相同元素并保存顺序]]
  - [[#命名切片][命名切片]]
  - [[#序列中出现次数最多的元素][序列中出现次数最多的元素]]
  - [[#通过某个关键字排序一个字典列表][通过某个关键字排序一个字典列表]]
  - [[#排序不支持原生比较的对象][排序不支持原生比较的对象]]
  - [[#通过某个字段将记录分组][通过某个字段将记录分组]]
  - [[#过滤序列元素][过滤序列元素]]
  - [[#从字典中提取子集][从字典中提取子集]]
  - [[#映射名称到序列元素][映射名称到序列元素]]

* 第一章: 数据结构和算法
** 删除序列相同元素并保存顺序
   在看 ~webpy~ 源码的时候看到的一种方式：
   #+BEGIN_SRC python
     def uniq(seq, key=None):
         key = key or (lambda x: x)
         seen, result = set(), list()

         for item in seq:
             item = key(item)
             if item in seen:
                 continue
             seen.add(item)
             result.append(item)

         return result
   #+END_SRC

   利用了 *集合* 内部元素不重复的特性。

** 命名切片
   通过内置函数 ~slice~ 将硬编码的 *切片* 转换为具名的切片， 含义更加清晰。

   #+BEGIN_SRC python
     >>> s = 'HelloWorld'
     >>> reverse = slice(None, None, -1)
     >>> s[reverse]  # s[::-1]
     'dlroWolleH'
   #+END_SRC

** 序列中出现次数最多的元素
   使用 ~collections.Counter~ 可以很容易的完成这个目标：

   #+BEGIN_SRC python
     words = [
         'look', 'into', 'my', 'eyes', 'look', 'into', 'my', 'eyes',
         'the', 'eyes', 'the', 'eyes', 'the', 'eyes', 'not', 'around', 'the',
         'eyes', "don't", 'look', 'around', 'the', 'eyes', 'look', 'into',
         'my', 'eyes', "you're", 'under'
     ]

     from collections import Counter

     word_counts = Counter(words)

     # 出现频率最高的3个单词
     top_three = word_counts.most_common(3)
     print(top_three)

     # Outputs [('eyes', 8), ('the', 5), ('look', 4)]
   #+END_SRC

   ~Counter~ 还可以跟数学运算操作相结合：
   #+BEGIN_SRC python
     >>> a = Counter(words)
     >>> b = Counter(morewords)
     >>> c = a + b
   #+END_SRC

** 通过某个关键字排序一个字典列表
   对于简单的 *字典列表*, 可以使用 ~lambda~ 表达式来实现， 但是很明显， ~Python~ 为我们准备好了更好的工具：
   #+BEGIN_SRC python
     rows = [
         {'fname': 'Brian', 'lname': 'Jones', 'uid': 1003},
         {'fname': 'David', 'lname': 'Beazley', 'uid': 1002},
         {'fname': 'John', 'lname': 'Cleese', 'uid': 1001},
         {'fname': 'Big', 'lname': 'Jones', 'uid': 1004}
     ]

     from operator import itemgetter

     rows_by_fname = sorted(rows, key=itemgetter('fname'))
     rows_by_uid = sorted(rows, key=itemgetter('uid'))

     print(rows_by_fname)
     print(rows_by_uid)
   #+END_SRC

   ~operator~ 模块的 ~itemgetter~ 函数充当 ~sorted~ 这类和排序相关的函数的 ~callable~ 参数。

   同时， ~itemgetter~ 支持多个参数：
   #+BEGIN_SRC python
     rows_by_lfname = sorted(rows, key=itemgetter('lname','fname'))
   #+END_SRC

** 排序不支持原生比较的对象
   某些对象不支持原生的比较操作， 一般情况下可以使用 ~lambda~ 表达式来完成比较操作。

   但也可以使用 ~operator.attrgetter~ 函数来完成这一工作， 和 ~itemgetter~ 一样， 也支持多个参数：
   #+BEGIN_SRC python
     class User:
         def __init__(self, user_id):
             self.user_id = user_id

         def __repr__(self):
             return 'User({})'.format(self.user_id)


     from operator import attrgetter
     sorted(users, key=attrgetter('user_id'))

     by_name = sorted(users, key=attrgetter('last_name', 'first_name'))

     min(users, key=attrgetter('user_id'))
   #+END_SRC

** 通过某个字段将记录分组
   通过 ~itertools.groupby()~ 根据某个特定的字段来对一个字典或实例序列分组：
   #+BEGIN_SRC python
     rows = [
         {'address': '5412 N CLARK', 'date': '07/01/2012'},
         {'address': '5148 N CLARK', 'date': '07/04/2012'},
         {'address': '5800 E 58TH', 'date': '07/02/2012'},
         {'address': '2122 N CLARK', 'date': '07/03/2012'},
         {'address': '5645 N RAVENSWOOD', 'date': '07/02/2012'},
         {'address': '1060 W ADDISON', 'date': '07/02/2012'},
         {'address': '4801 N BROADWAY', 'date': '07/01/2012'},
         {'address': '1039 W GRANVILLE', 'date': '07/04/2012'},
     ]
   #+END_SRC

   根据 ~date~ 分组：
   #+BEGIN_SRC python
     from operator import itemgetter
     from itertools import groupby

     # Sort by the desired field first
     rows.sort(key=itemgetter('date'))
     # Iterate in groups
     for date, items in groupby(rows, key=itemgetter('date')):
         print(date)
         for i in items:
             print(' ', i)
   #+END_SRC

   运行结果：
   #+BEGIN_SRC python
     07/01/2012
       {'date': '07/01/2012', 'address': '5412 N CLARK'}
       {'date': '07/01/2012', 'address': '4801 N BROADWAY'}
     07/02/2012
       {'date': '07/02/2012', 'address': '5800 E 58TH'}
       {'date': '07/02/2012', 'address': '5645 N RAVENSWOOD'}
       {'date': '07/02/2012', 'address': '1060 W ADDISON'}
     07/03/2012
       {'date': '07/03/2012', 'address': '2122 N CLARK'}
     07/04/2012
       {'date': '07/04/2012', 'address': '5148 N CLARK'}
       {'date': '07/04/2012', 'address': '1039 W GRANVILLE'}
   #+END_SRC

   ~groupby()~ 函数扫描整个序列并且查找 *连续相同值* 的元素序列， 每次迭代的时候， 它会返回一个值和一个迭代器对象，
   这个迭代器对象可以生成元素值全部等于上面那个值的组中所有对象。

   因此， 在使用 ~groupby()~ 分组前应该对序列进行 *排序*.

   否则， 最好还是使用 ~defaultdict~ 来进行分组：
   #+BEGIN_SRC python
     from collections import defaultdict
     rows_by_date = defaultdict(list)
     for row in rows:
         rows_by_date[row['date']].append(row)
   #+END_SRC

** 过滤序列元素
   使用 *列表推导式* 过滤简单的序列， 使用 *生成器表达式* 过滤大的序列， 使用 ~filter~ 过滤复杂的序列。

   列表推导式：
   #+BEGIN_SRC python
     >>> mylist = [1, 4, -5, 10, -7, 2, 3, -1]
     >>> [n for n in mylist if n > 0]
     [1, 4, 10, 2, 3]
     >>> [n for n in mylist if n < 0]
     [-5, -7, -1]
   #+END_SRC

   生成器表达式：
   #+BEGIN_SRC python
     >>> pos = (n for n in mylist if n > 0)
     >>> pos
     <generator object <genexpr> at 0x1006a0eb0>
   #+END_SRC
   
   filter:
   #+BEGIN_SRC python
     values = ['1', '2', '-3', '-', '4', 'N/A', '5']
     def is_int(val):
         try:
             x = int(val)
             return True
         except ValueError:
             return False
     ivals = list(filter(is_int, values))
     print(ivals)
     # Outputs ['1', '2', '-3', '4', '5']
   #+END_SRC

   另外， ~itertools.compress()~ 可以根据相关联的序列来过滤序列：
   #+BEGIN_SRC python
     addresses = [
         '5412 N CLARK',
         '5148 N CLARK',
         '5800 E 58TH',
         '2122 N CLARK',
         '5645 N RAVENSWOOD',
         '1060 W ADDISON',
         '4801 N BROADWAY',
         '1039 W GRANVILLE',
     ]
     counts = [ 0, 3, 10, 4, 1, 7, 6, 1]

     >>> from itertools import compress
     >>> more5 = [n > 5 for n in counts]
     >>> more5
     [False, False, True, False, False, True, True, False]
     >>> list(compress(addresses, more5))
     ['5800 E 58TH', '1060 W ADDISON', '4801 N BROADWAY']
   #+END_SRC

   ~itertools.compress()~ 过滤出第二个序列中 ~Boolean~ 值为 ~True~ 的元素。

** 从字典中提取子集
   最简单的方式是使用 *字典推导式*:
   #+BEGIN_SRC python
     prices = {
         'ACME': 45.23,
         'AAPL': 612.78,
         'IBM': 205.55,
         'HPQ': 37.20,
         'FB': 10.75
     }
     # Make a dictionary of all prices over 200
     p1 = {key: value for key, value in prices.items() if value > 200}
     # Make a dictionary of tech stocks
     tech_names = {'AAPL', 'IBM', 'HPQ', 'MSFT'}
     p2 = {key: value for key, value in prices.items() if key in tech_names}
   #+END_SRC

   也可以这样：
   #+BEGIN_SRC python
     p1 = dict((key, value) for key, value in prices.items() if value > 200)
   #+END_SRC

   第二种方式效率比第一种低。

** 映射名称到序列元素
   命名元组的使用：
   #+BEGIN_SRC python
     >>> from collections import namedtuple
     >>> Subscriber = namedtuple('Subscriber', ['addr', 'joined'])
     >>> sub = Subscriber('jonesy@example.com', '2012-10-19')
     >>> sub
     Subscriber(addr='jonesy@example.com', joined='2012-10-19')
     >>> sub.addr
     'jonesy@example.com'
     >>> sub.joined
     '2012-10-19'
   #+END_SRC

   ~namedtuple~ 相交于字典使用更少的内存， 但是不能修改。

   可以通过命名元组的 ~_replace()~ 方法改变属性的值， 它会创建一个全新的命名元组并将
   对应的字段用新的值取代。

   #+BEGIN_SRC python
     >>> s = s._replace(shares=75)
     >>> s
     Stock(name='ACME', shares=75, price=123.45)
   #+END_SRC
   
