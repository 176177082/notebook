* 继承相关
  + [[https://www.polarxiong.com/archives/JAVA-%E5%AD%90%E7%B1%BB-%E8%A6%86%E7%9B%96-%E7%88%B6%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F.html][JAVA: 子类覆盖父类的成员变量]]

* 异常相关
  + 捕获异常：
    #+BEGIN_SRC java
      try {
        // 可能会抛出异常的代码块
      } catch(Exception ex) {
        // 捕获异常后执行的代码块
      }
    #+END_SRC
  + 抛出异常：
    #+BEGIN_SRC java
      public int function() throws Exception {  // 声明可能抛出的异常
        throw new Exception();  // 抛出异常
      }
    #+END_SRC

  Java 中的所有异常是 ~Exception~ 类型的 *对象*.

  异常分为： 检查型异常和非检查型（运行时）异常。

  其中， 如果抛出的异常类型为 *检查型异常*, 那么就必需在方法声明时通过 ~throws~ 声明可能抛出的异常， 同时
  在调用该方法时， 使用 ~try/catch~ 或 ~ducking~ 处理异常。

  如果抛出的异常类型为 *非检查型异常*, 那么可以不声明或包含在 ~try/catch~ 代码块中。 当然， 做了也没影响。

  其中， 非检查型异常是 ~RuntimeException~ 类型或其子类类型的异常， 而检查型异常是除了 ~RuntimeException~ 以外
  的所有异常。

  其中， ~RuntimeException~ 也是 ~Exception~ 的子类， 不过比较特殊。

  使用 ~finally~ 代码块来存放无论如何都要执行的部分。 既是在 ~try/catch~ 代码块中存在 ~return~ 语句， ~finally~ 代码块也
  依然会执行 ！ 流程会跳到 ~finally~ 然后在回到 ~return~ 语句。

  通过如下方式声明多个异常：
  #+BEGIN_SRC java
    public int function() throws IOException, InterruptedException {
      // ...
    }
  #+END_SRC

  通过多个 ~catch~ 块捕获多个异常， 也可以通过多个异常的父类同时捕获多个异常（声明异常也一样， 通过异常父类同时声明多个异常）

  异常也是对象， 因此也支持多态， 所以应该：
  + 以异常的父型来声明会抛出的远程
  + 以所抛出的异常父型来捕获异常
  + 可以用 ~Exception~ 捕获所有异常， 但不代表应该这么做
  + 为每个需要单独处理的异常编写不同的 catch 块
  + 有多个 catch 块时， 要从小排到大（子类到父类）， 否则会无法通过编译

  如果不想处理异常， 那么只需要在方法声明时 *再次 throws* 可能的异常即可：
  #+BEGIN_SRC java
    public int functionA() throws Exception {
      // ...
    }

    public int functionB() throws Exception {  // 再次 throws
      functionA();
    }
  #+END_SRC

  如果连 ~main~ 函数也 duck 调异常， 那么当遇到异常时， Java 虚拟机会当场去世。

  因此， 对于 *检查型异常*, 有两种处理方式：
  1. 使用 ~try/catch~ 处理异常
  2. 使用 ~duck~ 逃避异常

  异常处理规则：
  1. catch 与 finally 不能没有 try
  2. try 与 catch 之间不能有程序
  3. try 一定要有 catch 或 finally
  4. 只带有 finally 的 try 必须声明异常 - duck
  
