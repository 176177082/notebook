* Misc
** 网络编程
   + [[https://docs.oracle.com/javase/tutorial/networking/overview/index.html][Lesson: Overview of Networking (The Java™ Tutorials > Custom Networking)]]
   + [[https://www.baeldung.com/java-http-request][Do a Simple HTTP Request in Java]]

** 图片处理
   + [[https://www.cnblogs.com/XL-Liang/archive/2011/12/14/2287566.html][java 图片处理 (文字水印、图片水印、缩放、补白)]]
   + [[https://segmentfault.com/a/1190000011388060][Java图像处理之正片叠底]]

** synchronized
   + [[https://juejin.im/post/594a24defe88c2006aa01f1c][Java 之 synchronized 详解]]

** 引用类型
   + [[https://www.zhihu.com/question/37401125][Java中的强引用，软引用，弱引用，虚引用有什么用？]]

* 对象的克隆
  + [[https://www.cnblogs.com/Qian123/p/5710533.html][Java提高篇——对象克隆（复制） - 萌小Q - 博客园]]

* core java
  + java 语言规范 - javase/specs
  + Java 初始化块执行顺序
  + Runtime.addShutdownHook
  + user.dir 是 java 运行环境的启动路径
  + 默认类路径包含当前目录，设置后就不一定了
  + 子类和父类同名的字段
  + 覆盖的方法的可见性不能低于父类
  + null isinstanceof xxx => false
  + 枚举值比较用 == 就可以了
  + [[https://stackoverflow.com/questions/11720288/is-an-interface-a-class][java - Is an interface a class? - Stack Overflow]]

* 反射
  + int.class, Integer.class, Integer.TYPE

* Tomcat
  + [[https://stackoverflow.com/questions/1153521/setting-default-locale-for-tomcat-service-in-windows-xp][java - Setting default locale for Tomcat Service in Windows XP - Stack Overflow]]
  + [[https://stackoverflow.com/questions/9361623/catalina-home-environmental-variable-is-not-defined-correctly][tomcat6 - CATALINA_HOME environmental variable is not defined correctly - Stack Overflow]]
  + [[https://stackoverflow.com/questions/6623161/javac-option-to-compile-all-java-files-under-a-given-directory-recursively][javac option to compile all java files under a given directory recursively - Stack Overflow]]

* 语法
  + [[https://stackoverflow.com/questions/1958636/what-is-double-brace-initialization-in-java][What is Double Brace initialization in Java? - Stack Overflow]]
* Core Java
  + 根据 Java 语言规范，main 方法必须声明为 public
  + 字符 $ 在 Java 中虽然合法，但是只用在 Java 编译器工具生成的名字中
  + const 是 Java 保留的关键字，但目前并没有使用，因此必须使用 final 关键字定义常量
  + Java 不使用逗号运算符
  + 格式化字符串是，s 转换符对于实现了 Formattable 接口的对象会调用 gromatTo 方法，否则调用 toString
  + 命令行参数中，程序名并没有保存在 args 数组中
  + 打印二维数组 Arrays.deepToString()
  + 编译器在编译源文件是不检查目录结构，但是不合适的目录结构会导致找不到类
  + 未指定访问修饰符的域可以被包内所有成员访问
  + 覆盖方法是，子类方法不能低于超类方法的可见性
  + 将超类转换为子类之前应该用 instanceof 进行检查
  + null instanceof type 返回 false
  + 抄写类可以包含具体数据和具体方法
  + 默认访问级别对子类不可见
  + 比较枚举值使用 == 就可以了
  + 接口中的所有方法自动为 public
  + 接口中的与自动设为 public static final
  + 伴随类 - Path/Paths，伴随类包含静态方法
  + 默认方法冲突 - 超类优先，接口冲突就必须手动覆盖
  + 所有数组类型都有一个 public 的 clone 方法，可以建立一个新数组，包含源数组所有元素的副本
  + 函数式接口注释 - FunctionalInterface
  + 非静态内部类不能有 static 方法
  + 内部类的所有静态域都必须是 final
  + 局部类不能用访问修饰符修饰
  + 内部类访问的局部变量必须为事实上的 final
  + 静态内部类可以有静态域和静态方法
  + 声明在接口中的内部类自动成为 static 和 public 类
  + 双括号初始化
    #+BEGIN_SRC java
      new ArrayList<>() {{
        add(1); add(2);
      }};
    #+END_SRC

    外层括号构建匿名子类，内层括号是个对象构造块
  + [[https://stackoverflow.com/questions/2420389/static-initialization-blocks][java - Static Initialization Blocks - Stack Overflow]]
  + Java 数组会保存存储的元素的类型信息，虽然符类型的数组引用可以引用子类型的数组的实例，
    而且往该引用中存入父类型实例的操作可以通过编译器的检查，但是会在运行期间抛出异常。

* Proxy
  动态创建实现了指定接口的类，调用这个类的方法的时候实际上是调用内部包装的对象的方法。

  创建：
  #+BEGIN_SRC java
    Proxy.newProxyInstance(null, new Class<?>[] { Comparable.class }, InvocationHandler);
  #+END_SRC

  需要实现的方法：
  #+BEGIN_SRC java
    public Object invoke(Object proxy, Method m, Object[] args) throws Throwable {}
  #+END_SRC

  Timer:
  #+BEGIN_SRC java
    class TimerHandler implements InvocationHandler {
      private Object target;

      public TimerHandler(Object target) {
        this.target = target;
      }

      public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        long start = System.currentTimeMillis();
        method.invoke(target, args);
        long end = System.currentTimeMillis();
        System.out.printf("Runtime: %ldms\n", end - start);
      }
    }
  #+END_SRC

* Exception
  Throwable:
  #+BEGIN_SRC java
    Throwable()
    Throwable(String message);
    String getMessage();
  #+END_SRC

* 泛型
  + [[https://www.cnblogs.com/wuqinglong/p/9456193.html][Java泛型类型擦除以及类型擦除带来的问题 - 蜗牛大师 - 博客园]]

  泛型的类型检查是在 *编译前* 进行的。
