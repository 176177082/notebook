* bean
  + 条件化创建 Bean 时，单例模式下，如果创建失败就无法获取实例了
  + Condition 可以和 Compent 一起使用
  + 没有使用 AOP 的 Bean 获取是返回的就是它的实例，而使用了 AOP 的 Bean 返回的就是它的动态代理
  + 环绕 Advice 的返回值需要和被环绕的方法相同，传递给 Advice 的参数名称和 args 定义的相同
  + 当自动装配和 JavaConfig 同时存在是，会优先使用自动装配
  + Profile、Qualifier、Scope 都可以用于自动装配、JavaConfig、XMLConfig
  + 配置的处理顺序：AutoWired、JavaConfig、XMLConfig，其中，如果自动装配已创建 Bean，那么 JavaConfig 中的便无效。
  + 原型作用域会在需要 bean 的时候创建，单例会在启动时创建

* 问题
  + spring xml 过滤器
  + 获取 bean 时指定过滤器
  + 不同配置的执行顺序
  + XML 配置中的 bean 必然会创建
  + [[https://www.cnblogs.com/zrtqsk/p/3735273.html][Spring Bean的生命周期（非常详细） - Chandler Qian - 博客园]]

    
* 模式
  Spring 中的表单验证方式和 Flask 中的验证方式：
  + Python 中缺少进行依赖注入的方式，因此只能创建相应的类型
  + Java 中可以通过注解的的方式进行验证
  + [[https://blog.tonyseek.com/post/notes-about-ioc-and-di/][控制反转 (IoC) 和依赖注入 (DI)]]

* 自我装配
  + [[https://stackoverflow.com/questions/5152686/self-injection-with-spring][java - Self injection with Spring - Stack Overflow]]

* springcore
  #+BEGIN_SRC plantuml
    ,* 装配
    ,** 装配方式
    ,*** 自动装配
    ,*** JavaConfig
    ,*** XMLConfig
    ,** 高级装配
    ,*** @Profile
    ,*** @Condition
    ,*** @Qualifier
    ,*** @Scope
    ,*** @Value - 运行时值注入
    ,* AOP
    ,** 概念
    ,** Spring 切面
    ,** AspectJ 切面
  #+END_SRC

* 目录结构
  + [[https://www.tutorialspoint.com/spring_boot/spring_boot_code_structure.htm][Spring Boot Code Structure]]

* Servlet 3.0
  + [[https://www.ibm.com/developerworks/cn/java/j-lo-servlet30/index.html][Servlet 3.0 新特性详解]]
  + [[http://www.oracle.com/technetwork/cn/community/4-servlet-3-324302-zhs.pdf][JavaEE 6 Servlet 3.0 中的新特性 - Oracle]]
  + [[https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types][MIME 类型 - HTTP | MDN]]
  + [[https://www.infoq.cn/article/2013/11/use-asynchronous-servlet-improve][使用异步 Servlet 改进应用性能]]
  + [[https://www.cnblogs.com/davenkin/p/async-servlet.html][Servlet 3.0/3.1 中的异步处理 - 无知者云 - 博客园]]
  + [[https://segmentfault.com/a/1190000012318350][Servlet 3.0 异步处理详解 - 颇忒脱 - SegmentFault 思否]]
  + [[https://elim.iteye.com/blog/2426592][通过ServletContainerInitializer注册Servlet对象 - Elim的博客 - ITeye博客]]

** spring
   + [[https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/SpringServletContainerInitializer.java][spring-framework/SpringServletContainerInitializer.java at master · spring-projects/spring-framework]]
   + [[https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java][spring-framework/DispatcherServlet.java at master · spring-projects/spring-framework]]
   + [[https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/context/ContextLoaderListener.java][spring-framework/ContextLoaderListener.java at master · spring-projects/spring-framework]]

** 流程描述
   应用上下文的创建与配置：
   1. Servlet 容器寻找实现了 ServletContainerInitializer 的对象，Spring 中的是 SpringServletContainerInitializer，
      它会要求容器找到所有 WebApplicationInitializer 并传递给它
   2. SpringServletContainerInitializer 会创建 DispatcherServlet 和 ContextLoaderListener，两者会分别创建一个应用上下文
   3. 我们的 WebApplicationInitializer 实现中，方法 getServletMapping 配置 DispatcherServlet 的路径映射，getRootConfigClasses 提供 ContextLoaderListener 应用上下文的配置，
      getServletConfigClasses 提供 DispatcherServlet 应用上下文的配置
   4. 通常，我们会在 DispatcherServlet 上下文中配置视图解析器，静态资源处理，而 ContextLoaderListener 上下文中配置其他 Bean。

   请求的处理：
   1. 请求首先会到达 DispatcherServlet，然后会查询处理器映射找到与请求对应的控制器
   2. 控制器处理请求，产生需要返回给用户的信息 Model 并返回 *视图名*
   3. 视图解析器根据视图名找到视图
   4. 视图处渲染数据并返回给用户

   控制器：
   1. 使用注解 Controller 声明为控制器
   2. 使用 RequestMapping 声明路径映射
   3. 客户端数据获取：查询参数、表单参数和路径变量
   4. 表单效验可以通过注解实现

   视图解析器：
   1. SpringMVC 定义的视图解析器接口为：
      #+BEGIN_SRC java
        public interface ViewResolver {
          View resolverViewName(String viewName, Locale locale);
        }
      #+END_SRC

      方法 resolverViewName 会返回 View 实例。

   2. View 接口的定义：
      #+BEGIN_SRC java
        public interface View {
          void render(Map<String, ?> model, req, resp);
        }
      #+END_SRC
      
      方法 render 接受模型数据，请求和响应对象，渲染数据输入的响应。

   3. 使用 JSP 时，如果需要使用 JSTL，那么应该使用 JstlView。也就是说默认的视图不会渲染 JSTL 标签？

      没有人权的容器 QAQ

** 更多的配置
   鉴于初始化时或获取所有实现 WebApplicationInitializer 的类，那么我们可以实现这一接口，在这个接口的 onStartup 方法中借助 Servlet 3.0 进行动态配置。

   特别的：
   + AbstractAnnotationConfigDispatcherServletInitializer 的子类可以覆盖 customRegistrantion 进行额外的配置
   + 过滤器的配置可以通过覆盖 getServletFilters 方法完成

** 通过 DD 进行配置
   完全通过 XML 进行配置，需要分别指定 DispatcherServlet 和 ContextLoaderListener 上下文的配置文件。

   但也可以通过指定上下文类的方式指定使用 Java 配置，即：在 DispatcherServlet 和 ContextLoaderListener 的初始化参数中指定上下文为 AnnotationConfigWebApplicationContext，
   并指定配置类。

   估计默认情况下使用的是 XmlWebApplicationContext。


* 教程
  + Spring 官方教程
  + Servlet 3.0
  + Java 8
  + Object as Map
  + commons package
  + Junit
  + Maven
  + Gradle
  + [[https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html][Web on Servlet Stack]]

* mybatis
  + [[http://www.mybatis.org/spring/zh/getting-started.html][mybatis-spring – MyBatis-Spring | 入门]]


* 编码设置
  + [[https://stackoverflow.com/questions/5928046/spring-mvc-utf-8-encoding][java - Spring MVC UTF-8 Encoding - Stack Overflow]]
  + 通过 jsp-config 设置也行


* SpringMVC
  Handler 方法：支持灵活的方法签名，同时支持 java 8 Optional 作为具有 require 属性的注解参数，require 默认为 false。

  参数和返回值：
  + [[https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-arguments][Web on Servlet Stack - Handler Methods - Method Arguments]]
  + [[https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-return-types][Web on Servlet Stack - Handler Methods - Return Values]]

  类型转换：对于部分字符串形式的参数，Spring 支持自动将它们转换为其他类型，比如int、long、Date

  可以通过 @RequestBody 将请求主题转换为对象，还可以和 @Valid 配合使用。

  可以通过 @ResponseBody 将返回对象转为为响应主体。

* recent
  + [[https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html][Core Technologies]]
  + [[https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/testing.html][Testing]]
  + [[https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/data-access.html][Data Access]]
  + [[https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html][Web on Servlet Stack]]

* structure
  + [[https://stackoverflow.com/questions/12397940/spring-and-mvc-proper-project-structure][java - Spring and MVC proper project structure - Stack Overflow]]


* 静态资源和 CLASSPATH
  + [[https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-config-static-resources][mvc-config-static-resources]]
  + [[https://segmentfault.com/a/1190000015802324][java项目中的classpath到底是什么 - mmmming - SegmentFault 思否]]

  静态页面的映射的配置是需要的吗？

