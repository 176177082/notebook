* bean
  + 条件化创建 Bean 时，单例模式下，如果创建失败就无法获取实例了
  + Condition 可以和 Compent 一起使用
  + 没有使用 AOP 的 Bean 获取是返回的就是它的实例，而使用了 AOP 的 Bean 返回的就是它的动态代理
  + 环绕 Advice 的返回值需要和被环绕的方法相同，传递给 Advice 的参数名称和 args 定义的相同
  + 当自动装配和 JavaConfig 同时存在是，会优先使用自动装配
  + Profile、Qualifier、Scope 都可以用于自动装配、JavaConfig、XMLConfig
  + 配置的处理顺序：AutoWired、JavaConfig、XMLConfig，其中，如果自动装配已创建 Bean，那么 JavaConfig 中的便无效。
  + 原型作用域会在需要 bean 的时候创建，单例会在启动时创建

* 模式
  Spring 中的表单验证方式和 Flask 中的验证方式：
  + Python 中缺少进行依赖注入的方式，因此只能创建相应的类型
  + Java 中可以通过注解的的方式进行验证
  + [[https://blog.tonyseek.com/post/notes-about-ioc-and-di/][控制反转 (IoC) 和依赖注入 (DI)]]

* 自我装配
  + [[https://stackoverflow.com/questions/5152686/self-injection-with-spring][java - Self injection with Spring - Stack Overflow]]

* springcore
  #+BEGIN_SRC plantuml
    ,* 装配
    ,** 装配方式
    ,*** 自动装配
    ,*** JavaConfig
    ,*** XMLConfig
    ,** 高级装配
    ,*** @Profile
    ,*** @Condition
    ,*** @Qualifier
    ,*** @Scope
    ,*** @Value - 运行时值注入
    ,* AOP
    ,** 概念
    ,** Spring 切面
    ,** AspectJ 切面
  #+END_SRC

