* Future
  + [[http://www.ruanyifeng.com/blog/2017/08/elasticsearch.html][全文搜索引擎 Elasticsearch 入门教程 - 阮一峰的网络日志]]
  + [[https://www.baeldung.com/spring-boot-devtools][Overview of Spring-Boot Dev Tools | Baeldung]]
  + [[https://commons.apache.org/][Apache Commons – Apache Commons]]
    
** Spring Cloud
   + [[https://www.cnblogs.com/fengzheng/p/10603672.html][Spring Cloud 系列之 Eureka 实现服务注册与发现 - 风的姿态 - 博客园]]
   + [[http://blog.didispace.com/springcloud1/][Spring Cloud构建微服务架构（一）服务注册与发现 | 程序猿DD]]
   + [[http://blog.didispace.com/springcloud5/][Spring Cloud构建微服务架构（五）服务网关 | 程序猿DD]]
   + [[https://juejin.im/post/5adee863f265da0b7527c26e][Spring Cloud Ribbon 客户端负载均衡 - 掘金]]
   + [[https://www.jianshu.com/p/3e11ac385c73][Hystrix技术解析 - 简书]]
   + [[https://cloud.spring.io/spring-cloud-static/Greenwich.SR3/single/spring-cloud.html#_spring_cloud_commons_common_abstractions][Spring Cloud 官方文档]]
   + Spring Cloud Security 和 Spring Security 之间的关系

** Spring WebFlux
   + [[https://www.ibm.com/developerworks/cn/java/spring5-webflux-reactive/index.html][使用 Spring 5 的 WebFlux 开发反应式 Web 应用]]
   + [[https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html][Web on Reactive Stack]]

** Mongodb
   + [[https://docs.spring.io/spring-data/mongodb/docs/2.2.3.RELEASE/reference/html/#reference][Spring Data MongoDB - Reference Documentation]]

* Spring MVC
  #+begin_src java
    private Optional<ApiOperation> getApiOperation(HttpServletRequest request) {
      try {
        return Optional.ofNullable(requestMappingHandlerMapping.getHandler(request))
          .map(handlerExecutionChain -> {
              Object object = handlerExecutionChain.getHandler();
              if (object instanceof HandlerMethod) {
                return ((HandlerMethod) object).getMethodAnnotation(ApiOperation.class);
              }
              return null;
            });
      } catch (Exception e) {
        log.info("无匹配 Handler 的请求 {}", request.getRequestURI());
      }
      return Optional.empty();
    }

    /**
     ,* 异常信息
     ,*/
    @Data
    public static class DataCaptureExceptionInfo {
      /**
       ,* 异常信息
       ,*/
      private String message;

      /**
       ,* 栈追踪信息
       ,*/
      private List<String> stackTrace;

      /**
       ,* 根据异常创建 DataCaptureExceptionInfo 实例
       ,*
       ,* @param ex 异常实例
       ,* @return DataCaptureExceptionInfo 实例
       ,*/
      public static DataCaptureExceptionInfo of(Throwable ex) {
        DataCaptureExceptionInfo dataCaptureExceptionInfo = new DataCaptureExceptionInfo();

        dataCaptureExceptionInfo.setMessage(ex.getMessage());

        List<String> stackTrace = new ArrayList<>();
        while (Objects.nonNull(ex)) {
          StackTraceElement stackTraceElement = ex.getStackTrace()[0];

          stackTrace.add(String.format("%s at %s(%s:%d)", stackTraceElement.getClassName(), stackTraceElement.getMethodName(), stackTraceElement.getFileName(),
                                       stackTraceElement.getLineNumber()));

          ex = ex.getCause();
        }
        dataCaptureExceptionInfo.setStackTrace(stackTrace);

        return dataCaptureExceptionInfo;
      }
    }

  #+end_src

* JSON
  fastjson - JSON.parse


* AOP
  动态代理是使用 Proxy 还是 CGLIB 需要考虑的应该是需要注入的 Bean 的类型，如果要注入的是类的话，就只有 CGLIB 了，如果是 Interface 和 InterfaceImpl 的形式，还可以用 Proxy

