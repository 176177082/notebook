* try & catch & throw
  + [[http://www.di.unipi.it/~nids/docs/longjump_try_trow_catch.html][Exceptions in C with Longjmp and Setjmp]]

  异常机制：
  + 异常机制通过非本地跳转实现
  + try 语句块中抛出异常， 触发非本地跳转
  + catch 语句块中为触发异常后的执行语句
  + 可能对某些信号处理程序进行了修改， 当收到这些信号时， 抛出一个异常而不是终止程序

* 进程
  异常是允许操作系统内核提供 *进程* 概念的基本构造块。

  进程轮流使用处理器， 进程的切换通过 *上下文切换* 完成。

** 并发流
   异常处理程序、 进程、 信号处理程序、 线程等都是 *逻辑流* 的例子。

   当一个逻辑流的 *执行时间(生命周期)* 与另一个流 *重叠*, 就说这两个流逝 *并发流*.

   两个流并发的运行在不同的处理器或计算机上时， 就说这两个流逝 *并行的*.

   因此， 并发流包含并行流。

** 用户模式和内核模式
   运行在 *内核模式* 中的进程可以执行任何指令， *用户模式* 中的进程必须通过系统接口间接的访问 *内核* 代码和数据。

   一个进程初始时是位于 *用户模式* 下的， 通过异常可以从 *用户模式* 切换到 *内核模式*.

   相当数量的功能都需要 *内核* 提供支持， 这些功能通过 *系统调用* 完成。

   某些系统调用会需要一定的时间， 如磁盘读取数据， 这时系统执行 *上下文切换*, 这段时间用于另一个进程的执行。

   磁盘读取数据完成是， 产生一个中断， 使得系统再次执行 *上下文切换*, 返回之前的进程。

   上下文切换时， 先进入 *内核模式*, 切换完成后进入 *用户模式*.

   因此， 上下文切换一般由 *系统调用* 或 *中断* 异常引起。

* 信号
  操作系统通过更行目标进程的 *上下文* 中的某个状态来向一个 *进程* 发送 *信号*.

  进程可以接受信号并进行处理， 每个信号都有默认的 *信号处理程序*.

  一个发出而没有被解释的信号叫做 *待处理信号*, 在任何时刻， *一种类型* 至多只会有一个待处理信号， 多于的
  信号会被丢弃。

  一个待处理信号最多只能被接受一次。

  信号的发送和对应信号处理程序的调用由 *操作系统* 完成， 我们可以显示的让操作系统发送信号， 也可以替换
  一些信号默认的信号处理程序。

  标准库头文件 ~<signal.h>~ 定义了相关的函数。

** 非本地跳转
   标准可头文件 ~<setjmp.h>~ 提供了实现非本地跳转的函数 ~setjmp~ 和 ~longjmp.~

   #+BEGIN_SRC C
     setjmp(jmp_buf env);

     longjmp(jmp_buf env, int val);
   #+END_SRC

   调用 ~setjmp~ 时， 会将当前的 *上下文* 信息保存在 ~env~ 中， 并返回数字 ~0~.

   调用 ~longjmp~ 时， 会根据 ~env~ 中的信息跳转到 *最近* 一次调用 ~setjmp~ 的位置， ~setjmp~ 返回 ~longjmp~ 的参数 ~val~ 的值。

   如果 ~val~ 是零， 那么 ~setjmp~ 会返回 ~1~.

   即： ~setjmp~ 调用一次， 返回两次。

   ~setjmp~ 的返回值不能赋给变量， 但是可以用于 *条件判断*.

