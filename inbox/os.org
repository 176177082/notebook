* 动态链接共享库
  共享库的特点：
  + 在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；
  + 在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。

  动态库的编译使用 ~-shared -fpic~ 选项：
  #+BEGIN_SRC bash
    $ gcc -shared -fpic -o libxxx.so xxx.c xxx.c
  #+END_SRC

  加载执行前加载链接共享库：
  #+BEGIN_SRC bash
    $ gcc -o prog prog.c libxxx.so
  #+END_SRC

  运行时加载链接共享库：
  #+BEGIN_SRC C
    #include <dlfcn.h>

    void* dlopen(const char* filename, int flag);  // 成功返回指向句柄的指针， 失败返回 NULL
    void* dlsym(void* handle, cha* symbol);  // 成功返回中指向符号的指针， 失败返回 NULL
    int dlclose(void* handle);  // 成功返回 0, 出错返回 -1
    const char* dlerror(void);  // 如果前面三个函数调用失败， 则返回错误信息， 否则返回 NULL
  #+END_SRC
  
* 系统级 I/O
  ~Unix/Linux~ 系统中， 将所有的 ~I/O~ 设备都当做是 *文件*, 使用统一输入输出接口来操作这些对象。

  文件操作有：
  + 打开文件： 通过内核打开文件时， 内核会返回一个小的非负整数， 称为 *描述符*. 用于在后续的操作中标识打开的文件。
    由内核记录有关这个文件的所有信息， 应用程序只需要记住这个描述符。
    
    每个进程开始时都有三个打开的文件： 标准输入 - 0、 标准输出 - 1、 标准错误 - 2.
  + 改变当前的文件位置： 对于每个打开的文件， 内核保持着一个文件位置 *k*, 初始为 0。 表示从文件开头起始的 *字节偏移量*.

    应用程序通过 seek 操作显示的设置文件当前位置为 k.
  + 读写文件： 读操作是从当前文件复制 n > 0 个字节到内存， 然后 k += n. 当 k 的大小超出文件大小是， 会除法 EOF 条件， 应用程序
    能够检测到这个条件。

    写操作是从内存复制 n > 0 个字节到文件， k += n.
  + 关闭文件： 关闭文件时内核释放打开文件时创建的数据结构， 并将描述符恢复到可用的 *描述符池*.

  文件类型包括： 普通文件（文本与二进制文件）、 目录文件、 套接字、 命名通道、 符号链接、 字符和块设备

** 文件操作接口
   #+BEGIN_SRC C
     #include <sys/types.h>
     #include <sys/stat.h>
     #include <fcntl.h>

     // 打开文件并返回文件描述符， 出错返回 -1
     int open(char* filename, int flags, mode_t mode);


     #include <unistd.h>

     // 关闭文件， 成功返回 0, 错误返回 -1, 关闭已关闭文件描述符会出错
     int close(int fd);


     #include <unistd.h>

     // 读 & 写
     size_t read(int fd, void* buf, size_t n);

     ssize_t write(int fd, const void* buf, size_t n);
   #+END_SRC
   
   + CSAPP-P625

        
