* Future
  + [[https://docs.oracle.com/cd/E17904_01/web.1111/e13712/web_xml.htm#WBAPP543][A web.xml Deployment Descriptor Elements]]
  + [[https://stackoverflow.com/questions/1515190/relationship-between-jsp-and-java-ee][Relationship between JSP and Java EE - Stack Overflow]]

* 问题
  + MIME
  + Tomcat 的使用
  + Java EE 1.5 & Servlet 2.5，新版本的东西需要补一下
  + 6 - 3.0，7 - 3.1，8 - 4.0
  + 过滤器中分派或不继续传递 - 就分派到目标 Servlet 或无响应

* IDEA
  相关的问题：
  + Maven 插件配置
  + Maven 镜像配置
  + 插件 Tomcat7 的使用
  + web-app 项目结构
  + 编译属性 - 字符编码之类的
  + 模块

* 生态
  + [[https://www.zhihu.com/question/263954669][Java的生态系统为什么好？好在哪里？ - 知乎]]
  + [[https://github.com/aalansehaiyang/technology-talk][aalansehaiyang/technology-talk: 汇总java生态圈常用技术框架、开源中间件，系统架构、项目管理、经典架构案例、数据库、常用三方库、线上运维等知识]]
  + [[https://juejin.im/post/5c07d0a36fb9a04a0955d4cd][Java简单介绍及Java生态 - 掘金]]
  + [[https://www.zhihu.com/question/19730582][中间件是什么？如何解释比较通俗易懂？ - 知乎]]

* 书籍
  + Java EE without EJB
  + Dependency Injection
  + AspectJ in Action
  + Spring Boot in Action
  + Rod Johnson 的三本红宝书

    
* Servlet 3.0
  + [[https://www.ibm.com/developerworks/cn/java/j-lo-servlet30/index.html][Servlet 3.0 新特性详解]]
  + [[http://www.oracle.com/technetwork/cn/community/4-servlet-3-324302-zhs.pdf][JavaEE 6 Servlet 3.0 中的新特性 - Oracle]]
  + [[https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types][MIME 类型 - HTTP | MDN]]
  + [[https://www.infoq.cn/article/2013/11/use-asynchronous-servlet-improve][使用异步 Servlet 改进应用性能]]
  + [[https://www.cnblogs.com/davenkin/p/async-servlet.html][Servlet 3.0/3.1 中的异步处理 - 无知者云 - 博客园]]
  + [[https://segmentfault.com/a/1190000012318350][Servlet 3.0 异步处理详解 - 颇忒脱 - SegmentFault 思否]]
  + [[https://elim.iteye.com/blog/2426592][通过ServletContainerInitializer注册Servlet对象 - Elim的博客 - ITeye博客]]

** spring
   + [[https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/SpringServletContainerInitializer.java][spring-framework/SpringServletContainerInitializer.java at master · spring-projects/spring-framework]]
   + [[https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java][spring-framework/DispatcherServlet.java at master · spring-projects/spring-framework]]
   + [[https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/context/ContextLoaderListener.java][spring-framework/ContextLoaderListener.java at master · spring-projects/spring-framework]]

** 流程描述
   应用上下文的创建与配置：
   1. Servlet 容器寻找实现了 ServletContainerInitializer 的对象，Spring 中的是 SpringServletContainerInitializer，
      它会要求容器找到所有 WebApplicationInitializer 并传递给它
   2. SpringServletContainerInitializer 会创建 DispatcherServlet 和 ContextLoaderListener，两者会分别创建一个应用上下文
   3. 我们的 WebApplicationInitializer 实现中，方法 getServletMapping 配置 DispatcherServlet 的路径映射，getRootConfigClasses 提供 ContextLoaderListener 应用上下文的配置，
      getServletConfigClasses 提供 DispatcherServlet 应用上下文的配置
   4. 通常，我们会在 DispatcherServlet 上下文中配置视图解析器，静态资源处理，而 ContextLoaderListener 上下文中配置其他 Bean。

   请求的处理：
   1. 请求首先会到达 DispatcherServlet，然后会查询处理器映射找到与请求对应的控制器
   2. 控制器处理请求，产生需要返回给用户的信息 Model 并返回 *视图名*
   3. 视图解析器根据视图名找到视图
   4. 视图处渲染数据并返回给用户

   控制器：
   1. 使用注解 Controller 声明为控制器
   2. 使用 RequestMapping 声明路径映射
   3. 客户端数据获取：查询参数、表单参数和路径变量
   4. 表单效验可以通过注解实现

   视图解析器：
   1. SpringMVC 定义的视图解析器接口为：
      #+BEGIN_SRC java
        public interface ViewResolver {
          View resolverViewName(String viewName, Locale locale);
        }
      #+END_SRC

      方法 resolverViewName 会返回 View 实例。

   2. View 接口的定义：
      #+BEGIN_SRC java
        public interface View {
          void render(Map<String, ?> model, req, resp);
        }
      #+END_SRC
      
      方法 render 接受模型数据，请求和响应对象，渲染数据输入的响应。

   3. 使用 JSP 时，如果需要使用 JSTL，那么应该使用 JstlView。也就是说默认的视图不会渲染 JSTL 标签？

      没有人权的容器 QAQ

** 更多的配置
   鉴于初始化时或获取所有实现 WebApplicationInitializer 的类，那么我们可以实现这一接口，在这个接口的 onStartup 方法中借助 Servlet 3.0 进行动态配置。

   特别的：
   + AbstractAnnotationConfigDispatcherServletInitializer 的子类可以覆盖 customRegistrantion 进行额外的配置
   + 过滤器的配置可以通过覆盖 getServletFilters 方法完成

** 通过 DD 进行配置
   完全通过 XML 进行配置，需要分别指定 DispatcherServlet 和 ContextLoaderListener 上下文的配置文件。

   但也可以通过指定上下文类的方式指定使用 Java 配置，即：在 DispatcherServlet 和 ContextLoaderListener 的初始化参数中指定上下文为 AnnotationConfigWebApplicationContext，
   并指定配置类。

   估计默认情况下使用的是 XmlWebApplicationContext。

