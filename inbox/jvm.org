#+TITLE:      Java 虚拟机结构

* 目录                                                    :TOC_4_gh:noexport:
- [[#运行时数据区域][运行时数据区域]]
- [[#对象的创建和内存布局][对象的创建和内存布局]]
- [[#垃圾回收][垃圾回收]]
- [[#类文件结构][类文件结构]]
- [[#字节码指令][字节码指令]]

* 运行时数据区域
  Java 虚拟机的运行时数据区分为：
  1. 程序计数器 PC，是一块较小的内存空间，可以看做是当前线程所指向的字节码的行号指示器，各线程的程序计数器互不影响
  2. Java 虚拟机栈，线程私有，保存方法执行时需要的数据，可能抛出 StackOverflowError 和 OutOfMemoryError 异常
  3. 本地方法栈，和虚拟机栈类似，为 native 方法服务，可能抛出 StackOverflowError 和 OutOfMemoryError 异常
  4. Java 堆，被所有线程共享的内存区域，用于存放所有的对象实例，可能抛出 OutOfMemoryError 异常
  5. 方法区，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态常量等数据，可能抛出 OutOfMemoryError 异常
  6. 运行时常量池，是方法区的一部分，用于存放编译器生成的各种字面量和符号引用，也可以在运行期间将新的常量放入

  其中，程序计数器、虚拟机栈和本地方法栈都是线程独立的，而方法区和堆被所有线程共享。

  另外，需要注意区分 Class 文件常量池和运行时常量池，Class 文件常量池中的内容会在加载时自动放入运行时常量池，但同时也可以在运行期间将常量放入运行时常量池。

* 对象的创建和内存布局
  通过 =new= 指令创建对象的流程为：
  1. 检查这个指令的参数能否在常量池中定位到一个类的符号引用
  2. 检查这个符号引用代表的类是否已被加载、解析和初始化过
  3. 如果没有，就必须先执行类加载过程
  4. 在类加载检查通过后，虚拟机便可以为新对象分配内存
  5. 内存分配完后，需要将分配到的内存空间都初始化为零值（不包括对象头），这一步保证了实例字段即使不赋值也可以直接使用
  6. 对对象进行必要的设置，例如这个对象是哪个类的实例、如何找到类的元数据信息、对象的哈希码等信息，这些信息存放在对象头（Object Header）中
  7. 一般来说，在前面的步骤完成后还会执行 =<init>= 方法，由字节码中是否跟随 =invokespecail= 指令决定
  
  其中，在分配内存时可以选择的策略有：
  1. 指针碰撞，内存空间规整，直接一段指针分配内存就可以了
  2. 空闲列表，内存空间不规整，虚拟机需要维护一个列表，记录哪些内存块时可用的，在分配的时候在列表中找到足够大的空间划分给对象实例，并更新列表记录

  另外，由于对象创建十分频繁的行为，为了避免出现正在给对象 A 分配内存，指针还没来得及修改，对象 B 有同时使用了原来的指针分配内存的情况，虚拟机有两种解决方案：
  1. 对分配内存空间的动作进行同步处理，保证原子性
  2. 把内存分配的动作按照线程划分到不同的空间进行，即每个线程在 Java 堆中预分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）。
     现在 TLAB 上分配内存，不够时才同步分配新的 TLAB。

     对象创建的第 5 步其实就可以提前到 TLAB 阶段完成。

  对象在内存中主要包含两个部分：
  1. 对象头，包含两个部分，一部分用于存储对象自身的运行时数据，如哈希码、锁状态标志、线程持有的锁等。另一部分是类型指针，用于执行对象类元数据的指针，但不是所有虚拟机实现都有。

     因为对象的访问定位可以由两种形式：
     1. 使用句柄，在堆中划分一块内存作为句柄池，引用中保存的就是对象的句柄地址，而句柄中包含 *对象实例数据* 和 *类型数据* 各自的地址信息
     2. 使用直接指针访问，这时对象头中就需要类型指针了
        
     同时，假如对象是数组，那么对象头还需要保证数组的大小信息。
     
  2. 实例数据，主要就是各个实例字段数据，通常相同宽度的字段会被放在一起
  
  除了对象头和实例数据以外，可能还要对齐填充，保证对象的大小是 8 的整数倍。

* 垃圾回收
  Java 中通过（根）可达性分析算法来判定对象是否存活，在 Java 语言中，可作为 GC Roots 的对象有：
  1. 虚拟机栈中引用的对象
  2. 方法区中类静态属性引用的对象
  3. 方法区中常量引用的对象
  4. 本地方法栈中引用的对象

  堆中对象的死活判定比较方便，而方法区中的常量也很容易判断死活，相对麻烦的是类，满足以下条件的类才是无用的类：
  1. 该类的所有实例都已被回收
  2. 加载该类的 ClassLoader 已经被回收
  3. 该类对应的 Class 对象没有在任何地方被引用

  在知道怎么判断一个对象的死活后，剩下的就是如何回收内存了，主要有三种算法：
  1. 标记清除算法，首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，主要问题是效率低，同时会产生大量不连续的内存碎片
  2. 复制算法，将内存分配为多个区域，每次只使用其中一部分内存，回收时将存活对象复制到空闲内存，主要问题是会造成内存空间的浪费，内存不足时还需要依赖其他内存进行分配担保
  3. 标记整理算法，算法过程和标记清除算法类似，区别在于清理时是将存活对象往内存的一端移动

  根据对象存活的周期不同，虚拟机往往采用分代收集算法来同时使用多个算法，比如将内存分为新生代和老年代，在新生代采用复制算法，在老年代采用标记清除或标记整理算法

  实现这些回收策略的垃圾收集器：
  |-------------------+--------------------------------------------+------------+--------------|
  | 垃圾收集器        | 特点                                       | 新生代算法 | 老年代算法   |
  |-------------------+--------------------------------------------+------------+--------------|
  | Serial            | 单线程，GC 时阻塞所有工作现场              | 复制算法   |              |
  | ParNew            | 多线程，GC 时阻塞所有工作现场              | 复制算法   |              |
  | Parallel Scavenge | 可以通过控制收集评率达到一个可控制的吞吐量 |            |              |
  | Serial Old        | Serial 的老年代版本                        |            | 标记整理算法 |
  | ParNew Old        | ParNew 的老年代版本                        |            | 标记整理算法 |
  | ……                |                                            |            |              |
  |-------------------+--------------------------------------------+------------+--------------|

  因为对内存区域进行了划分，因此 GC 方法也可以分为 Minor GC（新生代 GC）和 Full GC，通常，现在一些优秀的垃圾回收器可以在不阻塞工作线程的情况下进行 GC，
  但是 Full GC 的时候，往往就避免不了要停顿工作线程了。

* 类文件结构
  Java 虚拟机类文件中采用类似 C 语言结构体的伪结构来存储数据，这种结构只有两种数据类型：无符号数和表，其中，无符号数采用大端形式存储：
  |----------------+---------------------+-------------------------+--------------------|
  | 类型           | 名称                |                    数量 | 含义               |
  |----------------+---------------------+-------------------------+--------------------|
  | u4             | magic               |                       1 | Magic Number       |
  |----------------+---------------------+-------------------------+--------------------|
  | u2             | minor_version       |                       1 | 次版本号           |
  | u2             | major_version       |                       1 | 主版本号           |
  |----------------+---------------------+-------------------------+--------------------|
  | u2             | constant_pool_count |                       1 | 常量池大小         |
  | cp_info        | constant_pool       | constant_pool_count - 1 | 常量信息表         |
  |----------------+---------------------+-------------------------+--------------------|
  | u2             | acess_flags         |                       1 | 访问标志           |
  | u2             | this_class          |                       1 | 当前类全限定名索引 |
  | u2             | super_class         |                       1 | 父类全限定名索引   |
  | u2             | interfaces_count    |                       1 | 实现接口数量       |
  | u2             | interfaces          |        interfaces_count | 接口全限定名索引   |
  |----------------+---------------------+-------------------------+--------------------|
  | u2             | fields_count        |                       1 | 字段信息表数量     |
  | field_info     | fields              |            fields_count | 字段信息表         |
  |----------------+---------------------+-------------------------+--------------------|
  | u2             | methods_count       |                       1 | 方法信息表数量     |
  | method_info    | methods             |           methods_count | 方法信息表         |
  |----------------+---------------------+-------------------------+--------------------|
  | u2             | attributes_count    |                       1 | 类额外属性数量     |
  | attribute_info | attributes          |        attributes_count | 类额外属性表       |
  |----------------+---------------------+-------------------------+--------------------|

  除了类文件以外，字段信息表和方法信息表都可以有自己的属性表，各表主体信息只保存一些相对固定的数据，比如访问表示、限定名称索引等，
  而其他属性，如方法字节码、行号等就保存在对应的属性表中。

  整体来看，类文件的格式和网络协议相似，类似于 TLV 格式，可以通过 ~javap -v~ 选项来查看对应信息。

  方法和字段描述符格式：
  1. 类型的表示方式通过标识字符和限定名组成：
     |----------+--------+----------+--------------------------------|
     | 标识字符 | 含义   | 标识字符 | 含义                           |
     |----------+--------+----------+--------------------------------|
     | B        | byte   | J        | long                           |
     | C        | char   | S        | short                          |
     | D        | double | Z        | boolean                        |
     | F        | float  | V        | void                           |
     | I        | int    | L        | 对象类型，如 Ljava/lang/Object |
     |----------+--------+----------+--------------------------------|
  2. 对于数组类型，每一维度使用一个前置的 ~[~ 字符描述，因此 ~String[][]~ 的描述符就为 ~[[Ljava/lang/String~
  3. 方法描述符的格式为 ~(参数描述符...)返回值描述符~, 比如 ~void method(int a, String b)~ 的描述符就为 ~(ILjava/lang/String)V~
  4. 描述符结尾往往还会有一个分号，比如 ~(II)I;~

* 字节码指令
  Java 虚拟机采用面向操作数栈的架构，指令由单字节的操作码和跟随之后的零个或多个操作数构成。

  针对不同的类型，虚拟机可能提供了相同操作码的不同特化，这些操作码可以通过操作码助记符区分：
  + i - int、l - long、s - short、b - byte、c - char、f - float、d - double、a - reference

  这里可以看出来，能够存储在栈中的数据除了基本数据类型以外就是引用了。

  编译器会在编译期货运行期将 byte 和 short 类型数据符号扩展为相应的 int 类型数据，将 boolean 和 char 类型无符号扩展为相应的 int 类型数据，
  从而复用 int 类型的操作码，避免重复定义太多指令。

  相对特殊的是同步指令，分为两种情况：
  1. 方法级别的同步，无需字节码指令实现，当虚拟机发现 ACC_SYNCHRONIZED 标志为 true 时便会自动加锁
  2. 代码块的同步，通过 ~monitorenter~ 和 ~monitorexit~ 指令完成，编译器会保证只要调用过 ~monitorenter~ 就一定会调用 ~monitorexit~

     比如生成一个异常处理器，即使同步代码块中抛出了异常也会执行 ~monitorexit~ 指令

