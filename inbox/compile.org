* 词法单元的识别
  词法分析的一项工作是过滤源程序中的空白字符，这一目标可以通过如下方式实现：

  在读取到空白字符词法单元时不将其返回给语法分析器，而是继续读取下一词法单元，空白字符的词法单元定义：
  
  #+BEGIN_EXAMPLE
    ws -> (blank|tab|newline)+
  #+END_EXAMPLE

  + *保留字和标识符的识别*

    可以使用两种方法来处理那些看起来很像标识符的保留字：
    1. 初始化是就将各个保留字填入符号表中
    2. 为每个关键字建立单独的状态转换图

    相对来说，方法 1 更容易实现。

  + *基于状态转换图的词法分析器的体系结构*

    状态图由一些列的状态组成，为这些状态标上号，程序中可以用一个变量如 ~state~ 来表示当前所处的状态。

    读取到一个字符后将状态转移到下一个状态。同时需要注意某些状态上的 *字符回退*.

    #+BEGIN_SRC C
      while (true) {
        switch(state) {
          case 0:
            c = nextChar();

            if (c == '<') state = 1;
            elif (c == '>') state = 5;
            ...
            else fail();
            break;

          case 1:
            ...

          case 8:
            retract();  // 该状态需要字符回退
            return Token;  // 接受状态返回 Token
        }
      }
    #+END_SRC

    ~fail~ 代表状态转换无法继续，词法分析出错，调用错误恢复策略。

    针对不同的词法单元的状态转换图，可以考虑用如下几个方式进行处理：
    1. 让词法分析器顺序地尝试各个词法单元的状态转换图
    2. 可以并行的运行各个状态转换图，当多个匹配成功时，选择长的那一个
    3. 将所有状态转换图合并为一个图

* 有穷自动机
  有穷自动机是 *识别器*, 它们只能对每个输入串简单地回答 *是* 或 *否*, 分为两类：
  1. *不确定的有穷自动机 - NFA* - 对边上的标号无限制，一个符号标记离开同一状态的多条边，
     并且空串也可以作为标号。
  2. *确定的有穷自动机 - DFA* - 对于每个状态及自动机输入字母表中的每个符号，有且只有一条离开该状态、
     以该符号位标号的便。

  NFA 和 DFA 表示的语言的集合是相同的，这个集合中的语言被称为 *正则语言*.

  + *不确定的有穷自动机*

    NFA 的组成包括：
    1. 一个有穷的状态集合 S
    2. 一个输入符号集合 - *输入字母表*, 假设 *空串* 不是字母表中的元素
    3. 一个 *转换函数*, 它为每个状态和 *{输入字母表,空串}* 中的每个符号都给出了相应的 *后继状态* 的集合
    4. S 中的一个状态 S0 被指定为 *开始状态*
    5. S 的一个子集 F 被指定为 *接受状态*

  + *转换表*
    
    NFA 可以表示为一张 *转换表*, 表的各行对应于状态，各列对应于输入符号和 空串.
    
    (a|b)*abb 的转换表可以表示为：
    |------+--------+-----+------|
    | 状态 | a      | b   | 空串 |
    |------+--------+-----+------|
    |    0 | {0, 1} | {0} | /    |
    |    1 | /      | {2} | /    |
    |    2 | /      | {3} | /    |
    |    3 | /      | /   | /    |
    |------+--------+-----+------|

  + *自动机中输入字符串的接受*

    只要存在某条标号序列位某符号串的路径能够从开始状态到达某个接受状态， NFA 就接受这个符号串。

  + *确定的有穷自动机*

    确定的有穷自动机是不确定的有穷自动机的一个特例，其中：
    1. 没有输入空串之上的转换动作
    2. 对每个状态 s 和每个输入符号 a， 有且只有一条标号为 a 的边离开 s

    NFA 抽象地表示了用来识别某个语言中串的算法，而相应的 DFA 则是一个具体的识别串的算法。

    DFA 的模拟算法：
    #+BEGIN_SRC C
      s = s0;  // 开始状态
      c = nextChar();  // 下一个输入符号

      while (c != eof) {
        s = move(s, c);  // 从状态 s 出发，标号为 c 的边所到达的状态
        c = nextChar();
      }

      if (s in F) return "yes";  // F 接受状态集
      else return "no";
    #+END_SRC

* 从正则表达式到自动机
  + *子集构造法 NFA -> DFA*
    
    子集构造法的基本思想为：让构造得到的 DFA 的每个状态对应于 NFA 的一个状态集合。

    子集构造算法：
    + 输入： 一个 NFA N
    + 输出： 一个接受同样语言的 DFA D
    + 方法： 算法为 D 构造一个转换表 Dtran。D 的每个状态是一个 NFA 状态集合。

      |------------+--------------------------------------------------------------------|
      | 操作       | 描述                                                               |
      |------------+--------------------------------------------------------------------|
      | closure(s) | 能够从 NFA 的 *状态* s 开始只通过 *空串* 到达的 NFA 状态集合           |
      | closure(T) | 能够从 T 中的某个 NFA 状态 s 开始只通过 *空串* 到达的 NFA 状态集合   |
      | move(T, a) | 能够从 T 中的某个状态 s 出发通过标号为 a 的转换到达的 NFA 状态集合 |
      |------------+--------------------------------------------------------------------|
      
      s 是单个状态，而 T 是状态集合。

      算法模拟：
      #+BEGIN_SRC C
        Dstates = [closure(s0)];           // 初始状态集未被标记
        while (not markedAll(Dstates)) {   // 存在未被标记的状态集
          T = Dstates.getNotMarked();      // 取出一个未被标记的状态集
          mark(T);                         // 标记它
          U = closure(move(T, a));        //  很关键
          if (U not in Dstates) {
            Dstates.push(U);
          }
          Dtrans[T, a] = U;                // DFA
        }
      #+END_SRC

  + *NFA 的模拟*

    #+BEGIN_SRC C
      S = closure(s0);
      c = nextChar();
      while (c != eof) {
        S = closure(move(S, c));
        c = nextChar();
      }

      return (S & F) != 空；
    #+END_SRC
