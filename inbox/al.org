* 大数的实现
  实现大数的两种基本思路：
  + 将大数用 10 进制字符数组进行表示，然后模拟进行竖式计算的过程编写其加减乘除函数
  + 将大数当作一个二进制流进行处理，使用各种移位和逻辑操作来进行加减乘除运算

  可以参考的实现：
  + [[http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/java/math/BigInteger.java][jdk8/jdk8/jdk: 687fd7c7986d src/share/classes/java/math/BigInteger.java]]
    
  可参考的思路：
  + [[https://www.pediy.com/kssd/pediy05/pediy50664.htm][RSA 与大数运算]]

* 斐波那契堆
  + [[https://www.cnblogs.com/skywang12345/p/3659060.html][斐波那契堆(一)之 图文解析 和 C语言的实现 - 如果天空不死 - 博客园]]
  + [[https://github.com/danielborowski/fibonacci-heap-python/blob/master/fib-heap.py][fibonacci-heap-python/fib-heap.py at master · danielborowski/fibonacci-heap-python]]

* 拼写检查
  + [[https://en.wikipedia.org/wiki/BK-tree][BK-tree - Wikipedia]]

* 二叉树高度获取
  #+BEGIN_SRC java
    public int getHeight(TreeNode root) {
      if (root == null)
        return 0;
      return 1 + Math.max(getHeight(root.left), getHeight(root.right));
    }
  #+END_SRC

* 二分查找
  基础实现：
  #+BEGIN_SRC python
    def binary_search(array, size, target):
        left, right = 0, size - 1
        while left <= right:
            mid = floor((left + right) / 2)
            if array[mid] > target:
                right = mid - 1
            elif array[mid] < target:
                left = mid + 1
            else:
                return mid
        return -1
  #+END_SRC

  基础实现的变种，可以减少每次比较的次数，但是需要多进行一次迭代：
  #+BEGIN_SRC python
    def binary_search(array, size, target):
        left, right = 0, size - 1
        while not left == right:
            mid = ceil((left + right) / 2)
            if array[mid] > target:
                right = mid - 1
            else:
                left = mid

        if array[left] == target:
            return left
        return -1
  #+END_SRC
  
  当序列中存在重复元素时，寻找最左匹配元素：
  #+BEGIN_SRC python
    def binary_search_leftmost(array, size, target):
        left, right = 0, size
        while left < right:
            mid = floor((left + right) / 2)
            if array[mid] < target:
                left = mid + 1
            else:
                right = mid
        return left
  #+END_SRC

  当序列中存在重复元素时，寻找最右匹配元素：
  #+BEGIN_SRC python
    def binary_search_leftmost(array, size, target):
        left, right = 0, size
        while left < right:
            mid = floor((left + right) / 2)
            if array[mid] <= target:
                left = mid + 1
            else:
                right = mid
        return left - 1
  #+END_SRC

  + [[https://en.wikipedia.org/wiki/Binary_search_algorithm][Binary search algorithm - Wikipedia]]
  
