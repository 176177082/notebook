* 大数的实现
  实现大数的两种基本思路：
  + 将大数用 10 进制字符数组进行表示，然后模拟进行竖式计算的过程编写其加减乘除函数
  + 将大数当作一个二进制流进行处理，使用各种移位和逻辑操作来进行加减乘除运算

  可以参考的实现：
  + [[http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/java/math/BigInteger.java][jdk8/jdk8/jdk: 687fd7c7986d src/share/classes/java/math/BigInteger.java]]
    
  可参考的思路：
  + [[https://www.pediy.com/kssd/pediy05/pediy50664.htm][RSA 与大数运算]]

* 斐波那契堆
  + [[https://www.cnblogs.com/skywang12345/p/3659060.html][斐波那契堆(一)之 图文解析 和 C语言的实现 - 如果天空不死 - 博客园]]
  + [[https://github.com/danielborowski/fibonacci-heap-python/blob/master/fib-heap.py][fibonacci-heap-python/fib-heap.py at master · danielborowski/fibonacci-heap-python]]

* 拼写检查
  + [[https://en.wikipedia.org/wiki/BK-tree][BK-tree - Wikipedia]]

* 二叉树高度获取
  #+BEGIN_SRC java
    public int getHeight(TreeNode root) {
      if (root == null)
        return 0;
      return 1 + Math.max(getHeight(root.left), getHeight(root.right));
    }
  #+END_SRC

* 二分查找
  基础实现：
  #+BEGIN_SRC python
    def binary_search(array, size, target):
        left, right = 0, size - 1
        while left <= right:
            mid = floor((left + right) / 2)
            if array[mid] > target:
                right = mid - 1
            elif array[mid] < target:
                left = mid + 1
            else:
                return mid
        return -1
  #+END_SRC

  基础实现的变种，可以减少每次比较的次数，但是需要多进行一次迭代：
  #+BEGIN_SRC python
    def binary_search(array, size, target):
        left, right = 0, size - 1
        while not left == right:
            mid = ceil((left + right) / 2)
            if array[mid] > target:
                right = mid - 1
            else:
                left = mid

        if array[left] == target:
            return left
        return -1
  #+END_SRC
  
  当序列中存在重复元素时，寻找最左匹配元素：
  #+BEGIN_SRC python
    def binary_search_leftmost(array, size, target):
        left, right = 0, size
        while left < right:
            mid = floor((left + right) / 2)
            if array[mid] < target:
                left = mid + 1
            else:
                right = mid
        return left
  #+END_SRC

  当序列中存在重复元素时，寻找最右匹配元素：
  #+BEGIN_SRC python
    def binary_search_leftmost(array, size, target):
        left, right = 0, size
        while left < right:
            mid = floor((left + right) / 2)
            if array[mid] <= target:
                left = mid + 1
            else:
                right = mid
        return left - 1
  #+END_SRC

  + [[https://en.wikipedia.org/wiki/Binary_search_algorithm][Binary search algorithm - Wikipedia]]
  
* 随机算法
  + 生成 10 个随机数 [0,100] 且最终 10 个随机数之和为 100：
  
    解决方案：在一根 1 到 100 的数轴上，随机取 9 个点，拿到 10 个线段。计算每个线段的长度，即是取值。

    代码实现：
    #+BEGIN_SRC python :results output
      import random

      nums = [random.randint(0, 101) for i in range(9)]
      nums.extend([0, 100])
      nums.sort()

      result = []
      for i in range(1, 11):
          result.append(nums[i] - nums[i - 1])

      print(result, sum(result))
    #+END_SRC

    #+RESULTS:
    : [6, 7, 2, 2, 38, 22, 2, 2, 17, 2] 100

    概率统计：
    #+BEGIN_SRC python
      from collections import defaultdict

      import random


      def random_nums():
          nums = [random.randint(0, 101) for i in range(9)]
          nums.extend([0, 100])
          nums.sort()

          result = []
          for i in range(1, 11):
              result.append(nums[i] - nums[i - 1])

          return result

      counter = defaultdict(int)

      for i in range(1000):
          for num in random_nums():
              counter[num] += 1

      total = sum(counter.keys())
      for i in range(101):
          print('%d: %f' % (i, counter[i] / total))
    #+END_SRC

    1. [0, 100] 内每个数字的出现概率的话，只有靠前的数字容易出现
    2. 统计 [0, 9] 的出现概率的话，差不多
 
  + 微信红包算法：[[https://www.zhihu.com/question/22625187][微信红包的随机算法是怎样实现的？ - 知乎]]

  + 可参考实现：[[http://blog.sciencenet.cn/blog-797552-1089280.html][科学网—分红包的Python算法 - 康建的博文]]
    
    这种方法需要预先分配，对比知乎那个，生产环境中要麻烦一些

