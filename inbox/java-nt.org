* 基本概念
  多线程可能带来的问题：
  1. 安全性问题，多线程环境下由于对资源的共享可能会导致一些安全性问题
  2. 活跃性问题，常见的便是为了解决安全性问题而导致的死锁，另外还有饥饿和活锁
  3. 性能问题，多线程并不一定总是能够带来更好的性能，毕竟线程的切换同样会带来性能消耗

  线程安全性：当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的。

  竞态条件：当多个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。常见的竞态条件为 *先检查后执行* 操作。

  互斥锁：最多只有一个线程能持有这种锁。

  可重入锁：如果某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功。

* 线程安全性
  由于线程是拥有自己的栈空间的，因此，只包含局部变量的方法调用是线程安全的，因此，线程安全的主要关注点在对状态访问的控制上。

  多线程环境下的状态访问往往需要保证原子性，即对单个状态（读去-修改-写入）或一组状态（竞态条件）的原子性访问。为了保证对状态的原子性访问，
  往往需要引入某种 *同步机制* 来实现，比如加锁。

  Java 中可以通过 ~synchronized~ 关键字使用 *内置锁* 来支持原子性，其中，对于静态方法来说会使用对应的 Class 对象作为锁。这就带来了一个问题：
  + 既然类锁只是锁了 Class 对象，那么不需要 Class 对象的方法会不会受影响呢，还是说，所有方法都需要 Class 对象
  
  注：Java 内置锁是可重入锁
