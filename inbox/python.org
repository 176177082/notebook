* Wait
  + 混合编程
    + [[https://www.ibm.com/developerworks/cn/linux/l-cn-pythonandc/][Python 调用 C]]
    + [[http://blog.csdn.net/forever_jc/article/details/7743106][C调用Python]]
    + [[http://blog.csdn.net/feitianxuxue/article/details/41129677][C调用Python]]
  + 数据库
    + [[http://python.jobbole.com/88954/][伯乐在线]]
  + 3.x 特性
    + [[https://mozillazg.com/2016/01/python-function-argument-type-check-base-on-function-annotations.html][函数注解]]
    + [[https://cito.github.io/blog/f-strings/][f-strings]]
    + [[https://www.oschina.net/translate/playing-around-with-await-async-in-python-3-5][await/async]]



* http.server.BaseHTTPRequestHandler.responses
  #+BEGIN_SRC python
    responses = {
        v: (v.phrase, v.description)
        for v in HTTPStatus.__members__.values()
    }
  #+END_SRC

* unittest
  + https://docs.python.org/2/library/unittest.html

* gzip
  + http://blog.knownsec.com/2012/04/about-content-encoding-gzip
    

 
   
* 垃圾回收机制
  + http://python.jobbole.com/82061/

* 模块导入原理
  + https://blog.csdn.net/u012422440/article/details/41791433

* with 和 as 语句
  + with 后不一定必须要 as, 只不过没有 as 无法捕获上下文对象
  + as 可以在 import, except, with 语句后使用

* 线程
  + [[https://blog.csdn.net/u012063703/article/details/51601579][守护线程]]
  + [[http://yoyzhou.github.io/blog/2013/02/28/python-threads-synchronization-locks/][Python线程同步机制]]

  #+BEGIN_SRC python
    >>> help(threading.Lock().acquire)
    Help on built-in function acquire:

    acquire(...)
        acquire([wait]) -> bool
        (acquire_lock() is an obsolete synonym)

        Lock the lock.  Without argument, this blocks if the lock is already
        locked (even by the same thread), waiting for another thread to release
        the lock, and return True once the lock is acquired.
        With an argument, this will only block if the argument is true,
        and the return value reflects whether the lock is acquired.
        The blocking operation is not interruptible.
  #+END_SRC

  + [[https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001386832845200f6513494f0c64bd882f25818a0281e80000][threadlocal]]

* 装饰器
  + 不带参数的装饰器等价于 ~decorate(func)~
  + 带参数的装饰器等价于 ~decorate(args)(func)~

  不带参数的装饰器调用时， 会自动传入 ~func~ 作为装饰器函数的第一个参数。

  带参数的装饰器调用时， 首先传入给定的参数， 然后在传入 ~func~ 给返回的 *可调用对象*

* 数值类型和引用类型
  + cls.py
    #+BEGIN_SRC python
      # -*- coding: utf-8 -*-

      class Test(object):
          _insance = set()

          def __init__(self):
              Test._insance.add(self)
    #+END_SRC
  + a.py
    #+BEGIN_SRC python
      # -*- coding: utf-8 -*-

      from cls import Test

      print('In a module Test id', id(Test))

      a = Test()
    #+END_SRC
  + b.py
    #+BEGIN_SRC python
      # -*- coding: utf-8 -*-

      from a import a
      from cls import Test

      print('In b module a id', id(a))

      print('In b module Test id', id(Test))

      b = Test()
    #+END_SRC
  + test.py
    #+BEGIN_SRC python
      # -*- coding: utf-8 -*-

      from a import a
      from b import b
      from cls import Test

      print('In test module a id', id(a))

      print('In test module Test id', id(Test))

      print(Test._insance)
    #+END_SRC
    
  执行结果：
  #+BEGIN_SRC python
    In a module Test id 38100248
    In b module a id 38104080
    In b module Test id 38100248
    In test module a id 38104080
    {<cls.Test object at 0x02456C10>, <cls.Test object at 0x0247BCD0>}
  #+END_SRC

  *结论:* Python 中， ~class~ 是 ~type~ 的实例， 这个实例全局只会存在一个。
  在不同的模块中引用这个类时， 引用的是同一个 *类对象*.
  
  *扩*: 定义在一个模块中的 *对象*, 在其他不同的模块调用这个对象的时候， 调用的都是 *同一个对象*.
  
  *扩*: 如果这个对象是 *数值类型* 的话， 不同模块间的对象并不是同一个对象。 *引用类型* 才是同一个对象。
  
  *补*: 如果是通过 ~import module~, 然后使用 ~module.xxx~ 调用对象的话， 不同模块之间调用的是同一对象。

  如果是直接 ~import~ 一个 *数值对象* 的话， 是获取了那个对象的值，并绑定到本模块。

  如果是直接 ~import~ 一个 *引用对象* 的话， 只是在本模块对那个对象进行了引用， 本模块的修改会反应到元模块上。

  + [[http://www.runoob.com/w3cnote/python-understanding-dict-copy-shallow-or-deep.html][Python 直接赋值、浅拷贝和深度拷贝解析]]
  
* 闭包
  + https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431835236741e42daf5af6514f1a8917b8aaadff31bf000

* ast
  + ast 的源码可以了解一下

* abstractmethod
  + 抽象类了解一下
* 函数参数
  + https://www.v2ex.com/t/453924

* pip
  + https://packaging.python.org/tutorials/installing-packages/

* function attribute
  + https://stackoverflow.com/questions/338101/python-function-attributes-uses-and-abuses
  + https://www.python.org/dev/peps/pep-0232/
* PEP 8
  + https://www.python.org/dev/peps/pep-0008/

* __dict__
  + https://blog.csdn.net/lis_12/article/details/53521554

* 设计模式
  + http://python-web-guide.readthedocs.io/zh/latest/design/design.html
