#+TITLE:      Java 笔记

* 目录                                                    :TOC_4_gh:noexport:
- [[#版本][版本]]
- [[#jdk--jre--jvm][JDK & JRE & JVM]]
- [[#常用构建工具][常用构建工具]]
- [[#程序结构与文件名][程序结构与文件名]]
- [[#布尔判断][布尔判断]]
- [[#数据类型][数据类型]]
  - [[#字符与字符串][字符与字符串]]
  - [[#引用和对象][引用和对象]]
- [[#数组][数组]]
- [[#名称][名称]]
- [[#标识符和关键字][标识符和关键字]]
- [[#继承和多态][继承和多态]]
- [[#重载][重载]]
- [[#语法相关][语法相关]]
- [[#多态相关][多态相关]]
- [[#抽象类与抽象方法][抽象类与抽象方法]]
- [[#object][Object]]
- [[#类型转换][类型转换]]
- [[#接口][接口]]
- [[#栈与堆][栈与堆]]
- [[#创建对象][创建对象]]
- [[#生命周期][生命周期]]
- [[#static--final][static & final]]
- [[#autoboxing][autoboxing]]
- [[#唯一重载过的操作符][唯一重载过的操作符]]
- [[#格式化字符串][格式化字符串]]
- [[#日期和时间][日期和时间]]
- [[#static-import][static import]]
- [[#异常相关][异常相关]]

* 版本
  + Java: 1.02 - 1.1
  + Java2: 1.2, 1.3, 1.4
  + Java5.0: 1.5+

* JDK & JRE & JVM
  Java SE - Java Platform, Standard Edition. Including JRE and JDK.

  + JVM(Java Virtual Machine), Java 虚拟机的缩写.
  + JRE(Java Runtime Environment), Java 运行环境的缩写. 运行 JAVA 程序所必须的环境的集合，
    包括 Java 虚拟机和 Java 程序所需的核心类库等， 如果想要运行一个开发好的 Java 程序，计算机中只需要安装 JRE 即可。
  + JDK(Java Development Kit), Java 开发工具包的缩写. JDK是提供给 Java 开发人员使用的，其中包含了 java 的开发工具，
    也包括了 JRE。所以安装了 JDK，就不用在单独安装 JRE 了。其中的开发工具： 编译工具(javac.exe)  打包工具(jar.exe)等。
  
  参考： [[https://blog.csdn.net/z15732621736/article/details/50603819][JDK、JRE、JVM 简介]]

* 常用构建工具
  + Ant, Maven, gradle

* 程序结构与文件名
  程序结构：
  + 一个程序最少有一个类
  + 只有一个 main() 函数
  + 所有东西都需要包含在 class, interface, enum 中

  文件名：
  + Java 保存的文件名必须与类名一致
  + 如果文件中只有一个类，文件名必须与类名一致
  + 一个 Java 文件中只能有一个 public 类
  + 如果文件中不止一个类，文件名必须与 public 类名一致
  + 如果文件中不止一个类，而且没有 public 类，文件名可与任一类名一致

  参考： [[https://blog.csdn.net/shaoxiaoning/article/details/40424087][Java的类名与文件名必须一致]]

* 布尔判断
  Java 中 integer 和 boolean 是两种类型， 因此不能像这样：
  #+BEGIN_SRC java
      int x = 1;

      while (x) {}
  #+END_SRC

  使用 ~==~ 判断两个引用是否为同一个对象。

  使用 ~equals~ 判断两个对象的值是否相同。  

* 数据类型
  下表为： primitive 主数据类型
  |---------+-----------------+--------------------------|
  | 类型    |            位数 | 值域                     |
  |---------+-----------------+--------------------------|
  | boolean | Java 虚拟机决定 | true or false            |
  | char    |              16 | 0 ~ 65535                |
  | byte    |               8 | -128 ~ 127               |
  | short   |              16 | -32768 ~ 32767           |
  | int     |              32 | -2147483648 ~ 2147483647 |
  | long    |              64 | -很大 ~ +很大            |
  | float   |              32 | 范围规模可变             |
  | double  |              64 | 范围规模可变             |
  |---------+-----------------+--------------------------|

  + 没有无符号数
   
  + 定义 ~float~ 的数值需要加 ~f~ 后缀， 如： ~float f = 32.45f~, 否则小数会
    默认当做 ~double~ 处理

  + 和 ~C~ 不同， 类似下面的行为在 ~Java~ 中不被允许， 编译器会报错：
    #+BEGIN_SRC java
    int x = 24;
    byte b = x;
    #+END_SRC
    
    隐式类型转换只允许在不会有数据丢失的情况下进行， 即: ~int~ 不能和
    ~float~ 直接转换。
   
    也不能使用类似 ~byte x = 128~ 的语句
   
  + 除此之外的类型的变量都是对一个对象的 *引用*, *对象* 实例保存在可回收垃圾的堆上

  + 所有引用变量的大小都一样， 不一样的是内存中的实例大小

  + 引用变量的空值为 ~null~
   
  + 和 ~Python~ 一样， 当一个实例对象的引用数为 0 时， 这个对象就可以被回收。

  + 实例对象通常通过 ~new~ 创建， 这会在内存中创建唯一的对象实例

  + 数组也是对象， 数组名是引用类型变量
   
  + 注意引用类型数组的初始化：
    #+BEGIN_SRC java
    Dog[] dog;  // 声明数组 dog
    dog = new Dog[7];  // 为 dog 分配内存

    for (int i = 0; i < 7; ++i) {
      dog[i] = new Dog();  // 为数组元素分配内存
    }
    #+END_SRC
   
  + String 不是 Java 关键字
   
  + 没有初始化的数值类型（包括 char） 默认为 0, 布尔类型默认为 false, 引用默认为 null.
   
  + 局部变量没有默认值， 使用前必须初始化

  + 可以使用 == 来判断两个主数据类型是否相对， 会判断两个引用是否引用同一个对象
 
** 字符与字符串
   Java 中 字符串可以直接与 *整数* 和 *字符* 拼接。

   另外， 原始数据类型的变量没有方法， 需要通过对应的 *对象类型* 来调用方法， 如：
   + ~int~ 对应 ~Integer~
   + ~char~ 对应 ~Character~

** 引用和对象
   + 类型 引用变量名 = new 类型();

   左值为引用类型变量， 固定大小， 右值为 *对象*.

* 数组
  数组的声明和初始化方式：
  #+BEGIN_SRC java
    // 声明数组
    dataType[] arrayRefVar;   // 首选的方法

    dataType arrayRefVar[];  // 效果相同，但不是首选方法

    // 创建数组
    dataType[] arrayRefVar = new dataType[arraySize];

    dataType[] arrayRefVar = {value0, value1, ..., valuek};  // 只能在声明的同时使用

    dataType[] arrayRefVar = new dataType[arraySize]{value0, value1, ..., valuek};
  #+END_SRC

* 名称
  使用外部类的两种方式：
  + import 导入命名空间， 然后直接使用类名
  + 全名 - 包名.类名

  *NOTE:* java.lang 会自动导入， 因此可以直接使用类名

  *PS:* javax 开头的函数库曾经是扩展， 后来虽然并入标准库， 但是为了兼容程序没有修改名称。
  
* 标识符和关键字
  和 ~C~ 与 ~Python~ 不同， ~Java~ 的标识符包含 ~$~, 即可以用 ~$~ 开头。

  ~C~ 和 ~Python~ 只能是字母或下划线。

  这一点和 ~JavaScript~ 是相同的。

  关键字表格：
  |-----------+----------+------------+--------+------------+-----------+--------------+-----------+----------+---------|
  | boolean   | byte     | char       | double | float      | int       | long         | short     | public   | private |
  | protected | abstract | final      | native | static     | strictfp  | synchronized | transient | volatile | if      |
  | else      | do       | while      | switch | case       | default   | for          | break     | continue | assert  |
  | class     | extends  | implements | import | instanceof | interface | new          | package   | super    | this    |
  | catch     | finally  | try        | throw  | throws     | return    | void         | const     | goto     | enum    |
  |-----------+----------+------------+--------+------------+-----------+--------------+-----------+----------+---------|

* 继承和多态
  子类会自动继承父类的 *实例变量* 与 *方法*, 可以在子类中覆盖父类的方法， 但不能覆盖 *实例变量*,
  因为不需要， 实例变量并没有什么特殊的行为。

  方法调用会调用与该对象最接近的方法， 即在继承层次最下方。

  执行时 java 虚拟机不关心方法来自那个类。

  父类不能调用子类的方法。

  使用关键字 ~super~ 调用父类的方法。

  覆盖父类方法： 重写那个方法即可。 ~@Override~ 的作用： [[https://blog.csdn.net/zht666/article/details/7869383][Java中@Override的作用]]

  继承使用关键字 ~extends~: ~class son extends father~.

  继承会继承 ~public~ 类型的方法和实例变量， 但不会继承 ~private~ 的。

  *引用类型可以是实际对象类型的父类*. 定义变量， 函数传参， 返回值时都可以如此。 即： *多态*.

  除了 *内部类* 以外， 没有 *私有类* 的说法。

  防止类被继承：
  1. 非公有类只能被同一个包的类继承
  2. 使用 final 修饰符修饰的类无法被继承
  3. 让类拥有 private 的构造函数

  使用 final 修饰的方法不会被覆盖。

  同时， 类的 private 方法会隐式地被指定为 final 方法。
  
  覆盖的基本原则：
  1. 参数和返回值类型必须要一样
  2. 不能降低方法的存取权限， 只能保持一样或更加开放

  否则就是重载了。

* 重载
  重载的意义是两个方法的 *名称相同*, 但参数不同， 因此 *重载与多态毫无关系*.

  重载的基本原则：
  1. 返回类型可以不同
  2. 不能只改变返回类型
  3. 可以更改存取权限

  *NOTE:* 重载和覆盖不一样

  重载需要改变参数的类型或顺序， 而不是参数的名字。

  编译器只关注类型与顺序， 而不是参数的名字。

* 语法相关
  声明抽象方法必须省略方法主体：
  #+BEGIN_SRC java
    public abstract void method();
  #+END_SRC

  声明类和其他方法不能省略主体， 即使主体为空：
  #+BEGIN_SRC java
    public abstract class AbstractClass {
      public void method() {}
    }
  #+END_SRC

* 多态相关
  1. 使用父类类型的引用指向子类的对象
  2. 该引用只能调用父类中定义的方法和变量

  编译器根据 *引用类型* 来判断有哪些 ~method~ 可以调用， 而不是 ~Object~ 确实的类型。

* 抽象类与抽象方法
  1. 抽象类与抽象方法使用关键字 abstract 修饰
  2. 抽象类不能被实例化
  3. 抽象方法在具体类中必须被实现， 但可以在抽象类中传递
  4. 抽象方法只能在抽象类中定义
     
  *AbstractClass.java*:
  #+BEGIN_SRC java
    public abstract class AbstractClass {
      public abstract void method();
    }
  #+END_SRC

  *AbstractSubClass.java*:
  #+BEGIN_SRC java
    public abstract class AbstractSubClass extends AbstractClass {}
  #+END_SRC

  *NotAbstractClass.java*:
  #+BEGIN_SRC java
    public class NotAbstractClass extends AbstractSubClass{
      public void method() {}
    }
  #+END_SRC

* Object
  ~Object~ 是所有类的基类， 没有继承其他类的类会隐式继承这个类。

  ~Object~ 的方法：
  + equals(Object o) :: 判断两个对象的值是否相等
  + getClass() :: 获取对象的类型
  + hashCode() :: 列出对象的哈希代码， 这是对象的唯一 id
  + toString() :: 列出类的名字和一个我们不关心的数字

  方法 ~getClass~ 是被 ~final~ 修饰的， 不能被覆盖。

  ~Object~ 不是抽象类， 因此可以实例化。

* 类型转换
  由与所有的非 ~Object~ 对象都继承了 ~Object~, 因此这些对象在 *堆* 上的实例上， 内部
  也包括了一个 ~Object~ 实例。

  即： 后代的实例内部包含父类的实例。

  因此父类类型的引用相当于只能操作子类实例内部的父类实例。

  通过强制类型转换可以将父类引用转换为子类引用， 转换前可以使用关键字 ~instanceof~ 来判断该对象是否是对应类型的实例。

  #+BEGIN_SRC java
    if (obj instanceof Dog) {
      Dog d = (Dog)obj;
    }
  #+END_SRC

  如果类型转换失败会抛出 ~ClassCastException~ 异常。

* 接口
  1. Java 不允许多重继承
  2. 替代方案是使用接口 ~Interface~

  接口的特点：
  1. 接口不能被实例化， 但是可以被实现
  2. 接口没有构造方法
  3. 接口中所有的方法默认(必须)为 ~public abstract~
  4. 允许一个类同时实现多个接口， 因为所有的接口方法都是抽象的

  #+BEGIN_SRC java
    interface Actor {
      void methodA();
      void methodB();
    }
  #+END_SRC

  接口的继承使用关键字： ~implements~.

  #+BEGIN_SRC java
    public class Dog implements ...
  #+END_SRC

  如果继承接口的类是抽象类， 那么可以不实现接口的方法， 留待子类实现。
  
  需要某些类的特殊化版本时继承它们。

  需要某些类扮演一个角色时， 定义一个接口

* 栈与堆
  + 栈空间中保存： 方法调用与局部变量

  + 堆空间中保存： 对象与实例变量

  + 实例变量是被声明在类而不是方法里面的变量

  + 实例变量可以在声明时赋初值， 否则会被设置为默认值（局部变量没有默认值）

  + 实例变量的默认值为： 0/0.0/false/null

* 创建对象
  创建对象的过程： 声明引用变量、 创建对象、 连接对象与引用

  创建对象是会调用对象的 *构造函数*.

  默认构造函数为(编译器创建)：
  #+BEGIN_SRC java
    public className {
 
    }
  #+END_SRC

  *注*: 构造函数没有返回值， 且与类名同名。 如果存在与类名相同但是存在返回值类型的方法， 那么不是构造函数。

  构造函数不会被继承 ！

  定义构造函数时， 可以的话就编写一个 *没有参数* 的构造函数

  如果自己定义了构造函数， 那么编译器不会在创建默认的无参的构造函数。

  如果不存在无参的构造函数， 那么 new 操作时就必须有参数。

  构造函数可以为公有， 私有或不指定的。

  如果构造函数是私有的， 那么这个类不能创建实例

  在创建新对象时， 所有继承下来的构造函数都会执行。

  抽象类也有构造函数， 会在创建子类实例时执行。

  先执行父类的构造函数， 在执行自身的构造函数。

  在构造函数中使用 ~super()~ 调用父类构造函数（唯一方法）。

  如果没有手动调用 ~super()~, 编译器会默认进行调用（包括每一个构造函数）：
  #+BEGIN_SRC java
    // 默认构造函数
    public ClassName() {
      super();
    }


    // 自定义构造函数
    public ClassName() {
      super();
      // your code
    }
  #+END_SRC

  默认调用的是父类的无参构造函数。

  ~super()~ 的调用必须是在构造函数的 *第一个语句*.

  如果不能向父类的带参构造函数传参， 那么就不能继承没有无参构造函数的类。

  传参：
  #+BEGIN_SRC java
    super(args...)
  #+END_SRC

  使用 ~this()~ 来从某个构造函数调用同一个类的另外一个构造函数。

  ~this()~ 只能用在 *构造函数*, 且必须是 *第一个语句*.

  ~super()~ 和 ~this()~ 不能兼得。

  #+BEGIN_SRC java
    public ClassName() {
      this(num);
    }
  #+END_SRC

* 生命周期
  + 局部变量存活在声明该变量的方法中
  + 实例变量与对象的生命周期相同
  + Life 与 Scope 的区别： P259, 很形象
  + 对象的声明周期受引用计数的影响， 当引用计数为 0 时该对象就可以被回收
  + 释放对象引用的三种方式：
    1. 引用变量永久性离开它的返回（死了）
    2. 引用被赋值到其他对象身上（NTR）
    3. 直接将引用设定为 null (byebye)
  
* static & final
  可以使用 ~static~ 修饰 实例变量 和 方法， 修饰的实例变量作为静态变量， 所有实例共享。
  修饰的方法为静态方法。

  不能使用 ~static~ 修饰类和局部变量。

  静态方法不能访问非静态成员， 包括实例变量与非静态方法。

  静态成员可以使用实例的引用来访问， 但是不推荐使用这种方式。

  静态变量的初始化是指类被加载时完成的， 会在任何类的对象创建之前完成初始化。也会在任何类的
  静态方法执行之前完成初始化。

  如果没有为静态变量赋初值， 那么静态变量会被设定为对应类型的默认值。

  ~static final~ 修饰的变量作为 *常量*. 常量的初始化只能在 *声明时* 或 *静态初始化程序* 中：
  #+BEGIN_SRC java
    public class ClassName {
      public static final int num;

      // 静态初始化程序
      static {
        num = 10;
      }
    }
  #+END_SRC

  不能同时在声明与静态初始化程序中赋值。

  常量必须初始化， 否则会出错。

  静态初始化程序可以为静态变量赋值， 不能访问非静态成员。

  单独使用 ~final~ 修饰的变量是常量， 不能被改动。 可以在声明或构造函数中初始化。不能
  同时进行。

  ~final~ 修饰的方法不能被覆盖。

  ~final~ 修饰的类不能被继承。
  
* autoboxing
  ~primitive~ 主数据类型都有对应的 *包装类*.

  |----------------------+--------------|
  | primitive 主数据类型 | 对应的包装类 |
  |----------------------+--------------|
  | boolean              | Boolean      |
  | char                 | Character    |
  | byte                 | Byte         |
  | short                | Short        |
  | int                  | Integer      |
  | long                 | Long         |
  | float                | Float        |
  | double               | Double       |
  |----------------------+--------------|

  在 ~java 5.0~ 之后的 ~java~ 中， 添加了 ~autoboxing~ 的功能， 允许在一些
  地方自动的完成 primitive 主数据类型和包装的对象的转换。

  这也叫做装箱和拆箱：
  + 装箱 -> primitive 主数据类型转换为对应的包装对象
  + 拆箱 -> 将包装对象转换为对应的 primitive 主数据类型

  可以使用 autoboxing 的地方包括：
  1. 方法的参数
  2. 返回值
  3. boolean 表达式， 任何预期 boolean 值的地方都可以用求 boolean 的表达式代替
  4. 数值运算
  5. 赋值

  #+BEGIN_SRC java
    public class Autoboxing {
      public Integer auto(Integer num) {  // 参数可以为 int 或 Integer
        int n = num;  // int 和 Integer 间可以直接赋值
        num += n;  // int 和 Integer 间可以直接加减
        return n;  // 返回值类型可以为 int 或 Integer
      }
    }
  #+END_SRC

  通过包装类可以调用有用的静态方法。

* 唯一重载过的操作符
  Java 中唯一重载过的操作符是 加号 '+', 允许字符串和数字， 字符直接相加。

* 格式化字符串
  格式化说明的格式：
  #+BEGIN_EXAMPLE
    %[argument number][flags][width][.precision]type
  #+END_EXAMPLE

  使用方法： ~String.format~.

* 日期和时间
  日期格式化：
  #+BEGIN_SRC java
    // 完整日期和时间
    String.format("%tc", new Date());

    // 只有时间
    String.format("%tr", new Date());

    // 周， 月， 日 - %tA, %tB, %td
    String.format("%tA %<tB %<td", new Date());
  #+END_SRC

  取得当前日期和时间使用 ~Date~.

  其余功能可以使用 ~Calendar~.

* static import
  使用 static import 的作用是 *少打一些字*.

  如：
  #+BEGIN_SRC java
    import static java.lang.System.out;
    import static java.lang.Math.*;

    class WithStatic {
      public static void main(String[] args) {
        out.println("sqrt" + sqrt(2.0));
      }
    }
  #+END_SRC

  可以看到， 省略了前面的 *名称空间.类*, 直接使用导入的 *静态成员*.
* 异常相关
  + 捕获异常：
    #+BEGIN_SRC java
      try {
        // 可能会抛出异常的代码块
      } catch(Exception ex) {
        // 捕获异常后执行的代码块
      }
    #+END_SRC
  + 抛出异常：
    #+BEGIN_SRC java
      public int function() throws Exception {  // 声明可能抛出的异常
        throw new Exception();  // 抛出异常
      }
    #+END_SRC

  Java 中的所有异常是 ~Exception~ 类型的 *对象*.

  异常分为： 检查型异常和非检查型（运行时）异常。

  其中， 如果抛出的异常类型为 *检查型异常*, 那么就必需在方法声明时通过 ~throws~ 声明可能抛出的异常， 同时
  在调用该方法时， 使用 ~try/catch~ 或 ~ducking~ 处理异常。

  如果抛出的异常类型为 *非检查型异常*, 那么可以不声明或包含在 ~try/catch~ 代码块中。 当然， 做了也没影响。

  其中， 非检查型异常是 ~RuntimeException~ 类型或其子类类型的异常， 而检查型异常是除了 ~RuntimeException~ 以外
  的所有异常。

  其中， ~RuntimeException~ 也是 ~Exception~ 的子类， 不过比较特殊。

  使用 ~finally~ 代码块来存放无论如何都要执行的部分。 既是在 ~try/catch~ 代码块中存在 ~return~ 语句， ~finally~ 代码块也
  依然会执行 ！ 流程会跳到 ~finally~ 然后在回到 ~return~ 语句。

  通过如下方式声明多个异常：
  #+BEGIN_SRC java
    public int function() throws IOException, InterruptedException {
      // ...
    }
  #+END_SRC

  通过多个 ~catch~ 块捕获多个异常， 也可以通过多个异常的父类同时捕获多个异常（声明异常也一样， 通过异常父类同时声明多个异常）

  异常也是对象， 因此也支持多态， 所以应该：
  + 以异常的父型来声明会抛出的远程
  + 以所抛出的异常父型来捕获异常
  + 可以用 ~Exception~ 捕获所有异常， 但不代表应该这么做
  + 为每个需要单独处理的异常编写不同的 catch 块
  + 有多个 catch 块时， 要从小排到大（子类到父类）， 否则会无法通过编译

  如果不想处理异常， 那么只需要在方法声明时 *再次 throws* 可能的异常即可：
  #+BEGIN_SRC java
    public int functionA() throws Exception {
      // ...
    }

    public int functionB() throws Exception {  // 再次 throws
      functionA();
    }
  #+END_SRC

  如果连 ~main~ 函数也 duck 调异常， 那么当遇到异常时， Java 虚拟机会当场去世。

  因此， 对于 *检查型异常*, 有两种处理方式：
  1. 使用 ~try/catch~ 处理异常
  2. 使用 ~duck~ 逃避异常

  异常处理规则：
  1. catch 与 finally 不能没有 try
  2. try 与 catch 之间不能有程序
  3. try 一定要有 catch 或 finally
  4. 只带有 finally 的 try 必须声明异常 - duck
  
