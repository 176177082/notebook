#+SETUPFILE:  ./_style/style.setup
#+TITLE:      基础内容

* 信息
  信息就是 ~位~ + ~上下文~

  + ~8bit~ = ~1byte~

  + 文件分类：
    - *文本文件* -- 由字符构成的文件
    - *二进制文件* -- 文本文件以外的所有文件
  + 区分不同数据对象的唯一方法： 读取到这些数据对象时的上下文

* 硬件组成
** 总线
   传送定长的 *字节块*, 64位/32位

** I/O设备
   每个I/O设备都通过一个 *控制器* 或 *适配器* 与I/O总线相连

** 主存
   主存是一个临时存储设备

** 处理器
   * 解释或执行存储在主存中指令的引擎
   * 处理器的核心是一个大小为一个字的存储设备(寄存器), 称为 *程序计数器(PC)*
     在任何时刻, PC 都指向主存中的某条机器语言指令(即含有该条指令的地址)
   * 可能会执行的简单操作
     + *加载*: 从主存复制一个字节或者一个字到寄存器, 以覆盖寄存器原来的内容
     + *存储*: 从寄存器复制一个字节或一个字到主存的某个位置, 以覆盖这个位置上原来的内容
     + *操作*: 把两个寄存器的内容复制到ALU, ALU对这两个字做算术运算, 并将结果放到一个寄存器中, 以覆盖寄存器原来的内容
     + *跳转*: 从指令本身中抽取一个字, 并将这个字复制到程序计数器(PC)中, 以覆盖PC中原来的值

* 操作系统管理硬件
** 基本功能
   1. 防止硬件被失控的应用程序滥用
   2. 向应用程序提供简单一致的机制来控制复杂又通常大不相同的低级硬件设备

** 基本抽象概念
   + 进程 :: 对处理器、主存和I\O设备的抽象表示

           操作系统保持跟踪进程运行所需的所有状态信息. 这种状态, 也就是 *上下文* , 包括许多信息.

           比如: PC 和寄存器文件的当前值, 以及主存的内容

           当操作系统决定要把控制权从当前进程转移到某个新进程时, 就会进行 *上下文切换.*
           即: 保存当前进程的上下文, 恢复新进程的上下文, 然后将控制权传递带新进程
   + 虚拟内存 :: 对主存和磁盘I\O设备的抽象表示

             虚拟内存是一个抽象概念, 它为每个进程提供了一个假象, 即每个进程都在独占的使用主存.
             每个进程看到的内存都是一致的, 称为虚拟地址空间
   + 虚拟地址空间布局 :: 从最低地址开始, 逐步向上
                 - 程序代码和数据, 对所有的进程来说, 代码是从同一固定地址开始
                 - 堆, 代码和数据区在进程一开始运行时就被指定了大小, 堆可以在运行时动态的扩展和收缩
                 - 共享库, 大约在地址空间的中间部分
                 - 栈, 位于用户虚拟地址空间顶部的是用户栈, 编译器用它来实现函数调用
                 - 内核虚拟内存, 不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数.
                   必须调用内核来执行操作

   + 文件 :: 对I\O设备的抽象表示, 就是字节序列, 仅此而已
* 大小端问题
  + 计算机内存地址分配： *由小到大*

  1. 假设有整数 0x01234567
  2. 假设该整数为 4 字节
  3. 假设该整数的地址为 0x100

  则， 该整数占据的内存地址为： 0x100, 0x101, 0x102, 0x103;

  大端法:
  |-------+------|
  |  地址 |   值 |
  |-------+------|
  | 0x103 | 0x67 |
  | 0x102 | 0x45 |
  | 0x101 | 0x23 |
  | 0x100 | 0x01 |
  |-------+------|

  小端法：
  |-------+------|
  |  地址 |   值 |
  |-------+------|
  | 0x103 | 0x01 |
  | 0x102 | 0x23 |
  | 0x101 | 0x45 |
  | 0x100 | 0x67 |
  |-------+------|

  *PS:* 大多数 Intel 为 小端法

* 整数表示
  + 无符号数(非负数) :: 二进制 ~n~ 位， 表示的最大值为 ~2ⁿ - 1~
  + 有符号数 :: 最高位为 ~负权~.
            
    - 补码： ~[0001]~ = *-0·2³ + 0·2² + 0·2¹ + 1·2⁰*

      ~[1001]~ = *-1·2³ + 0·2² + 0·2¹ + 1·2⁰*

    - 反码， 原码： ~P47~
  + 补码转化为无符号数 :: ~n~ 位补码表示的整数 ~x~, 如果 ~x < 0~, 转化为无符号数等于： ~x + 2ⁿ~,
                 如果 ~x >= 0~, 转化为无符号数等于： ~x~.
  + 无符号数转化为补码 :: ~n~ 为无符号数 ~x~, ~n~ 为补码的最大整数为 ~TMax~, 如果 ~x > TMax~, 转化为补码为： ~x - 2ⁿ~.
                 反之， 为 ~x~.


      
