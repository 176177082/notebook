#+SETUPFILE:  ./_style/style.setup
#+TITLE:      基础内容

* 信息
  信息就是 ~位~ + ~上下文~

  + ~8bit~ = ~1byte~

  + 文件分类：
    - *文本文件* -- 由字符构成的文件
    - *二进制文件* -- 文本文件以外的所有文件
  + 区分不同数据对象的唯一方法： 读取到这些数据对象时的上下文

* 硬件组成
** 总线
   传送定长的 *字节块*, 64位/32位

** I/O设备
   每个I/O设备都通过一个 *控制器* 或 *适配器* 与I/O总线相连

** 主存
   主存是一个临时存储设备

** 处理器
   * 解释或执行存储在主存中指令的引擎
   * 处理器的核心是一个大小为一个字的存储设备(寄存器), 称为 *程序计数器(PC)*
     在任何时刻, PC 都指向主存中的某条机器语言指令(即含有该条指令的地址)
   * 可能会执行的简单操作
     + *加载*: 从主存复制一个字节或者一个字到寄存器, 以覆盖寄存器原来的内容
     + *存储*: 从寄存器复制一个字节或一个字到主存的某个位置, 以覆盖这个位置上原来的内容
     + *操作*: 把两个寄存器的内容复制到ALU, ALU对这两个字做算术运算, 并将结果放到一个寄存器中, 以覆盖寄存器原来的内容
     + *跳转*: 从指令本身中抽取一个字, 并将这个字复制到程序计数器(PC)中, 以覆盖PC中原来的值

* 操作系统管理硬件
** 基本功能
   1. 防止硬件被失控的应用程序滥用
   2. 向应用程序提供简单一致的机制来控制复杂又通常大不相同的低级硬件设备

** 基本抽象概念
   + 进程 :: 对处理器、主存和I\O设备的抽象表示

           操作系统保持跟踪进程运行所需的所有状态信息. 这种状态, 也就是 *上下文* , 包括许多信息.

           比如: PC 和寄存器文件的当前值, 以及主存的内容

           当操作系统决定要把控制权从当前进程转移到某个新进程时, 就会进行 *上下文切换.*
           即: 保存当前进程的上下文, 恢复新进程的上下文, 然后将控制权传递带新进程
   + 虚拟内存 :: 对主存和磁盘I\O设备的抽象表示

             虚拟内存是一个抽象概念, 它为每个进程提供了一个假象, 即每个进程都在独占的使用主存.
             每个进程看到的内存都是一致的, 称为虚拟地址空间
   + 虚拟地址空间布局 :: 从最低地址开始, 逐步向上
                 - 程序代码和数据, 对所有的进程来说, 代码是从同一固定地址开始
                 - 堆, 代码和数据区在进程一开始运行时就被指定了大小, 堆可以在运行时动态的扩展和收缩
                 - 共享库, 大约在地址空间的中间部分
                 - 栈, 位于用户虚拟地址空间顶部的是用户栈, 编译器用它来实现函数调用
                 - 内核虚拟内存, 不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数.
                   必须调用内核来执行操作

   + 文件 :: 对I\O设备的抽象表示, 就是字节序列, 仅此而已
* 大小端问题
  + 计算机内存地址分配： *由小到大*

  1. 假设有整数 0x01234567
  2. 假设该整数为 4 字节
  3. 假设该整数的地址为 0x100

  则， 该整数占据的内存地址为： 0x100, 0x101, 0x102, 0x103;

  大端法:
  |-------+------|
  |  地址 |   值 |
  |-------+------|
  | 0x103 | 0x67 |
  | 0x102 | 0x45 |
  | 0x101 | 0x23 |
  | 0x100 | 0x01 |
  |-------+------|

  小端法：
  |-------+------|
  |  地址 |   值 |
  |-------+------|
  | 0x103 | 0x01 |
  | 0x102 | 0x23 |
  | 0x101 | 0x45 |
  | 0x100 | 0x67 |
  |-------+------|

  *PS:* 大多数 Intel 为 小端法

* 整数表示
  |----------+------+------+------+------+------+------+------+------|
  | 十六进制 |    0 |    1 |    2 |    3 |    4 |    5 |    6 |    7 |
  | 十进制   |    0 |    1 |    2 |    3 |    4 |    5 |    6 |    7 |
  | 二进制   | 0000 | 0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111 |
  |----------+------+------+------+------+------+------+------+------|
  | 十六进制 |    8 |    9 |    A |    B |    C |    D |    E |    F |
  | 十进制   |    8 |    9 |   10 |   11 |   12 |   13 |   14 |   15 |
  | 二进制   | 1000 | 1001 | 1010 | 1011 | 1100 | 1101 | 1110 | 1111 |
  |----------+------+------+------+------+------+------+------+------|

  *PS:* 负数的范围比正数范围大 1.
  *PS:* 强制类型转换， 位值不变， 但改变解释这些位的方式.


  *规则：* ~n~ 代表二进制数的位数， ~w = n - 1~.

  + 二进制转无符号数 BSU :: ~UMax~ = ~2ⁿ - 1~

                    ~BSU([0000])~ ==> ~0·2³ + 0·2² + 0·2¹ + 0·2⁰~ ==> ~0~
                    
                    ~BSU([1111])~ ==> ~1·2³ + 1·2² + 1·2¹ + 1·2⁰~ ==> ~2⁴ - 1~ ==> ~15~

  + 二进制转补码 BST :: ~TMax~ = ~2ʷ - 1~, ~TMin = -2ʷ~, ~|TMin| = |TMax| + 1,~
                  ~UMax = 2Tmax + 1~

                    ~BST([0000])~ ==> ~-1·0·2³ + 0·2² + 0·2¹ + 0·2⁰~ ==> ~0~
                    
                    ~BST([1111])~ ==> ~-1·1·2³ + 1·2² + 1·2¹ + 1·2⁰~ ==> ~-1~
                    
                    *PS:* 补码的首位为 *负权*

                    反码： 最高位的权是 ~-(2ʷ - 1)~ 而不是 ~-2ʷ~, 其他和补码相同
                    
                    原码： 最高位确定符号， ~1~ 为负数， ~0~ 为正数， 无权
                    
  + 补码转无符号数 T2U :: 设补码数为 ~x~, 当 ~x < 0~ 时， ~T2U(x) = x + 2ⁿ~; 当 ~x >= 0~ 时，
                   ~T2U(x) = x~

  + 无符号数转补码 U2T :: 设无符号数为 ~x~, 当 ~x <= TMax~ 时， ~U2T(x) = x~; 当 ~x > TMax~ 时，
                   ~U2T(x) = x - 2ⁿ~

  + 无符号数的零扩展 :: 在表示的开头添 ~0~

  + 补码数的符号扩展 :: 在表示中添加最高有效位的值， 负数为 ~1~, 正数为 ~0~

  + 截断数字 :: 截断高位， 保留低位， 根据相应的编码解释剩下的位。 ~-1~ 的截断值总是 ~-1~.

  + 无符号数加法 :: 对于无符号数 ~0 <= x, y < 2ⁿ~, 如果 ~x + y < 2ⁿ~, 那么加法正常;
              如果 ~x + y >= 2ⁿ~, 那么加法 *溢出*, 结果为 ~x + y - 2ⁿ~. (~(x + y) mod 2ⁿ~)

              溢出检测： 令 ~s = x + y~, 当 ~s < x~ 或 ~s < y~ 时， 发生了溢出

  + 无符号数加法逆元 :: ~x = 0, -x = 0~, ~x > 0, -x = 2ⁿ - x~, ~x + -x = 0~.

  + 补码加法 :: 对于补码数 ~-2ⁿ <= x, y <= 2ⁿ - 1~:

            正溢出： ~x + y = x + y - 2ⁿ, 2ʷ <= x + y~

            正常： ~x + y = x + y, -2ʷ <= x + y < 2ʷ~

            负溢出： ~x + y = x + y + 2ⁿ, x + y < -2ʷ~
            
            溢出检测： 零 ~s = x + y~, 当 ~x > 0, y > 0, s < 0~ 或 ~x < 0, y < 0, s > 0~ 时溢出

  + 补码数加法逆元 :: ~x = TMin, -x = TMin~, ~x > TMin, -x = -x~, ~x + -x = 0~.

  + 无符号数乘法 :: ~x*y = (x·y) mod 2ⁿ~

  + 补码乘法 :: ~x*y = U2T((x·y) mod 2ⁿ)~, 结果截断为补码数

  + 乘以 2 的幂 :: ~x << k~

  + 除以 2 的幂 :: 结果向下取整 ~x >> k~, 结果向上取整 ~(x + (1 << k) - 1) >> k~ (P71)

