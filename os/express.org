#+TITLE:      程序的机器级表示

* 目录                                                    :TOC_4_gh:noexport:
- [[#条件码寄存器][条件码寄存器]]
- [[#att-与-intel-汇编代码格式][ATT 与 Intel 汇编代码格式]]
- [[#数据格式][数据格式]]
  - [[#寄存器][寄存器]]
  - [[#操作数指示符][操作数指示符]]
- [[#mov-指令][MOV 指令]]
- [[#pop-和-push-指令][POP 和 PUSH 指令]]
- [[#栈帧][栈帧]]

* 条件码寄存器
  + [[https://en.wikipedia.org/wiki/FLAGS_register][维基百科]]

* ATT 与 Intel 汇编代码格式
  对比 ~ATT~ 格式， ~Intel~ 汇编代码格式做出了这些修改：
  1. 省略了指示大小的后缀
  2. 省略了寄存器前面的 ~%~ 符号
  3. 用不同的方式来描述内存中的位置， 如 ~QWORD PTR [rbx]~ 而不是 ~(%rbx)~
  4. 带有多个操作数的时候， 操作数的顺序和 ~ATT~ 格式相反

* 数据格式
  |--------------------+--------------+------------|
  | Intel 数据类型     | 汇编代码后缀 | 大小(字节) |
  |--------------------+--------------+------------|
  | ~字节(byte)~         | ~b~            | ~1~          |
  | ~字(word)~           | ~w~            | ~2~          |
  | ~双字(double words)~ | ~l~            | ~4~          |
  | ~四字(quad words)~   | ~q~            | ~8~          |
  |--------------------+--------------+------------|

  *PS:* 双字后缀 ~l~ 可以按 长字 ~long word~ 来理解。

** 寄存器
   + 完整寄存器列表： *P120*
   + 两个规则：
     1. 生成 1 字节和 2 字节数字的指令会保持剩下的字节不变
     2. 生成 4 字节数字的指令会把高位 4 个字节置为 0
   + 栈指针寄存器 ~%rsp~

** 操作数指示符
   1. 立即数(immediate), 书写方式为 ~$~ 后面跟一个用标准 C 表示法表示的整数， 如 ~$123~, ~$-123~
   2. 寄存器(register), 书写方式为 ~%~ 跟一个寄存器名， 如 ~%rax~, ~%eax~
   3. 内存引用， 书写方式为 ~立即数(基址寄存器 A, 变址寄存器 B, 比例因子 S)~.
      其中 ~s~ 必须为 ~1, 2, 4, 8~ 中的一个。 寄存器必须为 ~64~ 位寄存器。

      有效地址的值为： ~立即数 + 基址寄存器的值 + 变址寄存器的值 * 比例因子~.

      各部分为可选参数， 即这些都是有效的内存引用： *0xFFFF*, *(%rax)*, *(%rax, %rbx)*, *(%rax, %rbx, 1)*...

* MOV 指令
  + /movb, movw, movl, movl, movabsq/.
  + *movabsq* 以任意 64 位立即数作为源操作数， 以寄存器作为目标操作数
  + *movl* 以寄存器作为目标时， 会把该寄存器的高位 4 字节置为 0

  注意事项：
  + 不能直接将一个值从内存 *MOV* 到内存， 正确的顺序为 *内存 --> 寄存器 --> 内存*
  + 如果操作数中存在寄存器， 那么操作数的后缀必须与指定的寄存器大小相匹配
  + 如果两个操作数都是寄存器， 那么两个寄存器的大小必须相同

  将较小的源值复制到较大的目的：
  + *MOVZ* 类指令把目标中剩余的字节填充为 0
  + *MOVS* 类指令通过 *符号扩展* 来填充， 把源操作数的最高位进行复制

  完整指令列表： P121

  指令举例： *movzbl*, 将 *字节 b* 传送到 *双字 l*

* POP 和 PUSH 指令
  + *pushq* 指令, 栈顶地址减 8, 存入操作数的值. 操作数可以是 *立即数*, *寄存器*, *内存*. *寄存器* 大小没有要求
  + *popq* 指令, 返回栈顶数据, 栈顶地址加 8. 操作数可以是 *寄存器*, *内存*. *寄存器* 大小没有要求
  + 弹入和弹出的数据大小都是 *四字(8 byte)*

  栈向下增长， 堆向上增长：
  #+BEGIN_SRC C
    #include <stdio.h>
    #include <stdlib.h>

    int main(int ragc, char* argv[]) {
      int a = 10;
      int b = 10;
      int* heap = (int*)malloc(10 * sizeof(int));

      printf("a: %p, b: %p\n", &a, &b);
      for (int i = 0; i < 10; ++i) {
        printf("heap[%d]: %p\n", i, &heap[i]);
      }

      return 0;
    }
  #+END_SRC

* 栈帧
  + [[http://www.cnblogs.com/xkfz007/archive/2012/03/27/2420158.html][C语言中函数参数入栈的顺序]]

