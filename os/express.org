#+TITLE:      程序的机器级表示

* 目录                                                    :TOC_4_gh:noexport:
- [[#att-与-intel-汇编代码格式][ATT 与 Intel 汇编代码格式]]
- [[#数据格式][数据格式]]
  - [[#寄存器][寄存器]]
  - [[#操作数指示符][操作数指示符]]
- [[#mov-指令][MOV 指令]]
- [[#pop-和-push-指令][POP 和 PUSH 指令]]
- [[#算数和逻辑操作][算数和逻辑操作]]
  - [[#加载有效地址][加载有效地址]]
  - [[#一元和二元操作][一元和二元操作]]
  - [[#移位操作][移位操作]]
- [[#控制][控制]]
  - [[#条件码][条件码]]
  - [[#cmp--test][CMP & TEST]]
  - [[#访问条件码][访问条件码]]
  - [[#跳转指令][跳转指令]]
  - [[#跳转表][跳转表]]
- [[#栈帧][栈帧]]

* ATT 与 Intel 汇编代码格式
  对比 ~ATT~ 格式， ~Intel~ 汇编代码格式做出了这些修改：
  1. 省略了指示大小的后缀
  2. 省略了寄存器前面的 ~%~ 符号
  3. 用不同的方式来描述内存中的位置， 如 ~QWORD PTR [rbx]~ 而不是 ~(%rbx)~
  4. 带有多个操作数的时候， 操作数的顺序和 ~ATT~ 格式相反
     
* 数据格式
  |--------------------+--------------+------------|
  | Intel 数据类型     | 汇编代码后缀 | 大小(字节) |
  |--------------------+--------------+------------|
  | ~字节(byte)~         | ~b~            | ~1~          |
  | ~字(word)~           | ~w~            | ~2~          |
  | ~双字(double words)~ | ~l~            | ~4~          |
  | ~四字(quad words)~   | ~q~            | ~8~          |
  |--------------------+--------------+------------|

  *PS:* 双字后缀 ~l~ 可以按 长字 ~long word~ 来理解。

** 寄存器
   + 完整寄存器列表： *P120*
   + 两个规则：
     1. 生成 1 字节和 2 字节数字的指令会保持剩下的字节不变
     2. 生成 4 字节数字的指令会把高位 4 个字节置为 0
   + 栈指针寄存器 ~%rsp~
   + 基址指针(帧指针)寄存器 ~%rbp~
   + PC ~%rip~

** 操作数指示符
   1. 立即数(immediate), 书写方式为 ~$~ 后面跟一个用标准 C 表示法表示的整数， 如 ~$123~, ~$-123~
   2. 寄存器(register), 书写方式为 ~%~ 跟一个寄存器名， 如 ~%rax~, ~%eax~
   3. 内存引用， 书写方式为 ~立即数(基址寄存器 A, 变址寄存器 B, 比例因子 S)~.
      其中 ~s~ 必须为 ~1, 2, 4, 8~ 中的一个。 寄存器必须为 ~64~ 位寄存器。

      有效地址的值为： ~立即数 + 基址寄存器的值 + 变址寄存器的值 * 比例因子~.

      各部分为可选参数， 即这些都是有效的内存引用： *0xFFFF*, *(%rax)*, *(%rax, %rbx)*, *(%rax, %rbx, 1)*...

* MOV 指令
  + /movb, movw, movl, movl, movabsq/.
  + *movabsq* 以任意 64 位立即数作为源操作数， 以寄存器作为目标操作数
  + *movl* 以寄存器作为目标时， 会把该寄存器的高位 4 字节置为 0

  注意事项：
  + 不能直接将一个值从内存 *MOV* 到内存， 正确的顺序为 *内存 --> 寄存器 --> 内存*
  + 如果操作数中存在寄存器， 那么操作数的后缀必须与指定的寄存器大小相匹配
  + 如果两个操作数都是寄存器， 那么两个寄存器的大小必须相同

  将较小的源值复制到较大的目的：
  + *MOVZ* 类指令把目标中剩余的字节填充为 0
  + *MOVS* 类指令通过 *符号扩展* 来填充， 把源操作数的最高位进行复制

  完整指令列表： P121

  指令举例： *movzbl*, 将 *字节 b* 传送到 *双字 l*

* POP 和 PUSH 指令
  + *pushq* 指令, 栈顶地址减 8, 存入操作数的值. 操作数可以是 *立即数*, *寄存器*, *内存*. *寄存器* 大小没有要求
  + *popq* 指令, 返回栈顶数据, 栈顶地址加 8. 操作数可以是 *寄存器*, *内存*. *寄存器* 大小没有要求
  + 弹入和弹出的数据大小都是 *四字(8 byte)*

  栈向下增长， 堆向上增长：
  #+BEGIN_SRC C
    #include <stdio.h>
    #include <stdlib.h>

    int main(int ragc, char* argv[]) {
      int a = 10;
      int b = 10;
      int* heap = (int*)malloc(10 * sizeof(int));

      printf("a: %p, b: %p\n", &a, &b);
      for (int i = 0; i < 10; ++i) {
        printf("heap[%d]: %p\n", i, &heap[i]);
      }

      return 0;
    }
  #+END_SRC

* 算数和逻辑操作
** 加载有效地址  
   加载有效地址 ~LEA~, 是 ~MOV~ 指令的变性， 计算出 *地址* 的值， 但不读取
   *地址* 的值， 而是直接将 *地址* 的值送人 *目标操作数*.

** 一元和二元操作
   一元操作， D 既是源又是目的：
   + INC D 加 1
   + DEC D 减 1
   + NEG D 取反加 1
   + NOT D 按位取反
   二元操作， D 既是源又是目的：
   + ADD S D 加 S
   + SUB S D 减 S
   + IMUL S D 乘 S
   + XOR S D 和 S 进行异或运算
   + OR S D 和 S 进行或运算
   + AND S D 和 S 进行与运算

** 移位操作
   对于移位操作， 算数左和逻辑左移的操作是一样的， 在右端补 0.

   而逻辑右移是在左端补 0, 算数右移是补 *符号位*.

   移位操作的目标操作数可以是寄存器或内存位置。
   
   + 指令 移位量, 目标操作数
   + SAL, SHL, 左移
   + SAR 算数右移
   + SHR 逻辑右移

* 控制
** 条件码
   + [[https://en.wikipedia.org/wiki/FLAGS_register][维基百科]]
   + CF: 进位标志， 无符号操作溢出时为 1
   + ZF: 零标志， 结果为 0 时 为 1
   + SF: 符号标志， 等于结果的最高位
   + OF: 溢出标志， 有符号数运算溢出时为 1

  不同操作对条件码的影响：
  + leaq 不改变条件码
  + 逻辑操作， 如 XOR 会将 CF 和 OF 置为 0
  + 对于移位操作， CF 会被设置为最后一个被移出的位， OF 设置为 0
  + INC 和 DEC 会设置 OF 和 ZF, 但不会改变标志位

** CMP & TEST
   + CMP 指令类似于指令 SUB, 只影响条件码， 不改变操作数的值
   + TEST 指令类似于指令 AND, 只影响条件码， 不改变操作数的值
   
** 访问条件码
   可以通过 SET 指令来访问

** 跳转指令
   + 直接跳转： 形如 ~jmp .L1~ 的形式， 跳转目标是作为指令的一部分编码的
   + 间接跳转： 形如 ~*%rax~ 的形式， 符号 ~*~ 后跟一个 *操作数指示符*. 根据
     *操作数指示符* 的值来确定跳转目标

   跳转指令： [[http://www.penguin.cz/~literakl/intel/j.html][JXX - Jump Instructions Table]]

** 跳转表
   对于 ~switch~ 语句， 当选项超过 4, 且选项之间的值 *很接近* 的时候， 编译器会
   生成一个 *跳转表*.

   需要注意的是， 跳转表的索引顺序是 ~0, 1, 2, 3...~ 而不是 ~1, 2, 3, ...~
   
* 栈帧
  + [[http://www.cnblogs.com/xkfz007/archive/2012/03/27/2420158.html][C语言中函数参数入栈的顺序]]

