#+SETUPFILE:  ./_style/style.setup
#+TITLE:      信息的表示和处理

* 大小端问题
  + 计算机内存地址分配： *由小到大*

  1. 假设有整数 0x01234567
  2. 假设该整数为 4 字节
  3. 假设该整数的地址为 0x100

  则， 该整数占据的内存地址为： 0x100, 0x101, 0x102, 0x103;

  大端法:
  |-------+------|
  |  地址 |   值 |
  |-------+------|
  | 0x103 | 0x67 |
  | 0x102 | 0x45 |
  | 0x101 | 0x23 |
  | 0x100 | 0x01 |
  |-------+------|

  小端法：
  |-------+------|
  |  地址 |   值 |
  |-------+------|
  | 0x103 | 0x01 |
  | 0x102 | 0x23 |
  | 0x101 | 0x45 |
  | 0x100 | 0x67 |
  |-------+------|

  *PS:* 大多数 Intel 为 小端法

* 整数表示
  |----------+------+------+------+------+------+------+------+------|
  | 十六进制 |    0 |    1 |    2 |    3 |    4 |    5 |    6 |    7 |
  | 十进制   |    0 |    1 |    2 |    3 |    4 |    5 |    6 |    7 |
  | 二进制   | 0000 | 0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111 |
  |----------+------+------+------+------+------+------+------+------|
  | 十六进制 |    8 |    9 |    A |    B |    C |    D |    E |    F |
  | 十进制   |    8 |    9 |   10 |   11 |   12 |   13 |   14 |   15 |
  | 二进制   | 1000 | 1001 | 1010 | 1011 | 1100 | 1101 | 1110 | 1111 |
  |----------+------+------+------+------+------+------+------+------|

  *PS:* 负数的范围比正数范围大 1.
  *PS:* 强制类型转换， 位值不变， 但改变解释这些位的方式.


  *规则：* ~n~ 代表二进制数的位数， ~w = n - 1~.

  + 二进制转无符号数 BSU :: ~UMax~ = ~2ⁿ - 1~

                    ~BSU([0000])~ ==> ~0·2³ + 0·2² + 0·2¹ + 0·2⁰~ ==> ~0~
                    
                    ~BSU([1111])~ ==> ~1·2³ + 1·2² + 1·2¹ + 1·2⁰~ ==> ~2⁴ - 1~ ==> ~15~

  + 二进制转补码 BST :: ~TMax~ = ~2ʷ - 1~, ~TMin = -2ʷ~, ~|TMin| = |TMax| + 1,~
                  ~UMax = 2Tmax + 1~

                    ~BST([0000])~ ==> ~-1·0·2³ + 0·2² + 0·2¹ + 0·2⁰~ ==> ~0~
                    
                    ~BST([1111])~ ==> ~-1·1·2³ + 1·2² + 1·2¹ + 1·2⁰~ ==> ~-1~
                    
                    *PS:* 补码的首位为 *负权*

                    反码： 最高位的权是 ~-(2ʷ - 1)~ 而不是 ~-2ʷ~, 其他和补码相同
                    
                    原码： 最高位确定符号， ~1~ 为负数， ~0~ 为正数， 无权
                    
  + 补码转无符号数 T2U :: 设补码数为 ~x~, 当 ~x < 0~ 时， ~T2U(x) = x + 2ⁿ~; 当 ~x >= 0~ 时，
                   ~T2U(x) = x~

  + 无符号数转补码 U2T :: 设无符号数为 ~x~, 当 ~x <= TMax~ 时， ~U2T(x) = x~; 当 ~x > TMax~ 时，
                   ~U2T(x) = x - 2ⁿ~

  + 无符号数的零扩展 :: 在表示的开头添 ~0~

  + 补码数的符号扩展 :: 在表示中添加最高有效位的值， 负数为 ~1~, 正数为 ~0~

  + 截断数字 :: 截断高位， 保留低位， 根据相应的编码解释剩下的位。 ~-1~ 的截断值总是 ~-1~.

* 整数运算
  + 无符号数加法 :: 对于无符号数 ~0 <= x, y < 2ⁿ~, 如果 ~x + y < 2ⁿ~, 那么加法正常;
              如果 ~x + y >= 2ⁿ~, 那么加法 *溢出*, 结果为 ~x + y - 2ⁿ~. (~(x + y) mod 2ⁿ~)

              溢出检测： 令 ~s = x + y~, 当 ~s < x~ 或 ~s < y~ 时， 发生了溢出

  + 无符号数加法逆元 :: ~x = 0, -x = 0~, ~x > 0, -x = 2ⁿ - x~, ~x + -x = 0~.

  + 补码加法 :: 对于补码数 ~-2ⁿ <= x, y <= 2ⁿ - 1~:

            正溢出： ~x + y = x + y - 2ⁿ, 2ʷ <= x + y~

            正常： ~x + y = x + y, -2ʷ <= x + y < 2ʷ~

            负溢出： ~x + y = x + y + 2ⁿ, x + y < -2ʷ~
            
            溢出检测： 零 ~s = x + y~, 当 ~x > 0, y > 0, s < 0~ 或 ~x < 0, y < 0, s > 0~ 时溢出

  + 补码数加法逆元 :: ~x = TMin, -x = TMin~, ~x > TMin, -x = -x~, ~x + -x = 0~.

  + 无符号数乘法 :: ~x*y = (x·y) mod 2ⁿ~

  + 补码乘法 :: ~x*y = U2T((x·y) mod 2ⁿ)~, 结果截断为补码数

  + 乘以 2 的幂 :: ~x << k~

  + 除以 2 的幂 :: 结果向下取整 ~x >> k~, 结果向上取整 ~(x + (1 << k) - 1) >> k~ (P71)

* 浮点数表示
  + [[https://zh.wikipedia.org/wiki/IEEE_754][IEEE 754 维基百科]]
