#+SETUPFILE:  ./_style/style.setup
#+TITLE:      信息的表示和处理

* 大小端问题
  + 计算机内存地址分配： *由小到大*

  1. 假设有整数 0x01234567
  2. 假设该整数为 4 字节
  3. 假设该整数的地址为 0x100

  则， 该整数占据的内存地址为： 0x100, 0x101, 0x102, 0x103;

  大端法:
  |-------+------|
  |  地址 |   值 |
  |-------+------|
  | 0x103 | 0x67 |
  | 0x102 | 0x45 |
  | 0x101 | 0x23 |
  | 0x100 | 0x01 |
  |-------+------|

  小端法：
  |-------+------|
  |  地址 |   值 |
  |-------+------|
  | 0x103 | 0x01 |
  | 0x102 | 0x23 |
  | 0x101 | 0x45 |
  | 0x100 | 0x67 |
  |-------+------|

  *PS:* 大多数 Intel 为 小端法

* 整数表示
  |----------+------+------+------+------+------+------+------+------|
  | 十六进制 |    0 |    1 |    2 |    3 |    4 |    5 |    6 |    7 |
  | 十进制   |    0 |    1 |    2 |    3 |    4 |    5 |    6 |    7 |
  | 二进制   | 0000 | 0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111 |
  |----------+------+------+------+------+------+------+------+------|
  | 十六进制 |    8 |    9 |    A |    B |    C |    D |    E |    F |
  | 十进制   |    8 |    9 |   10 |   11 |   12 |   13 |   14 |   15 |
  | 二进制   | 1000 | 1001 | 1010 | 1011 | 1100 | 1101 | 1110 | 1111 |
  |----------+------+------+------+------+------+------+------+------|

  *PS:* 负数的范围比正数范围大 1.
  *PS:* 强制类型转换， 位值不变， 但改变解释这些位的方式.


  *规则：* ~n~ 代表二进制数的位数， ~w = n - 1~.

  + 二进制转无符号数 BSU :: ~UMax~ = ~2ⁿ - 1~

                    ~BSU([0000])~ ==> ~0·2³ + 0·2² + 0·2¹ + 0·2⁰~ ==> ~0~
                    
                    ~BSU([1111])~ ==> ~1·2³ + 1·2² + 1·2¹ + 1·2⁰~ ==> ~2⁴ - 1~ ==> ~15~

  + 二进制转补码 BST :: ~TMax~ = ~2ʷ - 1~, ~TMin = -2ʷ~, ~|TMin| = |TMax| + 1,~
                  ~UMax = 2Tmax + 1~

                    ~BST([0000])~ ==> ~-1·0·2³ + 0·2² + 0·2¹ + 0·2⁰~ ==> ~0~
                    
                    ~BST([1111])~ ==> ~-1·1·2³ + 1·2² + 1·2¹ + 1·2⁰~ ==> ~-1~
                    
                    *PS:* 补码的首位为 *负权*

                    反码： 最高位的权是 ~-(2ʷ - 1)~ 而不是 ~-2ʷ~, 其他和补码相同
                    
                    原码： 最高位确定符号， ~1~ 为负数， ~0~ 为正数， 无权
                    
  + 补码转无符号数 T2U :: 设补码数为 ~x~, 当 ~x < 0~ 时， ~T2U(x) = x + 2ⁿ~; 当 ~x >= 0~ 时，
                   ~T2U(x) = x~

  + 无符号数转补码 U2T :: 设无符号数为 ~x~, 当 ~x <= TMax~ 时， ~U2T(x) = x~; 当 ~x > TMax~ 时，
                   ~U2T(x) = x - 2ⁿ~

  + 无符号数的零扩展 :: 在表示的开头添 ~0~

  + 补码数的符号扩展 :: 在表示中添加最高有效位的值， 负数为 ~1~, 正数为 ~0~

  + 截断数字 :: 截断高位， 保留低位， 根据相应的编码解释剩下的位。 ~-1~ 的截断值总是 ~-1~.

* 整数运算
  + 无符号数加法 :: 对于无符号数 ~0 <= x, y < 2ⁿ~, 如果 ~x + y < 2ⁿ~, 那么加法正常;
              如果 ~x + y >= 2ⁿ~, 那么加法 *溢出*, 结果为 ~x + y - 2ⁿ~. (~(x + y) mod 2ⁿ~)

              溢出检测： 令 ~s = x + y~, 当 ~s < x~ 或 ~s < y~ 时， 发生了溢出

  + 无符号数加法逆元 :: ~x = 0, -x = 0~, ~x > 0, -x = 2ⁿ - x~, ~x + -x = 0~.

  + 补码加法 :: 对于补码数 ~-2ⁿ <= x, y <= 2ⁿ - 1~:

            正溢出： ~x + y = x + y - 2ⁿ, 2ʷ <= x + y~

            正常： ~x + y = x + y, -2ʷ <= x + y < 2ʷ~

            负溢出： ~x + y = x + y + 2ⁿ, x + y < -2ʷ~
            
            溢出检测： 零 ~s = x + y~, 当 ~x > 0, y > 0, s < 0~ 或 ~x < 0, y < 0, s > 0~ 时溢出

  + 补码数加法逆元 :: ~x = TMin, -x = TMin~, ~x > TMin, -x = -x~, ~x + -x = 0~.

  + 无符号数乘法 :: ~x*y = (x·y) mod 2ⁿ~

  + 补码乘法 :: ~x*y = U2T((x·y) mod 2ⁿ)~, 结果截断为补码数

  + 乘以 2 的幂 :: ~x << k~

  + 除以 2 的幂 :: 结果向下取整 ~x >> k~, 结果向上取整 ~(x + (1 << k) - 1) >> k~ (P71)

* 浮点数表示
  二进制小数点后表示的值 = 原本代表的值 / 2^(-小数点后的位数) --(类比十进制)

  如： 0.001: (001) = 1, 2^(-3) = 8, 0.001 ==> 1/8

** IEEE 754
   + [[https://zh.wikipedia.org/wiki/IEEE_754][IEEE 754 维基百科]]

   公式： ~V = pow(-1, s) * M * pow(2, E)~
   + 符号 (sign) :: ~s~ 决定浮点数的符号
   + 尾数 (significand) :: ~M~ 是一个二进制小数
   + 阶码 (exponent) :: ~E~ 的作用是对浮点数加权， 权重是 ~2~ 的 ~E~ 次幂

   浮点数的位表示：
   + 一个单独的符号位 ~s~ 直接编码符号 ~s~
   + ~k~ 位的阶码字段 ~exp~ 编码阶码 ~E~
   + ~n~ 位小数字段 ~frac~ 编码尾数 ~M~

   |--------------+---+-----+------|
   | 浮点数类型   | s | exp | frac |
   |--------------+---+-----+------|
   | 单精度浮点数 | 1 |   8 |   23 |
   | 双精度浮点数 | 1 |  11 |   52 |
   |--------------+---+-----+------|

   根据 ~exp~ 的值分为三种情况：
   + 规格化的值 :: ~exp~ 的位模式既不全为 ~0~ 也不全为 ~1~.

              此时， 阶码字段被解释为以 *偏置(biased)* 形式表示的有符号整数， 阶码的
              值 ~E = exp - Bias~. 其中， ~E~ 为实际的阶码值， ~exp~ 为 ~exp~ 字段按无符号解释出的值，
              ~Bias = pow(2, k-1) - 1~. ~k~ 为 ~exp~ 的位数。

              小数字段 ~frac~ 被解释为描述小数值 ~f~, ~0 <= f < 1~. 二进制表示为 ~0.f~, 小数点在
              最高有效位的左边。 尾数 ~M = 1 + f~. 这种表示方式也叫做 *隐含的以 1 开头的* 表示。

              表示的浮点数应该为： ~pow(-1, s) * (1 + frac) * pow(2, exp - Bias)~.

   + 非规格化的值 :: 当 ~exp~ 全为 ~0~ 时.

               此时， 阶码值 ~E = 1- Bias~, 尾数 ~M = f~.

               非规格化的值的两种用途：
     - 提供表示数值 0 的方法， ~+0.0~ 和 ~-0.0~
     - 表示哪些非常接近 ~0.0~ 的数
    
   + 特殊值 :: 当 ~exp~ 全为 ~1~ 时。

            此时如果 ~frac~ 全为 ~0~, 得到的值表示无穷。 根据 ~s~ 的值分别表示正负无穷。

            无穷可以表示 *溢出* 的结果。

            如果此时 ~frac~ 不全为 ~0~, 那么得到的值表示 ~NaN~ 非数。 比如 ~sqrt(-1)~ 会得到 ~NaN~.

   转换例子：
   #+BEGIN_EXAMPLE
     (int):(0x00359141) ==> (float):(0x4A564504)

     (bit)(int):(0x00359141) ==> (bit):1101011001000101000001

     ==> (bit):1.101011001000101000001 * 2^21 ==> (E = 21, M = 1.101011001000101000001)

     ==> frac = 101011001000101000001000

     ==> exp = (E + Bias) = (21 + 127) = 10010100

     ==> (float):(0, exp, frac) ==> (0100 1010 0101 0110 0100 0101 0000 01000)

     ==> (float):(0x4A564504)
   #+END_EXAMPLE
 
** 舍入
   四种舍入方式：
   + 向偶数舍入（向最接近的值舍入） :: 默认方式， 当舍入的值距离一个值比另一个值
        更接近时， 舍入更接近的值。 如果与两个值的距离相同， 向偶数舍入。

        如： 对于 ~1.4~, 和 ~1~ 的距离是 ~0.4~, 和 ~2~ 的距离是 ~0.6~. 因此舍入为 ~1~.

        对于 ~1.5~, 和 ~1~ 与 ~2~ 的距离都是 ~0.5~, 但 ~2~ 是偶数， 因此舍入为 ~2~.

        同理， ~2.5~ 舍入为 ~2~.

   + 向上舍入 :: ~1.1~ 舍入为 ~2~, ~-1.1~ 舍入为 ~-1~. 舍入为较大的值

   + 向下舍入 :: ~1.1~ 舍入为 ~1~, ~-1.1~ 舍入为 ~-2~. 舍入为较小的值

   + 向零舍入 :: 正数向下舍入， 负数向上舍入， 趋近于 ~0~

   对于二进制小数， 最低有效位是 ~0~ 为偶数， ~1~ 为奇数。

   因此， 二进制小数的舍入倾向于使最低有效位为 ~0~.

   *Example*:
   #+BEGIN_EXAMPLE
     10.00011 ==> 10.00
     10.00110 ==> 10.01

     10.11100 ==> 11.00
     10.10100 ==> 10.10
   #+END_EXAMPLE

   对于前两个舍入， 舍入值并不是中间值， 因此舍入到最接近的值。

   对于第三个舍入， 最低有效位是 ~1~, 向上舍入进位使得最低有效位为 ~0~.

   对于第四个舍入， 最低有效位是 ~0~, 向下舍入使得最低有效位保持不变为 ~0~.

