#+TITLE:      MySQL

* 目录                                                    :TOC_4_gh:noexport:
- [[#install][Install]]
- [[#事务][事务]]
  - [[#事务的隔离级别][事务的隔离级别]]
- [[#执行计划][执行计划]]
- [[#sql][SQL]]
- [[#相关问题][相关问题]]
  - [[#mysql-中-schema-和-database-的区别是什么][MySQL 中 Schema 和 Database 的区别是什么]]
  - [[#时区陷阱问题][时区陷阱问题]]
  - [[#怎样执行-sql-脚本][怎样执行 SQL 脚本]]
  - [[#怎样通过远程主机进行访问][怎样通过远程主机进行访问]]
  - [[#怎样在数据存在时更新不存在时插入][怎样在数据存在时更新不存在时插入]]
  - [[#怎样显示-table-的元数据信息][怎样显示 Table 的元数据信息]]

* Install
  目前来说，有一些 Linux 发行版已经将 MySQL 换成了 MariaDB，安装方式也就变成了：
  #+BEGIN_SRC bash
    apt-get install mariadb-server
  #+END_SRC
  
  安装完成后，可以通过 ~mysql_secure_installation~ 配置 root 用户的密码，参考：
  + [[https://mariadb.com/kb/en/library/mysql_secure_installation/][mysql_secure_installation - MariaDB Knowledge Base]]
  
* 事务
  事务的基本要素为：
  + 原子性：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用
  + 一致性：执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的
  + 隔离性：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的
  + 持久性：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响

  并发事务可能带来的问题：
  + 脏读：当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。
    因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的。
  + 丢失修改：指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。
    这样第一个事务内的修改结果就被丢失，因此称为丢失修改。
  + 不可重复读：指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，
    由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。
  + 幻读：幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，
    就好像发生了幻觉一样，所以称为幻读。

  不可重复度和幻读区别：不可重复读的重点是修改，幻读的重点在于新增或者删除。

** 事务的隔离级别
   SQL 标准定义了四个隔离级别：
   + READ-UNCOMMITTED(读取未提交)：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读
   + READ-COMMITTED(读取已提交)：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生
   + REPEATABLE-READ(可重复读)：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生
   + SERIALIZABLE(可串行化)：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读

   各自可以避免的并发问题：
   |------------------+------+------------+------|
   | 隔离级别         | 脏读 | 不可重复读 | 幻读 |
   |------------------+------+------------+------|
   | READ-UNCOMMITTED | Y    | Y          | Y    |
   | READ-COMMITTED   | N    | Y          | Y    |
   | REPEATABLE-READ  | N    | N          | Y    |
   | SERIALIZABLE     | Y    | Y          | Y    |
   |------------------+------+------------+------|

   MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重复读）。

   参考链接：
   + [[https://github.com/Snailclimb/JavaGuide/blob/master/docs/database/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB(%E5%9B%BE%E6%96%87%E8%AF%A6%E8%A7%A3).md#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB][事务隔离级别(图文详解)]]
   + [[https://www.cnblogs.com/huanongying/p/7021555.html][MySQL 的四种事务隔离级别 - 花弄影 - 博客园]]

* 执行计划
  MySQL 数据库索引使用的是 B+ 树结构，我们查询数据时，查询条件命中索引时，查询效率会特别高，如果没有命中索引，此时，则会全表扫描，耗时且消耗性能。

  通过执行计划，我们可以得知一条 SQL 语句执行下来，这个 SQL 分别查询了哪些表，先查询的哪张表后查询的哪张表，以及是否使用了索引，使用了哪些索引，
  当前 SQL 语句查询效率是否高效，这些数据从哪获取到。

  通过在 SQL 语句前，添加 explain 关键字，MySQL 会在查询上设置一个标记，执行查询时，会返回执行计划的信息，而不是执行这一条 SQL 语句。

  返回的执行计划的信息格式如下：
  #+begin_example
    +----+-------------+-------+------------+-------+---------------+---------+---------+--------+------+----------+-------------+
    | id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref    | rows | filtered | Extra       |
    +----+-------------+-------+------------+-------+---------------+---------+---------+--------+------+----------+-------------+
    | 1  | SIMPLE      | order | <null>     | index | <null>        | PRIMARY | 8       | <null> | 51   | 100.0    | Using index |
    +----+-------------+-------+------------+-------+---------------+---------+---------+--------+------+----------+-------------+
  #+end_example

  其中，各字段的含义如下：
  + id：查询 SQL 语句 id，当有多个查询时，将拆分为多个执行计划，每个执行计划都有一个 id，id是 SQL 执行成功的标识，SQL 从大到小的执行，id 越大越先执行。
    当 id 相同的情况时，执行顺序由上至下。
  + select_type：查询类型，MYSQL 中一共有 8 中查询类型，主要作用是用来标记查询类型，比如：普通查询、关联查询、子查询、左查询等
  + table：当前执行计划查询的表，如果给表起别名了，则显示别名信息
  + partitions:：访问的分区表信息
  + type：查询方式，即 MYSQL 如何去查找的表中的行，查询方式是 SQL 优化中一个很重要的指标，结果值从好到坏依次是：system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL。
    |--------+--------------------------------------------------------------------------------------------------------------|
    | 类型   | 含义                                                                                                         |
    |--------+--------------------------------------------------------------------------------------------------------------|
    | system | 表中只有一行数据，此时根据索引查询一次就能找到                                                               |
    | const  | SQL 查询时根据索引一次就找到了，此时会显示为 const                                                           |
    | eq_ref | 唯一索引扫描，常见于主键和唯一索引扫描，索引在表中只对应一条记录                                             |
    | ref    | 与 eq_ref 相比，ref 常见于非唯一索引扫描，通常能扫描到多条记录，还可见于唯一索引最左原则匹配扫描也会出现 ref |
    | range  | 通常见于范围扫描，比如：in、大于小于等。索引根据给定范围进行检索                                             |
    | index  | 索引全表扫描，此时扫描只扫描索引树，非数据库表                                                               |
    | All    | 全表扫描                                                                                                     |
    |--------+--------------------------------------------------------------------------------------------------------------|
  + possible_keys：可能使用到的索引
  + key：实际使用到的索引
  + key_len：当前使用的索引的长度
  + ref：关联 id 等信息
  + rows：查找到记录所扫描的行数
  + filtered：查找到所需记录所占总扫描记录数比例
  + Extra：额外的信息

* SQL
  + 在 MySQL 中 LIMIT 不是子句，因此需要放在 ORDER BY 子句后面

* 相关问题
** MySQL 中 Schema 和 Database 的区别是什么
   MySQL 中 Schema 和 Database 在语义上是等价的，两者可以等价替换。

   参考：[[https://stackoverflow.com/questions/11618277/difference-between-schema-database-in-mysql][Difference Between Schema / Database in MySQL - Stack Overflow]]

** 时区陷阱问题
   ~mysql~ 6.0 以上的版本需要在链接字符串中假设参数 ~serverTimezone~ 指定时区：
   #+BEGIN_SRC xml
     <property name="url" value="jdbc:mysql://localhost:3306/springdatastudy?serverTimezone=UTC"/>
   #+END_SRC

   但是设置 ~UTC~ 时区可能导致时间精度的问题， 因此可以设置为中国标准时间：
   #+BEGIN_SRC xml
     <property name="url" value="jdbc:mysql://localhost:3306/springdatastudy?serverTimezone=Asia/Shanghai"/>
   #+END_SRC

** 怎样执行 SQL 脚本
   #+BEGIN_SRC bash
     mysql> source /path/to/script
   #+END_SRC

** 怎样通过远程主机进行访问
   + 更改配置文件中的 ~bind-address~ 为 ~0.0.0.0~, 配置文件在 ~/etc/mysql/~, 使得允许远程主机访问
   + 更改用户的 ~host~ 为 ~%~, 允许该用户进行远程访问
      #+BEGIN_SRC sql
        > use mysql;
        > UPDATE USER SET HOST='%' WHERE user='user_name';
      #+END_SRC     
   + 通过如下方式创建拥有所有权限可远程访问的用户
     #+BEGIN_SRC sql
       CREATE USER 'user'@'%' IDENTIFIED BY 'password';

       GRANT ALL PRIVILEGES ON *.* TO 'user'@'%' = WITH GRANT OPTION;

       FLUSH PRIVILEGES;
     #+END_SRC

** 怎样在数据存在时更新不存在时插入
   #+BEGIN_SRC sql
     IF EXISTS(SELECT * FROM tbl WHERE id = 30122)
       UPDATE tbl SET name = 'john' WHERE id = 3012
     ELSE
       INSERT INTO tbl(name) VALUES('john');
   #+END_SRC

** 怎样显示 Table 的元数据信息
   通过 ~SHOW COLUMNS FROM tblName~ 可以显示表的元数据信息，但是也可以通过 ~DESCRIBE tblName~ 快速查询。
