#+TITLE:      相关问题

* 目录                                                    :TOC_4_gh:noexport:
- [[#创建动态大小的数组][创建动态大小的数组]]
- [[#goroutines-和线程][Goroutines 和线程]]
- [[#包的初始化][包的初始化]]
- [[#receiver-使用-value-还是使用-pointer][receiver 使用 value 还是使用 pointer]]

* 创建动态大小的数组
  #+begin_src go
    left := make([]int, leftLength)

    a := make([][]uint8, dy)
    for i := range a {
        a[i] = make([]uint8, dx)
    }
  #+end_src

  参考：
  + [[https://stackoverflow.com/questions/39804861/what-is-a-concise-way-to-create-a-2d-slice-in-go][What is a concise way to create a 2D slice in Go? - Stack Overflow]]
  + [[https://stackoverflow.com/questions/38362631/go-error-non-constant-array-bound][Go error: non-constant array bound - Stack Overflow]]

* Goroutines 和线程
  通过阅读 [[https://books.studygolang.com/gopl-zh/ch9/ch9-08.html][Goroutines 和线程 · Go语言圣经]] 可以了解到 Goroutines 和线程之间的一些区别和联系：
  1. 栈的大小，线程通常会分配一个固定大小的栈，这个栈可能小了也可能大了，而 Goroutines 则是动态的栈，
     一开始很小，后面可以根据需要进行扩大
  2. 线程由内核进行调度，而 Go 的运行时包含了其自己的调度器，这个调度器使用了一些技术手段，比如 m:n 调度，
     在 n 个操作系统线程上多工（调度）m 个 goroutine
  3. 可以通过 GOMAXPROCS 变量来决定会有多少个操作系统的线程同时执行 Go 的代码，默认值是运行机器上的 CPU 的核心数
  4. Goroutine 没有 ID 号，ThreadLocal 也就不存在了……

* 包的初始化
  Go 中包的初始化位于 main 方法之前，其顺序为 import --> const --> var --> init()，可以参考下图：
  #+HTML: <img src="https://astaxie.gitbooks.io/build-web-application-with-golang/en/images/2.3.init.png?raw=true">

  重要的一点：init 函数只会调用一次，可以起到 =sync.Once= 的作用。

  参考：
  + [[https://stackoverflow.com/a/49831018][When is the init() function run? - Stack Overflow]]

* receiver 使用 value 还是使用 pointer
  The Code Review comment can help:
  #+begin_quote
  + If the receiver is a map, func or chan, don't use a pointer to it.
  + If the receiver is a slice and the method doesn't reslice or reallocate the slice, don't use a pointer to it.
  + If the method needs to mutate the receiver, the receiver must be a pointer.
  + If the receiver is a struct that contains a sync.Mutex or similar synchronizing field, the receiver must be a pointer to avoid copying.
  + If the receiver is a large struct or array, a pointer receiver is more efficient. How large is large? Assume it's equivalent to passing all its elements as arguments to the method. If that feels too large, it's also too large for the receiver.
  + Can function or methods, either concurrently or when called from this method, be mutating the receiver? A value type creates a copy of the receiver when the method is invoked, so outside updates will not be applied to this receiver. If changes must be visible in the original receiver, the receiver must be a pointer.
  + If the receiver is a struct, array or slice and any of its elements is a pointer to something that might be mutating, prefer a pointer receiver, as it will make the intention more clear to the reader.
  + If the receiver is a small array or struct that is naturally a value type (for instance, something like the time.Time type), with no mutable fields and no pointers, or is just a simple basic type such as int or string, a value receiver makes sense.
  + A value receiver can reduce the amount of garbage that can be generated; if a value is passed to a value method, an on-stack copy can be used instead of allocating on the heap. (The compiler tries to be smart about avoiding this allocation, but it can't always succeed.) Don't choose a value receiver type for this reason without profiling first.
  + Finally, when in doubt, use a pointer receiver.
  #+end_quote
  
  参考：
  + [[https://stackoverflow.com/questions/27775376/value-receiver-vs-pointer-receiver][function - Value receiver vs. pointer receiver - Stack Overflow]]

