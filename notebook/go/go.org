#+TITLE:      GoLang

* 目录                                                    :TOC_4_gh:noexport:
- [[#go-语言起源][Go 语言起源]]
- [[#简单语句][简单语句]]
- [[#程序结构][程序结构]]
  - [[#命名][命名]]
  - [[#声明][声明]]
  - [[#包和文件][包和文件]]
  - [[#作用域][作用域]]
- [[#数据类型][数据类型]]
  - [[#基础类型][基础类型]]
  - [[#引用类型][引用类型]]

* Go 语言起源
  Go 语言的设计主要受到 CSP、Pascal 和 C 三个分支的影响，其中，CSP 只是一个用于描述并发性基本概念的描述语言，
  并不是一个可以编写可执行程序的通用编程语言。
  
  在 CSP 中，程序是一组中间没有共享状态的平行运行的处理过程，它们之间使用 *管道* 进行通信和控制同步。

  #+HTML: <img src="https://books.studygolang.com/gopl-zh/images/ch0-01.png">
  
  Go 语言的设计虽然参考了其他语言，但是，本身的设计上是很简单的，也就是说，缺少一些在其他语言中很常见的特性。例如，
  它没有隐式的数值转换，没有构造函数和析构函数，没有运算符重载，没有默认参数，也没有继承，没有泛型，没有异常，
  没有宏，没有函数修饰，更没有线程局部存储。

  这体现了 Go 语言的一个设计哲学——少即是多（感觉某些时候会很蛋疼）

  可以参考：
  + [[https://en.wikipedia.org/wiki/Communicating_sequential_processes][Communicating sequential processes - Wikipedia]]
  + [[https://books.studygolang.com/gopl-zh/ch0/ch0-01.html][Go语言起源 | Go语言圣经]]
  + [[https://books.studygolang.com/gopl-zh/ch0/ch0-02.html][Go语言项目 | Go语言圣经]]

* 简单语句
  Go 语言不需要在语句或者声明的末尾添加分号，除非一行上有多条语句，因为编译器会主动把特定符号后的换行符转换为分号，主要包括以下情况：
  + 行末是标识符、整数、浮点数、虚数、字符或字符串文字、关键字 break、continue、fallthrough 或 return 中的一个
  + 行末是运算符和分隔符 ++、--、)、] 或 } 中的一个

  也就是说，这样的代码会出问题：
  #+begin_src go
    f(
      a(), b(), c()
    )
  #+end_src

  但是可以这样：
  #+begin_src go
    f(
      a(), b(), c(),
    )
  #+end_src

* 程序结构
** 命名
   Go 语言中标识符必须以字母（Unicode 字母）或下划线开头，后面跟任意数量的字母、数组或下划线，大小写敏感。

   关键字和内建名字有：
   #+begin_example
     Keywords:
         break      default       func     interface   select
         case       defer         go       map         struct
         chan       else          goto     package     switch
         const      fallthrough   if       range       type
         continue   for           import   return      var

     Built-in Constants:
         true false iota nil

     Built-in Types:
         int     int8    int16      int32     int64
         uint    uint8   uint16     uint32    uint64 uintptr
         float32 float64 complex128 complex64
         bool    byte    rune       string    error

     Built-in Functions:
         make    len     cap  new append copy close delete
         complex real    imag
         panic   recover
   #+end_example
  
   #+begin_quote
   内建名字可以被从新定义，但是也要注意避免过度而引起语义混乱。
   #+end_quote

   如果一个名字是在函数内部定义，那么它的就只在函数内部有效。如果是在函数外部定义，那么将在当前包的所有文件中都可以访问。
   名字的开头字母的大小写决定了名字在包外的可见性。如果一个名字是大写字母开头的，那么它将是导出的。

   名字的长度没有逻辑限制，但是 Go 语言的风格是尽量使用短小的名字，对于局部变量尤其是这样。

   #+begin_comment
   a, b, c, d, e...?
   #+end_comment
  
   同时，在习惯上，Go 语言程序员推荐使用 *驼峰式* 命名，当名字有几个单词组成的时优先使用大小写分隔，而不是优先用下划线分隔。
  
** 声明
   声明语句定义了程序的各种实体对象以及部分或全部的属性。Go 语言主要有四种类型的声明语句：var、const、type 和 func，
   分别对应变量、常量、类型和函数实体对象的声明。

   Go 语言编写的程序对应一个或多个以 =.go= 为文件后缀名的源文件中。每个源文件以包的声明语句开始，说明该源文件是属于哪个包。
   包声明语句之后是 =import= 语句导入依赖的其它包，然后是包一级的类型、变量、常量、函数的声明语句，
   包一级的各种类型的声明语句的顺序无关紧要（函数内部的名字则必须先声明之后才能使用）。
   #+begin_src go
     // =============================================================================
     // package declare
     // =============================================================================

     package main

     // =============================================================================
     // import statement
     // =============================================================================

     import "fmt"

     // =============================================================================
     // package-level declarations of types, variables, constants, and functions
     // =============================================================================

     func main() {
         fmt.Println("Hello, World!")
     }
   #+end_src

   + 变量 ::
     可以通过 =var= 关键字声明变量，类型放在最后面，只能有一个类型：
     #+begin_src go
       var c, python, java bool
     #+end_src
     
     使用初始值是可以通过类型推断自动判断类型，可以有多个类型的值：
     #+begin_src go
       var c, python, java = true, false, "no!"
     #+end_src
     
     可以使用 ~:=~ 代理具有隐式类型声明的 =var= 语句，这需要左值为一个新的变量，由于函数外面的语句必须由关键字开始，因此函数外面无法使用这一语句：
     #+begin_src go
       c, python, java := true, false, "no!"
     #+end_src

     变量的生命周期为：
     + 对于包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的
     + 对于局部变量来说，它们的生命周期为每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收
     + 编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，这由变量的作用域确定，有点类似 Rust 中的所有权
     
     其中，函数的参数变量和返回值变量都是局部变量，它们在函数每次被调用的时候创建。

     可以参考：《Go 程序设计语言 2.3.4 节》

   + 赋值 ::
     Go 语言和 Python 一样，支持元组赋值，这是很棒的一个特性，至少，交换变量值就不需要手动写一个中间变量了：
     #+begin_src go
       x, y = y, x
     #+end_src

     同时，函数可以返回多个值，这些值就是一个元组，这时，左边变量的数目必须和右边函数的返回值数量一致。

     一些特殊的操作返回的值数量受到左值数量的影响,可以通过空白标识符 =_= 来丢弃不需要的值：
     #+begin_src go
       v = m[key]                // map 查找，失败时返回零值
       v = x.(T)                 // type 断言，失败时 panic 异常
       v = <-ch                  // 管道接收，失败时返回零值

       _, ok = m[key]            // map 返回 2 个值
       _, ok = mm[""], false     // map 返回 1 个值
       _ = mm[""]                // map 返回 1 个值
     #+end_src

   + 类型 :: 
     Go 语言中可以通过 *类型声明* 语句来声明类型，但是需要注意的是，Go 语言中的类型和其他一些语言中的类不一样，
     反而更接近 C 语言中的 =typedef= 和结构体：
     #+begin_src go
       type 类型名字 底层类型
     #+end_src

     可以简单的为一个类型添加不同的别名，但是，这些别名属于不同的类型，因此它们不可以被相互比较或混在一个表达式运算。
     #+begin_src go
       type Celsius float64     // 摄氏温度
       type Fahrenheit float64  // 华氏温度
     #+end_src

     Go 语言不允许隐式类型转换，只能使用 =T(v)= 表达式完成类型转换，只有当两个类型的底层基础类型相同时，才允许这种转型操作，
     或者是两者都是指向相同底层结构的指针类型，这些转换只改变类型而不会影响值本身。
     
     当然，数值类型之间的转型是被允许的，并且在字符串和一些特定类型的 =slice= 之间也是可以转换的。
     #+begin_src go
       (*int)(0)  // Convert to *int
     #+end_src

     底层数据类型决定了内部结构和表达方式，也决定是否可以像底层类型一样对内置运算符的支持：
     #+begin_src go
       var v Celsius = 1.0
       v += 1
     #+end_src

     比较运算符以用来比较一个命名类型的变量和另一个有相同类型的变量，或有着 *相同底层类型* 的 *未命名类型的值* 之间做比较，
     但是如果两个值有着不同的类型，则不能直接进行比较：
     #+begin_src go
       var c Celsius
       var f Fahrenheit
       fmt.Println(c == 0)           // "true"
       fmt.Println(f >= 0)           // "true"
       fmt.Println(c == f)           // compile error: type mismatch
       fmt.Println(c == Celsius(f))  // "true"!
     #+end_src

** 包和文件
   每个 ~Go~ 程序都由 ~package~ 组成，程序从 =main= 包开始运行，Go 语言中一个包的源代码保存在一个或 *多个* 以 =.go= 为文件后缀名的源文件中，
   通常一个包所在目录路径的后缀是包的导入路径，例如包 =gopl.io/ch1/helloworld= 对应的目录路径是 =$GOPATH/src/gopl.io/ch1/helloworld=.

   每个包都对应一个独立的名字空间。例如，在 =image= 包中的 =Decode= 函数和在 =unicode/utf16= 包中的 =Decode= 函数是不同的。
   要在外部引用该函数，必须显式使用 =image.Decode= 或 =utf16.Decode= 形式访问。

   包还可以让我们通过控制哪些名字是外部可见的来隐藏内部实现信息。在 Go 语言中，一个简单的规则是：如果一个名字是大写字母开头的，
   那么该名字是导出的（因为汉字不区分大小写，因此汉字开头的名字是没有导出的）。

   #+begin_comment
   一般也不会用中文来命名吧……
   #+end_comment

   在 Go 语言程序中，每个包都有一个全局唯一的导入路径。导入语句中类似 "gopl.io/ch2/tempconv" 的字符串对应包的导入路径。
   Go 语言的规范并没有定义这些字符串的具体含义或包来自哪里，它们是由 *构建工具* 来解释的。
   #+begin_quote
   当使用 Go 语言自带的 go 工具箱时，一个导入路径代表一个目录中的一个或多个 Go 源文件。
   #+end_quote

   除了包的导入路径，每个包还有一个包名，包名一般是短小的名字（并不要求包名是唯一的），包名在包的声明处指定。按照惯例，
   一个包的名字和包的导入路径的最后一个字段相同，例如 =gopl.io/ch2/tempconv= 包的名字一般是 =tempconv=.

   包的初始化首先是解决包级变量的依赖顺序，然后按照包级变量声明出现的顺序依次初始化：
   #+begin_src go
     var a = b + c // a 第三个初始化, 为 3
     var b = f()   // b 第二个初始化, 为 2, 通过调用 f (依赖c)
     var c = 1     // c 第一个初始化, 为 1

     func f() int { return c + 1 }
   #+end_src

   如果包中含有多个 =.go= 源文件，它们将按照发给编译器的顺序进行初始化，Go 语言的构建工具首先会将 =.go= 文件根据文件名排序，然后依次调用编译器编译。

   对于在包级别声明的变量，如果有初始化表达式则用表达式初始化，还有一些没有初始化表达式的，可以用一个特殊的 =init= 初始化函数来简化初始化工作。
   每个文件都可以包含多个 =init= 初始化函数，这样的 =init= 初始化函数除了不能被调用或引用外，其他行为和普通函数类似。
   在每个文件中的 =init= 初始化函数，在程序开始执行时按照它们声明的顺序被自动调用。
   #+begin_src go
     func init() { /* ... */ }
   #+end_src

   比如，具有复杂初始化逻辑的包级变量的初始化：
   #+begin_src go
     var pc [256]byte

     func init() {
         for i := range pc {
             pc[i] = pc[i/2] + byte(i&1)
         }
     }
   #+end_src

   但也可以将初始化逻辑包装为一个匿名函数来进行处理：
   #+begin_src go
     var pc [256]byte = func() (pc [256]byte) {
         for i := range pc {
             pc[i] = pc[i/2] + byte(i&1)
         }
         return
     }()
   #+end_src

   每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次。因此，如果一个 =p= 包导入了 =q= 包，那么在 =p= 包初始化的时候可以认为 =q= 包必然已经初始化过了。
   初始化工作是自下而上进行的，main 包最后被初始化。以这种方式，可以确保在 =main= 函数执行之前，所有依赖的包都已经完成初始化工作了。

** 作用域
   Go 语言存在块级作用域，同时，按照由内到外的查找规则，内部作用域的名字可以覆盖外部作用域的名字：
   #+begin_src go
     func main() {
       a := 10
       {
         a := 100
         fmt.Println(a)  // 100
       }
       fmt.Println(a)      // 10
     }

   #+end_src

   Go 中的作用域大致可以分为如下几个级别：
   #+begin_src go
     全局作用域 -> 包级作用域 -> 函数作用域 -> 块级作用域
   #+end_src

   虽然说块级作用域挺好的，但有时候又希望它不存在，如果可以由用户来控制就好了，比如循环体上的变量。

* 数据类型
  Go 语言将数据类型分为四类：基础类型、复合类型、引用类型和接口类型。

** 基础类型
   通常，基础类型就是数值类型，但是，在这点上，Go 的风格更加接近 C 语言，因为，Go 中的字符串也是基础类型。
   
   + 整型 ::
     Go 语言同时提供了有符号和无符号类型的整数，主要有：
     #+begin_example
       int  int8  int16  int32  int64
       uint uint8 uint16 uint32 uint64
     #+end_example

     其中，类型 =int= 和 =uint= 的宽度可能是 =32= 或 =64= 位，由编译器和平台决定。

     同时，还存在一些其他的和整数类型相关的类型：
     #+begin_example
       byte     // alias for uint8
       rune     // alias for int32, represents a Unicode code point
       uintptr
     #+end_example

     下面是 Go 语言中关于算术运算、逻辑运算和比较运算的二元运算符，它们按照优先级递减的顺序排列：
     #+begin_example
       ,*      /      %      <<       >>     &       &^
       +      -      |      ^
       ==     !=     <      <=       >      >=
       &&
       ||
     #+end_example

     其中，算术运算符 +、-、* 和 / 可以适用于整数、浮点数和复数，但是取模运算符 % 仅用于整数间的运算，同时，
     在 Go 语言中，% 取模运算符的符号和被取模数的符号总是一致的，因此 -5 % 3 和 -5 % -3 结果都是 -2。
     
     Go 语言中提供了一个 =&^= 位运算操作符，作用为：如果对应 y 中 bit 位为 1 的话, 表达式 z = x &^ y 结果 z 的对应的 bit 位为 0，
     否则 z 对应的 bit 位等于 x 相应的 bit 位的值。

   + 浮点数 :: 
     Go 中提供了 =float32= 和 =float64= 两个浮点数类型，剩下感觉没啥好说的了。

   + 复数 :: 
     Go 是原生支持复数这一数值类型的语言，提供了 =complex64= 和 =complex128= 两个精度。内置的 =complex= 函数用于构建复数，
     内建的 =real= 和 =imag= 函数分别返回复数的实部和虚部：
     #+begin_src go
       var x complex128 = complex(1, 2) // 1+2i
       var y complex128 = complex(3, 4) // 3+4i
       fmt.Println(x*y)                 // "(-5+10i)"
       fmt.Println(real(x*y))           // "-5"
       fmt.Println(imag(x*y))           // "10"
     #+end_src

   + 布尔型 :: 
     布尔类型没啥好说的，只有 =true= 和 =false= 这两个值，存在短路行为，OVER。

   + 字符串 :: 
     

** 引用类型
   + 指针 ::
     Go 中存在指针，和 C 语言不同的是：
     1. Go 语言中的指针是不能偏移的，不能像 C 语言中那样，拿到个指针就可以到处飘了
     2. Go 语言中返回函数中局部变量的地址也是安全的
     
     这就使得下面这个操作的含义和 C 语言中的不一样，C 语言中是让指针 p 的值发生偏移，但是 Go 中是让 p 指向的变量的值加一：
     #+begin_src go
       func incr(p *int) int {
           ,*p++
           return *p
       }
     #+end_src
     
     可以通过内建函数 =new= 创建变量，表达式 =new(T)= 将创建一个 =T= 类型的匿名变量，初始化为 =T= 类型的零值，然后返回变量地址，类型为 =*T= 的指针，
     一定程度上等价于如下函数：
     #+begin_src go
       func newInt() *int {
           var dummy int
           return &dummy
       }
     #+end_src
   
