#+TITLE:      GoLang

* 目录                                                    :TOC_4_gh:noexport:
- [[#go-语言起源][Go 语言起源]]
- [[#基本语法][基本语法]]
  - [[#分号][分号]]
  - [[#控制流][控制流]]
  - [[#切片][切片]]
- [[#程序结构][程序结构]]
  - [[#命名][命名]]
  - [[#声明][声明]]
  - [[#包和文件][包和文件]]
  - [[#作用域][作用域]]
- [[#数据类型][数据类型]]
  - [[#基础类型][基础类型]]
  - [[#引用类型][引用类型]]

* Go 语言起源
  Go 语言的设计主要受到 CSP、Pascal 和 C 三个分支的影响，其中，CSP 只是一个用于描述并发性基本概念的描述语言，
  并不是一个可以编写可执行程序的通用编程语言。
  
  在 CSP 中，程序是一组中间没有共享状态的平行运行的处理过程，它们之间使用 *管道* 进行通信和控制同步。

  #+HTML: <img src="https://books.studygolang.com/gopl-zh/images/ch0-01.png">
  
  Go 语言的设计虽然参考了其他语言，但是，本身的设计上是很简单的，也就是说，缺少一些在其他语言中很常见的特性。例如，
  它没有隐式的数值转换，没有构造函数和析构函数，没有运算符重载，没有默认参数，也没有继承，没有泛型，没有异常，
  没有宏，没有函数修饰，更没有线程局部存储。

  这体现了 Go 语言的一个设计哲学——少即是多（感觉某些时候会很蛋疼）

  可以参考：
  + [[https://en.wikipedia.org/wiki/Communicating_sequential_processes][Communicating sequential processes - Wikipedia]]
  + [[https://books.studygolang.com/gopl-zh/ch0/ch0-01.html][Go语言起源 | Go语言圣经]]
  + [[https://books.studygolang.com/gopl-zh/ch0/ch0-02.html][Go语言项目 | Go语言圣经]]

* 基本语法
** 分号
   Go 语言不需要在语句或者声明的末尾添加分号，除非一行上有多条语句，因为编译器会主动把特定符号后的换行符转换为分号，主要包括以下情况：
   + 行末是标识符、整数、浮点数、虚数、字符或字符串文字、关键字 break、continue、fallthrough 或 return 中的一个
   + 行末是运算符和分隔符 ++、--、)、] 或 } 中的一个

   #+begin_src go
     f(
       a(), b(), c()   // error
     )

     f(
       a(), b(), c(),  // ok
     )
   #+end_src

** 控制流
   Go 语言里面 =for= 循环就是唯一的循环控制语句了，几个特点：
   + 由 init statement、condition expression 和 post statement 组成
   + 总是有大括号但是没有小括号：
     #+begin_src go
       for i := 0; i < 10; i++ {
         sum += i
       }
     #+end_src
   + 循环语句上声明的变量作用域仅限于循环语句内部
   + init statement 和 post statement 是可选的：
     #+begin_src go
       for ; sum < 1000; {
         sum += sum
       }
     #+end_src

     删除分号就约等于 =while= 语句了：
     #+begin_src go
       for sum < 1000 {
         sum += sum
       }
     #+end_src
     
     啥都不要就是死循环：
     #+begin_src go
       for {
       }
     #+end_src

   条件判断语句 =if= 也不要小括号但是要大括号：
   #+begin_src go
     func sqrt(x float64) string {
       if x < 0 {
         return sqrt(-x) + "i"
       }
       return fmt.Sprint(math.Sqrt(x))
     }
   #+end_src

   条件表达式前面可以有一个短语句，如果是声明变量，那么作用域仅限于条件语句：
   #+begin_src go
     if v := math.Pow(x, n); v < lim {
       return v
     }
   #+end_src

   作用域是包括 =else= 块的：
   #+begin_src go
     if v := math.Pow(x, n); v < lim {
       return v
     } else {
       fmt.Printf("%g >= %g\n", v, lim)
     }
   #+end_src

   Go 语言支持 =switch= 语句：
   #+begin_src go
     switch os := runtime.GOOS; os {
     case "darwin":
       fmt.Println("OS X.")
     case "linux":
       fmt.Println("Linux.")
     default:
       // freebsd, openbsd,
       // plan9, windows...
       fmt.Printf("%s.\n", os)
     }
   #+end_src
   
   但是它的 =case= 可以是表达式：
   #+begin_src go
     switch time.Saturday {
     case today + 0:
       fmt.Println("Today.")
     case today + 1:
       fmt.Println("Tomorrow.")
     case today + 2:
       fmt.Println("In two days.")
     default:
       fmt.Println("Too far away.")
     }
   #+end_src

   因此，可以不要条件：
   #+begin_src go
     switch {
     case t.Hour() < 12:
       fmt.Println("Good morning!")
     case t.Hour() < 17:
       fmt.Println("Good afternoon.")
     default:
       fmt.Println("Good evening.")
     }
   #+end_src   

   同时，比较特殊的是，Go 中匹配一个 case 项后不会自动执行后面的 case 项，除非使用了 =fallthrough= 关键字：
   #+begin_src go
     switch (v) {
     case 1:
       fmt.Println(1)
       fallthrough
     case 2:
       fmt.Println(2)
     }
   #+end_src

   PS：感觉 =break= 的方式更加符合使用习惯才对……

   defer 语句将函数的执行推迟到函数返回之前，但是参数还是会立即计算出来：
   #+begin_src go
     defer fmt.Println("world")

     fmt.Println("hello")
   #+end_src

   多个 defer 函数调用：
   #+begin_src go
     func main() {
       fmt.Println("counting")

       for i := 0; i < 10; i++ {
         defer fmt.Println(i)
       }

       fmt.Println("done")
     }
   #+end_src

   运行结果为，可以看到是后进先出的：
   #+begin_example
     counting
     done
     9
     8
     7
     6
     5
     4
     3
     2
     1
     0
   #+end_example

   更多可以参考：
   + [[https://blog.golang.org/defer-panic-and-recover][Defer, Panic, and Recover - The Go Blog]]

** 切片
   Go 中部分类型是支持切片操作的，但是，Go 中的切片和 Python 中的切片不一样，Go 中的切片是原对象的一个视图 View，
   修改切片也就会修改原对象，而 Python 中切片是创建一个新对象。

   当然，也因为 Go 中切片是原对象的视图的原因，使得切片同时具有长度 =length= 和容量 =capacity= 两个属性：
   + 长度表示该切片有多少个元素
   + 容量表示该切片 *对应的* 原对象左边界到原对象右边界之间的大小，当容量大于长度时，可以从新切片扩容

   PS：调整切片左边界会影响容量，但是右边界不会……

   可以通过函数 =len= 和 =cap= 获取这两个属性的值：
   #+begin_src go
     func main() {
       s := []int{2, 3, 5, 7, 11, 13}
       printSlice(s)

       // Slice the slice to give it zero length.
       s = s[:0]
       printSlice(s)

       // Extend its length.
       s = s[:4]
       printSlice(s)

       // Drop its first two values.
       s = s[2:]
       printSlice(s)
     }

     func printSlice(s []int) {
       fmt.Printf("len=%d cap=%d %v\n", len(s), cap(s), s)
     }
   #+end_src

   运行结果：
   #+begin_example
     len=6 cap=6 [2 3 5 7 11 13]
     len=0 cap=6 []
     len=4 cap=6 [2 3 5 7]
     len=2 cap=4 [5 7]
   #+end_example

* 程序结构
** 命名
   Go 语言中标识符必须以字母（Unicode 字母）或下划线开头，后面跟任意数量的字母、数组或下划线，大小写敏感。

   关键字和内建名字有：
   #+begin_example
     Keywords:
         break      default       func     interface   select
         case       defer         go       map         struct
         chan       else          goto     package     switch
         const      fallthrough   if       range       type
         continue   for           import   return      var

     Built-in Constants:
         true false iota nil

     Built-in Types:
         int     int8    int16      int32     int64
         uint    uint8   uint16     uint32    uint64 uintptr
         float32 float64 complex128 complex64
         bool    byte    rune       string    error

     Built-in Functions:
         make    len     cap  new append copy close delete
         complex real    imag
         panic   recover
   #+end_example
  
   #+begin_quote
   内建名字可以被从新定义，但是也要注意避免过度而引起语义混乱。
   #+end_quote

   如果一个名字是在函数内部定义，那么它的就只在函数内部有效。如果是在函数外部定义，那么将在当前包的所有文件中都可以访问。
   名字的开头字母的大小写决定了名字在包外的可见性。如果一个名字是大写字母开头的，那么它将是导出的。

   名字的长度没有逻辑限制，但是 Go 语言的风格是尽量使用短小的名字，对于局部变量尤其是这样。

   #+begin_comment
   a, b, c, d, e...?
   #+end_comment
  
   同时，在习惯上，Go 语言程序员推荐使用 *驼峰式* 命名，当名字有几个单词组成的时优先使用大小写分隔，而不是优先用下划线分隔。
  
** 声明
   声明语句定义了程序的各种实体对象以及部分或全部的属性。Go 语言主要有四种类型的声明语句：var、const、type 和 func，
   分别对应变量、常量、类型和函数实体对象的声明。

   Go 语言编写的程序对应一个或多个以 =.go= 为文件后缀名的源文件中。每个源文件以包的声明语句开始，说明该源文件是属于哪个包。
   包声明语句之后是 =import= 语句导入依赖的其它包，然后是包一级的类型、变量、常量、函数的声明语句，
   包一级的各种类型的声明语句的顺序无关紧要（函数内部的名字则必须先声明之后才能使用）。
   #+begin_src go
     // =============================================================================
     // package declare
     // =============================================================================

     package main

     // =============================================================================
     // import statement
     // =============================================================================

     import "fmt"

     // =============================================================================
     // package-level declarations of types, variables, constants, and functions
     // =============================================================================

     func main() {
         fmt.Println("Hello, World!")
     }
   #+end_src

   + 变量 ::
     可以通过 =var= 关键字声明变量，类型放在最后面，只能有一个类型：
     #+begin_src go
       var c, python, java bool
     #+end_src
     
     使用初始值是可以通过类型推断自动判断类型，可以有多个类型的值：
     #+begin_src go
       var c, python, java = true, false, "no!"
     #+end_src
     
     可以使用 ~:=~ 代理具有隐式类型声明的 =var= 语句，这需要左值为一个新的变量，由于函数外面的语句必须由关键字开始，因此函数外面无法使用这一语句：
     #+begin_src go
       c, python, java := true, false, "no!"
     #+end_src

     变量的生命周期为：
     + 对于包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的
     + 对于局部变量来说，它们的生命周期为每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收
     + 编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，这由变量的作用域确定，有点类似 Rust 中的所有权
     
     其中，函数的参数变量和返回值变量都是局部变量，它们在函数每次被调用的时候创建。

     可以参考：《Go 程序设计语言 2.3.4 节》

   + 赋值 ::
     Go 语言和 Python 一样，支持元组赋值，这是很棒的一个特性，至少，交换变量值就不需要手动写一个中间变量了：
     #+begin_src go
       x, y = y, x
     #+end_src

     同时，函数可以返回多个值，这些值就是一个元组，这时，左边变量的数目必须和右边函数的返回值数量一致。

     一些特殊的操作返回的值数量受到左值数量的影响,可以通过空白标识符 =_= 来丢弃不需要的值：
     #+begin_src go
       v = m[key]                // map 查找，失败时返回零值
       v = x.(T)                 // type 断言，失败时 panic 异常
       v = <-ch                  // 管道接收，失败时返回零值

       _, ok = m[key]            // map 返回 2 个值
       _, ok = mm[""], false     // map 返回 1 个值
       _ = mm[""]                // map 返回 1 个值
     #+end_src

   + 类型 :: 
     Go 语言中可以通过 *类型声明* 语句来声明类型，但是需要注意的是，Go 语言中的类型和其他一些语言中的类不一样，
     反而更接近 C 语言中的 =typedef= 和结构体：
     #+begin_src go
       type 类型名字 底层类型
     #+end_src

     可以简单的为一个类型添加不同的别名，但是，这些别名属于不同的类型，因此它们不可以被相互比较或混在一个表达式运算。
     #+begin_src go
       type Celsius float64     // 摄氏温度
       type Fahrenheit float64  // 华氏温度
     #+end_src

     Go 语言不允许隐式类型转换，只能使用 =T(v)= 表达式完成类型转换，只有当两个类型的底层基础类型相同时，才允许这种转型操作，
     或者是两者都是指向相同底层结构的指针类型，这些转换只改变类型而不会影响值本身。
     
     当然，数值类型之间的转型是被允许的，并且在字符串和一些特定类型的 =slice= 之间也是可以转换的。
     #+begin_src go
       (*int)(0)  // Convert to *int
     #+end_src

     底层数据类型决定了内部结构和表达方式，也决定是否可以像底层类型一样对内置运算符的支持：
     #+begin_src go
       var v Celsius = 1.0
       v += 1
     #+end_src

     比较运算符以用来比较一个命名类型的变量和另一个有相同类型的变量，或有着 *相同底层类型* 的 *未命名类型的值* 之间做比较，
     但是如果两个值有着不同的类型，则不能直接进行比较：
     #+begin_src go
       var c Celsius
       var f Fahrenheit
       fmt.Println(c == 0)           // "true"
       fmt.Println(f >= 0)           // "true"
       fmt.Println(c == f)           // compile error: type mismatch
       fmt.Println(c == Celsius(f))  // "true"!
     #+end_src

** 包和文件
   每个 ~Go~ 程序都由 ~package~ 组成，程序从 =main= 包开始运行，Go 语言中一个包的源代码保存在一个或 *多个* 以 =.go= 为文件后缀名的源文件中，
   通常一个包所在目录路径的后缀是包的导入路径，例如包 =gopl.io/ch1/helloworld= 对应的目录路径是 =$GOPATH/src/gopl.io/ch1/helloworld=.

   每个包都对应一个独立的名字空间。例如，在 =image= 包中的 =Decode= 函数和在 =unicode/utf16= 包中的 =Decode= 函数是不同的。
   要在外部引用该函数，必须显式使用 =image.Decode= 或 =utf16.Decode= 形式访问。

   包还可以让我们通过控制哪些名字是外部可见的来隐藏内部实现信息。在 Go 语言中，一个简单的规则是：如果一个名字是大写字母开头的，
   那么该名字是导出的（因为汉字不区分大小写，因此汉字开头的名字是没有导出的）。

   #+begin_comment
   一般也不会用中文来命名吧……
   #+end_comment

   在 Go 语言程序中，每个包都有一个全局唯一的导入路径。导入语句中类似 "gopl.io/ch2/tempconv" 的字符串对应包的导入路径。
   Go 语言的规范并没有定义这些字符串的具体含义或包来自哪里，它们是由 *构建工具* 来解释的。
   #+begin_quote
   当使用 Go 语言自带的 go 工具箱时，一个导入路径代表一个目录中的一个或多个 Go 源文件。
   #+end_quote

   除了包的导入路径，每个包还有一个包名，包名一般是短小的名字（并不要求包名是唯一的），包名在包的声明处指定。按照惯例，
   一个包的名字和包的导入路径的最后一个字段相同，例如 =gopl.io/ch2/tempconv= 包的名字一般是 =tempconv=.

   包的初始化首先是解决包级变量的依赖顺序，然后按照包级变量声明出现的顺序依次初始化：
   #+begin_src go
     var a = b + c // a 第三个初始化, 为 3
     var b = f()   // b 第二个初始化, 为 2, 通过调用 f (依赖c)
     var c = 1     // c 第一个初始化, 为 1

     func f() int { return c + 1 }
   #+end_src

   如果包中含有多个 =.go= 源文件，它们将按照发给编译器的顺序进行初始化，Go 语言的构建工具首先会将 =.go= 文件根据文件名排序，然后依次调用编译器编译。

   对于在包级别声明的变量，如果有初始化表达式则用表达式初始化，还有一些没有初始化表达式的，可以用一个特殊的 =init= 初始化函数来简化初始化工作。
   每个文件都可以包含多个 =init= 初始化函数，这样的 =init= 初始化函数除了不能被调用或引用外，其他行为和普通函数类似。
   在每个文件中的 =init= 初始化函数，在程序开始执行时按照它们声明的顺序被自动调用。
   #+begin_src go
     func init() { /* ... */ }
   #+end_src

   比如，具有复杂初始化逻辑的包级变量的初始化：
   #+begin_src go
     var pc [256]byte

     func init() {
         for i := range pc {
             pc[i] = pc[i/2] + byte(i&1)
         }
     }
   #+end_src

   但也可以将初始化逻辑包装为一个匿名函数来进行处理：
   #+begin_src go
     var pc [256]byte = func() (pc [256]byte) {
         for i := range pc {
             pc[i] = pc[i/2] + byte(i&1)
         }
         return
     }()
   #+end_src

   每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次。因此，如果一个 =p= 包导入了 =q= 包，那么在 =p= 包初始化的时候可以认为 =q= 包必然已经初始化过了。
   初始化工作是自下而上进行的，main 包最后被初始化。以这种方式，可以确保在 =main= 函数执行之前，所有依赖的包都已经完成初始化工作了。

** 作用域
   Go 语言存在块级作用域，同时，按照由内到外的查找规则，内部作用域的名字可以覆盖外部作用域的名字：
   #+begin_src go
     func main() {
       a := 10
       {
         a := 100
         fmt.Println(a)  // 100
       }
       fmt.Println(a)      // 10
     }

   #+end_src

   Go 中的作用域大致可以分为如下几个级别：
   #+begin_src go
     全局作用域 -> 包级作用域 -> 函数作用域 -> 块级作用域
   #+end_src

   虽然说块级作用域挺好的，但有时候又希望它不存在，如果可以由用户来控制就好了，比如循环体上的变量。

* 数据类型
  Go 语言将数据类型分为四类：基础类型、复合类型、引用类型和接口类型。

** 基础类型
   通常，基础类型就是数值类型，但是，在这点上，Go 的风格更加接近 C 语言，因为，Go 中的字符串也是基础类型。
   
   + 整型 ::
     Go 语言同时提供了有符号和无符号类型的整数，主要有：
     #+begin_example
       int  int8  int16  int32  int64
       uint uint8 uint16 uint32 uint64
     #+end_example

     其中，类型 =int= 和 =uint= 的宽度可能是 =32= 或 =64= 位，由编译器和平台决定。

     同时，还存在一些其他的和整数类型相关的类型：
     #+begin_example
       byte     // alias for uint8
       rune     // alias for int32, represents a Unicode code point
       uintptr
     #+end_example

     下面是 Go 语言中关于算术运算、逻辑运算和比较运算的二元运算符，它们按照优先级递减的顺序排列：
     #+begin_example
       ,*      /      %      <<       >>     &       &^
       +      -      |      ^
       ==     !=     <      <=       >      >=
       &&
       ||
     #+end_example

     其中，算术运算符 +、-、* 和 / 可以适用于整数、浮点数和复数，但是取模运算符 % 仅用于整数间的运算，同时，
     在 Go 语言中，% 取模运算符的符号和被取模数的符号总是一致的，因此 -5 % 3 和 -5 % -3 结果都是 -2。
     
     Go 语言中提供了一个 =&^= 位运算操作符，作用为：如果对应 y 中 bit 位为 1 的话, 表达式 z = x &^ y 结果 z 的对应的 bit 位为 0，
     否则 z 对应的 bit 位等于 x 相应的 bit 位的值。

   + 浮点数 :: 
     Go 中提供了 =float32= 和 =float64= 两个浮点数类型，剩下感觉没啥好说的了。

   + 复数 :: 
     Go 是原生支持复数这一数值类型的语言，提供了 =complex64= 和 =complex128= 两个精度。内置的 =complex= 函数用于构建复数，
     内建的 =real= 和 =imag= 函数分别返回复数的实部和虚部：
     #+begin_src go
       var x complex128 = complex(1, 2) // 1+2i
       var y complex128 = complex(3, 4) // 3+4i
       fmt.Println(x*y)                 // "(-5+10i)"
       fmt.Println(real(x*y))           // "-5"
       fmt.Println(imag(x*y))           // "10"
     #+end_src

   + 布尔型 :: 
     布尔类型没啥好说的，只有 =true= 和 =false= 这两个值，存在短路行为，OVER。

   + 字符串 :: 
     字符串是一个不可改变的字节序列，可以包含任意的数据，包括 byte 值 0。文本字符串通常被解释为采用 UTF8 编码的 Unicode 码点（rune）序列。

     内置的 len 函数可以返回一个字符串中的 *字节* 数目（不是 rune 字符数目），索引操作 =s[i]= 返回第 =i= 个 *字节* 的字节值。

     字符串可以用比较运算符进行比较，比较通过逐个 *字节* 比较完成，因此比较的结果是字符串自然编码的顺序。
     也可以使用 =+= 操作符完成字符串拼接操作，但是只能拼接字符串或字符串切片。
     
     字符串的不变性意味如果两个字符串共享相同的底层数据的话也是安全的，这使得复制任何长度的字符串代价是低廉的。同样，
     一个字符串 =s= 和对应的子字符串切片 =s[7:]= 的操作也可以安全地共享相同的内存，因此字符串切片操作代价也是低廉的。
     在这两种情况下都没有必要分配新的内存。
     
     如图：
     #+HTML: <img src="https://books.studygolang.com/gopl-zh/images/ch3-04.png">

     字符串的字面量形式和其他语言差不多，值得注意的是，Go 中存在类似 Python 中的原生字符串：
     #+begin_src go
       `This is a raw string.

       Yes, new line.

       \\\\\\\\\\
       `
     #+end_src

     Go 语言的 range 循环在处理字符串的时候，会自动隐式解码 UTF8 字符串（为什么字符串要设计成字节数组呢？）：
     #+HTML: <img src="https://books.studygolang.com/gopl-zh/images/ch3-05.png">

     PS: Go 在遇到一个错误的 UTF8 编码输入时会将生成一个特别的 Unicode 字符 \uFFFD。

     UTF8 字符串作为交换格式是非常方便的，但是在程序内部采用 rune 序列可能更方便，因为 rune 大小一致，支持数组索引和方便切割。
     将 =[]rune= 类型转换应用到 =UTF8= 编码的字符串，将返回字符串编码的 =Unicode= 码点序列：
     #+begin_src go
       // "program" in Japanese katakana
       s := "プログラム"
       fmt.Printf("% x\n", s) // "e3 83 97 e3 83 ad e3 82 b0 e3 83 a9 e3 83 a0"
       r := []rune(s)
       fmt.Printf("%x\n", r)  // "[30d7 30ed 30b0 30e9 30e0]"
     #+end_src

     如果是将一个 =[]rune= 类型的 Unicode 字符 =slice= 或数组转为 string，则对它们进行 UTF8 编码：
     #+begin_src go
       fmt.Println(string(r)) // "プログラム"
     #+end_src

     将一个整数转型为字符串意思是生成以只包含对应 Unicode 码点字符的 UTF8 字符串，如果对应码点的字符是无效的，
     则用 \uFFFD 无效字符作为替换：
     #+begin_src go
       fmt.Println(string(65))     // "A", not "65"
       fmt.Println(string(0x4eac)) // "京"
       fmt.Println(string(1234567)) // "�"
     #+end_src
     
     字符串是包含的只读字节数组，一旦创建，是不可变的。相比之下，字节切片的元素则可以自由地修改，两者可以相互转换：
     #+begin_src go
       s := "abc"
       b := []byte(s)
       s2 := string(b)
     #+end_src

     从概念上讲，一个 =[]byte(s)= 转换是分配了一个新的字节数组用于保存字符串数据的拷贝，然后引用这个底层的字节数组。
     编译器的优化可以避免在一些场景下分配和复制字符串数据，但总的来说需要确保在变量 b 被修改的情况下，
     原始的 s 字符串也不会改变。将一个字节切片转到字符串的 =string(b)= 操作则是构造一个字符串拷贝，
     以确保 s2 字符串是只读的。

     为了避免转换中不必要的内存分配，bytes 包和 strings 同时提供了许多实用函数：
     #+begin_src go
       // package string
       func Contains(s, substr string) bool
       func Count(s, sep string) int
       func Fields(s string) []string
       func HasPrefix(s, prefix string) bool
       func Index(s, sep string) int
       func Join(a []string, sep string) string

       // package bytes
       func Contains(b, subslice []byte) bool
       func Count(s, sep []byte) int
       func Fields(s []byte) [][]byte
       func HasPrefix(s, prefix []byte) bool
       func Index(s, sep []byte) int
       func Join(s [][]byte, sep []byte) []byte
     #+end_src

     它们之间唯一的区别是字符串类型参数被替换成了字节切片类型的参数。

     bytes 包还提供了 Buffer 类型用于字节 slice 的缓存。一个 Buffer 开始是空的，但是随着 string、byte 或 []byte 等类型数据的写入可以动态增长，
     一个 bytes.Buffer 变量并不需要初始化，因为零值也是有效的：
     #+begin_src go
       // intsToString is like fmt.Sprint(values) but adds commas.
       func intsToString(values []int) string {
           var buf bytes.Buffer
           buf.WriteByte('[')
           for i, v := range values {
               if i > 0 {
                   buf.WriteString(", ")
               }
               fmt.Fprintf(&buf, "%d", v)
           }
           buf.WriteByte(']')
           return buf.String()
       }

       func main() {
           fmt.Println(intsToString([]int{1, 2, 3})) // "[1, 2, 3]"
       }
     #+end_src

     标准库中对字符串处理尤为重要的四个包：bytes、strings、strconv 和 unicode。

   + 常量 :: 
     常量表达式的值在编译期计算，而不是在运行期（常见的编译期优化操作）。每种常量的潜在类型都是基础类型：boolean、string 或数字。

     常量间的所有算术运算、逻辑运算和比较运算的结果也是常量，对常量的类型转换操作或以下函数调用都是返回常量结果：
     + len、cap、real、imag、complex 和 unsafe.Sizeof
       
     因为它们的值是在编译期就确定的，因此常量可以是构成类型的一部分，例如用于指定数组类型的长度（Go 中动态声明二维数组也太恶心了）：
     #+begin_src go
       const IPv4Len = 4

       // parseIPv4 parses an IPv4 address (d.d.d.d).
       func parseIPv4(s string) IP {
           var p [IPv4Len]byte
           // ...
       }
     #+end_src

     如果是批量声明的常量，除了第一个外其它的常量右边的初始化表达式都可以省略，如果省略初始化表达式则表示使用前面常量的初始化表达式写法，
     对应的常量类型也一样的。例如：
     #+begin_src go
       const (
           a = 1
           b
           c = 2
           d
       )

       fmt.Println(a, b, c, d) // "1 1 2 2"
     #+end_src

     这个特性可以让我们使用 iota 常量生成器，它用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式。在一个 const 声明语句中，
     在第一个声明的常量所在的行，iota 将会被置为 0，然后在每一个有常量声明的行加一。
     
     可以将其用在复杂的表达式中：
     #+begin_src go
       const (
           _ = 1 << (10 * iota)
           KiB // 1024
           MiB // 1048576
           GiB // 1073741824
           TiB // 1099511627776             (exceeds 1 << 32)
           PiB // 1125899906842624
           EiB // 1152921504606846976
           ZiB // 1180591620717411303424    (exceeds 1 << 64)
           YiB // 1208925819614629174706176
       )
     #+end_src

     当常量没有一个确定的基础类型时，编译器为这些没有明确的基础类型的数字常量提供比基础类型更高精度的算术运算，主要包括：
     + 无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串

     通过延迟明确常量的具体类型，无类型的常量不仅可以提供更高的运算精度，而且可以直接用于更多的表达式而不需要显式的类型转换：
     #+begin_src go
       var x float32 = math.Pi
       var y float64 = math.Pi
       var z complex128 = math.Pi
     #+end_src
     
     对于常量面值，不同的写法可能会对应不同的类型。例如 0、0.0、0i 和 \u0000 虽然有着相同的常量值，但是它们分别对应无类型的整数、
     无类型的浮点数、无类型的复数和无类型的字符等不同的常量类型。同样，true 和 false 也是无类型的布尔类型，
     字符串面值常量是无类型的字符串类型。

     同时，除法运算符 =/= 会根据操作数的类型生成对应类型的结果。因此，不同写法的 *常量除法表达式* 可能对应不同的结果：
     #+begin_src go
       var f float64 = 212
       fmt.Println((f - 32) * 5 / 9)     // "100"; (f - 32) * 5 is a float64
       fmt.Println(5 / 9 * (f - 32))     // "0";   5/9 is an untyped integer, 0
       fmt.Println(5.0 / 9.0 * (f - 32)) // "100"; 5.0/9.0 is an untyped float
     #+end_src

     只有常量可以是无类型的。当一个无类型的常量被赋值给一个变量的时候，无类型的常量将会被隐式转换为对应的类型，如果转换合法的话：
     #+begin_src go
       var f float64 = 3 + 0i // untyped complex -> float64
       f = 2                  // untyped integer -> float64
       f = 1e123              // untyped floating-point -> float64
       f = 'a'                // untyped rune -> float64
     #+end_src

     无论是隐式或显式转换，将一种类型转换为另一种类型都要求目标可以表示原始值。对于浮点数和复数，可能会有舍入处理：
     #+begin_src go
       const (
           deadbeef = 0xdeadbeef // untyped int with value 3735928559
           a = uint32(deadbeef)  // uint32 with value 3735928559
           b = float32(deadbeef) // float32 with value 3735928576 (rounded up)
           c = float64(deadbeef) // float64 with value 3735928559 (exact)
           d = int32(deadbeef)   // compile error: constant overflows int32
           e = float64(1e309)    // compile error: constant overflows float64
           f = uint(-1)          // compile error: constant underflows uint
       )
     #+end_src

     对于一个没有显式类型的变量声明（包括简短变量声明），常量的形式将隐式决定变量的默认类型，就像下面的例子：
     #+begin_src go
       i := 0      // untyped integer;        implicit int(0)
       r := '\000' // untyped rune;           implicit rune('\000')
       f := 0.0    // untyped floating-point; implicit float64(0.0)
       c := 0i     // untyped complex;        implicit complex128(0i)
     #+end_src

     常量的默认类型：
     #+begin_src go
       fmt.Printf("%T\n", 0)      // "int"
       fmt.Printf("%T\n", 0.0)    // "float64"
       fmt.Printf("%T\n", 0i)     // "complex128"
       fmt.Printf("%T\n", '\000') // "int32" (rune)
     #+end_src

   + 字符 ::
     Go 语言中没有专门的字符类型，如果要存储单个字符（字母），一般使用 byte 来保存。字符串就是一串固定长度的字符连接起来的字符序列。
     Go 的字符串是由单个字节连接起来的。也就是说对于传统的字符串是由字符组成的，而 Go 的字符串不同，它是由字节组成的。

     #+begin_src go
       var chr = 'c'
     #+end_src

** 引用类型
   + 指针 ::
     Go 中存在指针，和 C 语言不同的是：
     1. Go 语言中的指针是不能偏移的，不能像 C 语言中那样，拿到个指针就可以到处飘了
     2. Go 语言中返回函数中局部变量的地址也是安全的
     
     这就使得下面这个操作的含义和 C 语言中的不一样，C 语言中是让指针 p 的值发生偏移，但是 Go 中是让 p 指向的变量的值加一：
     #+begin_src go
       func incr(p *int) int {
           ,*p++
           return *p
       }
     #+end_src
     
     可以通过内建函数 =new= 创建变量，表达式 =new(T)= 将创建一个 =T= 类型的匿名变量，初始化为 =T= 类型的零值，然后返回变量地址，类型为 =*T= 的指针，
     一定程度上等价于如下函数：
     #+begin_src go
       func newInt() *int {
           var dummy int
           return &dummy
       }
     #+end_src
   
