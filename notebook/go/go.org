#+TITLE:      GoLang

* 目录                                                    :TOC_4_gh:noexport:
- [[#go-语言起源][Go 语言起源]]
- [[#基本语法][基本语法]]
  - [[#分号][分号]]
  - [[#控制流][控制流]]
  - [[#range][range]]
- [[#程序结构][程序结构]]
  - [[#命名][命名]]
  - [[#声明][声明]]
  - [[#包和文件][包和文件]]
  - [[#作用域][作用域]]
- [[#数据类型][数据类型]]
  - [[#基础类型][基础类型]]
  - [[#复合类型][复合类型]]
  - [[#引用类型][引用类型]]
- [[#函数][函数]]
- [[#异常][异常]]
- [[#方法][方法]]
- [[#接口][接口]]
- [[#并发][并发]]

* Go 语言起源
  Go 语言的设计主要受到 CSP、Pascal 和 C 三个分支的影响，其中，CSP 只是一个用于描述并发性基本概念的描述语言，
  并不是一个可以编写可执行程序的通用编程语言。
  
  在 CSP 中，程序是一组中间没有共享状态的平行运行的处理过程，它们之间使用 *管道* 进行通信和控制同步。

  #+HTML: <img src="https://books.studygolang.com/gopl-zh/images/ch0-01.png">
  
  Go 语言的设计虽然参考了其他语言，但是，本身的设计上是很简单的，也就是说，缺少一些在其他语言中很常见的特性。例如，
  它没有隐式的数值转换，没有构造函数和析构函数，没有运算符重载，没有默认参数，也没有继承，没有泛型，没有异常，
  没有宏，没有函数修饰，更没有线程局部存储。

  这体现了 Go 语言的一个设计哲学——少即是多（感觉某些时候会很蛋疼）

  可以参考：
  + [[https://en.wikipedia.org/wiki/Communicating_sequential_processes][Communicating sequential processes - Wikipedia]]
  + [[https://books.studygolang.com/gopl-zh/ch0/ch0-01.html][Go语言起源 | Go语言圣经]]
  + [[https://books.studygolang.com/gopl-zh/ch0/ch0-02.html][Go语言项目 | Go语言圣经]]

* 基本语法
** 分号
   Go 语言不需要在语句或者声明的末尾添加分号，除非一行上有多条语句，因为编译器会主动把特定符号后的换行符转换为分号，主要包括以下情况：
   + 行末是标识符、整数、浮点数、虚数、字符或字符串文字、关键字 break、continue、fallthrough 或 return 中的一个
   + 行末是运算符和分隔符 ++、--、)、] 或 } 中的一个

   #+begin_src go
     f(
       a(), b(), c()   // error
     )

     f(
       a(), b(), c(),  // ok
     )
   #+end_src

** 控制流
   Go 语言里面 =for= 循环就是唯一的循环控制语句了，几个特点：
   + 由 init statement、condition expression 和 post statement 组成
   + 总是有大括号但是没有小括号：
     #+begin_src go
       for i := 0; i < 10; i++ {
         sum += i
       }
     #+end_src
   + 循环语句上声明的变量作用域仅限于循环语句内部
   + init statement 和 post statement 是可选的：
     #+begin_src go
       for ; sum < 1000; {
         sum += sum
       }
     #+end_src

     删除分号就约等于 =while= 语句了：
     #+begin_src go
       for sum < 1000 {
         sum += sum
       }
     #+end_src
     
     啥都不要就是死循环：
     #+begin_src go
       for {
       }
     #+end_src

   条件判断语句 =if= 也不要小括号但是要大括号：
   #+begin_src go
     func sqrt(x float64) string {
       if x < 0 {
         return sqrt(-x) + "i"
       }
       return fmt.Sprint(math.Sqrt(x))
     }
   #+end_src

   条件表达式前面可以有一个短语句，如果是声明变量，那么作用域仅限于条件语句：
   #+begin_src go
     if v := math.Pow(x, n); v < lim {
       return v
     }
   #+end_src

   作用域是包括 =else= 块的：
   #+begin_src go
     if v := math.Pow(x, n); v < lim {
       return v
     } else {
       fmt.Printf("%g >= %g\n", v, lim)
     }
   #+end_src

   Go 语言支持 =switch= 语句：
   #+begin_src go
     switch os := runtime.GOOS; os {
     case "darwin":
       fmt.Println("OS X.")
     case "linux":
       fmt.Println("Linux.")
     default:
       // freebsd, openbsd,
       // plan9, windows...
       fmt.Printf("%s.\n", os)
     }
   #+end_src
   
   但是它的 =case= 可以是表达式：
   #+begin_src go
     switch time.Saturday {
     case today + 0:
       fmt.Println("Today.")
     case today + 1:
       fmt.Println("Tomorrow.")
     case today + 2:
       fmt.Println("In two days.")
     default:
       fmt.Println("Too far away.")
     }
   #+end_src

   因此，可以不要条件：
   #+begin_src go
     switch {
     case t.Hour() < 12:
       fmt.Println("Good morning!")
     case t.Hour() < 17:
       fmt.Println("Good afternoon.")
     default:
       fmt.Println("Good evening.")
     }
   #+end_src   

   同时，比较特殊的是，Go 中匹配一个 case 项后不会自动执行后面的 case 项，除非使用了 =fallthrough= 关键字：
   #+begin_src go
     switch (v) {
     case 1:
       fmt.Println(1)
       fallthrough
     case 2:
       fmt.Println(2)
     }
   #+end_src

   PS：感觉 =break= 的方式更加符合使用习惯才对……

   defer 语句将函数的执行推迟到函数返回之前，但是参数还是会立即计算出来：
   #+begin_src go
     defer fmt.Println("world")

     fmt.Println("hello")
   #+end_src

   多个 defer 函数调用：
   #+begin_src go
     func main() {
       fmt.Println("counting")

       for i := 0; i < 10; i++ {
         defer fmt.Println(i)
       }

       fmt.Println("done")
     }
   #+end_src

   运行结果为，可以看到是后进先出的：
   #+begin_example
     counting
     done
     9
     8
     7
     6
     5
     4
     3
     2
     1
     0
   #+end_example

   更多可以参考：
   + [[https://blog.golang.org/defer-panic-and-recover][Defer, Panic, and Recover - The Go Blog]]

** range
   range 可以用于 =for= 循环迭代切片、数组和 =Map= 的索引和值：
   #+begin_src go
     for i, v := range pow {
       fmt.Printf("2**%d = %d\n", i, v)
     }
   #+end_src

   忽略另一个值：
   #+begin_src go
     pow := make([]int, 10)
     for i := range pow {
       pow[i] = 1 << uint(i) // == 2**i
     }
     for _, value := range pow {
       fmt.Printf("%d\n", value)
     }
   #+end_src
   
   PS: _ 是不能作为值使用的……

* 程序结构
** 命名
   Go 语言中标识符必须以字母（Unicode 字母）或下划线开头，后面跟任意数量的字母、数组或下划线，大小写敏感。

   关键字和内建名字有：
   #+begin_example
     Keywords:
         break      default       func     interface   select
         case       defer         go       map         struct
         chan       else          goto     package     switch
         const      fallthrough   if       range       type
         continue   for           import   return      var

     Built-in Constants:
         true false iota nil

     Built-in Types:
         int     int8    int16      int32     int64
         uint    uint8   uint16     uint32    uint64 uintptr
         float32 float64 complex128 complex64
         bool    byte    rune       string    error

     Built-in Functions:
         make    len     cap  new append copy close delete
         complex real    imag
         panic   recover
   #+end_example
  
   #+begin_quote
   内建名字可以被从新定义，但是也要注意避免过度而引起语义混乱。
   #+end_quote

   如果一个名字是在函数内部定义，那么它的就只在函数内部有效。如果是在函数外部定义，那么将在当前包的所有文件中都可以访问。
   名字的开头字母的大小写决定了名字在包外的可见性。如果一个名字是大写字母开头的，那么它将是导出的。

   名字的长度没有逻辑限制，但是 Go 语言的风格是尽量使用短小的名字，对于局部变量尤其是这样。

   #+begin_comment
   a, b, c, d, e...?
   #+end_comment
  
   同时，在习惯上，Go 语言程序员推荐使用 *驼峰式* 命名，当名字有几个单词组成的时优先使用大小写分隔，而不是优先用下划线分隔。
  
** 声明
   声明语句定义了程序的各种实体对象以及部分或全部的属性。Go 语言主要有四种类型的声明语句：var、const、type 和 func，
   分别对应变量、常量、类型和函数实体对象的声明。

   Go 语言编写的程序对应一个或多个以 =.go= 为文件后缀名的源文件中。每个源文件以包的声明语句开始，说明该源文件是属于哪个包。
   包声明语句之后是 =import= 语句导入依赖的其它包，然后是包一级的类型、变量、常量、函数的声明语句，
   包一级的各种类型的声明语句的顺序无关紧要（函数内部的名字则必须先声明之后才能使用）。
   #+begin_src go
     // =============================================================================
     // package declare
     // =============================================================================

     package main

     // =============================================================================
     // import statement
     // =============================================================================

     import "fmt"

     // =============================================================================
     // package-level declarations of types, variables, constants, and functions
     // =============================================================================

     func main() {
         fmt.Println("Hello, World!")
     }
   #+end_src

   + 变量 ::
     可以通过 =var= 关键字声明变量，类型放在最后面，只能有一个类型：
     #+begin_src go
       var c, python, java bool
     #+end_src
     
     使用初始值是可以通过类型推断自动判断类型，可以有多个类型的值：
     #+begin_src go
       var c, python, java = true, false, "no!"
     #+end_src
     
     可以使用 ~:=~ 代理具有隐式类型声明的 =var= 语句，这需要左值为一个新的变量，由于函数外面的语句必须由关键字开始，因此函数外面无法使用这一语句：
     #+begin_src go
       c, python, java := true, false, "no!"
     #+end_src

     变量的生命周期为：
     + 对于包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的
     + 对于局部变量来说，它们的生命周期为每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收
     + 编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，这由变量的作用域确定，有点类似 Rust 中的所有权
     
     其中，函数的参数变量和返回值变量都是局部变量，它们在函数每次被调用的时候创建。

     可以参考：《Go 程序设计语言 2.3.4 节》

   + 赋值 ::
     Go 语言和 Python 一样，支持元组赋值，这是很棒的一个特性，至少，交换变量值就不需要手动写一个中间变量了：
     #+begin_src go
       x, y = y, x
     #+end_src

     同时，函数可以返回多个值，这些值就是一个元组，这时，左边变量的数目必须和右边函数的返回值数量一致。

     一些特殊的操作返回的值数量受到左值数量的影响,可以通过空白标识符 =_= 来丢弃不需要的值：
     #+begin_src go
       v = m[key]                // map 查找，失败时返回零值
       v = x.(T)                 // type 断言，失败时 panic 异常
       v = <-ch                  // 管道接收，失败时返回零值

       _, ok = m[key]            // map 返回 2 个值
       _, ok = mm[""], false     // map 返回 1 个值
       _ = mm[""]                // map 返回 1 个值
     #+end_src

   + 类型 :: 
     Go 语言中可以通过 *类型声明* 语句来声明类型，但是需要注意的是，Go 语言中的类型和其他一些语言中的类不一样，
     反而更接近 C 语言中的 =typedef= 和结构体：
     #+begin_src go
       type 类型名字 底层类型
     #+end_src

     可以简单的为一个类型添加不同的别名，但是，这些别名属于不同的类型，因此它们不可以被相互比较或混在一个表达式运算。
     #+begin_src go
       type Celsius float64     // 摄氏温度
       type Fahrenheit float64  // 华氏温度
     #+end_src

     Go 语言不允许隐式类型转换，只能使用 =T(v)= 表达式完成类型转换，只有当两个类型的底层基础类型相同时，才允许这种转型操作，
     或者是两者都是指向相同底层结构的指针类型，这些转换只改变类型而不会影响值本身。
     
     当然，数值类型之间的转型是被允许的，并且在字符串和一些特定类型的 =slice= 之间也是可以转换的。
     #+begin_src go
       (*int)(0)  // Convert to *int
     #+end_src

     底层数据类型决定了内部结构和表达方式，也决定是否可以像底层类型一样对内置运算符的支持：
     #+begin_src go
       var v Celsius = 1.0
       v += 1
     #+end_src

     比较运算符以用来比较一个命名类型的变量和另一个有相同类型的变量，或有着 *相同底层类型* 的 *未命名类型的值* 之间做比较，
     但是如果两个值有着不同的类型，则不能直接进行比较：
     #+begin_src go
       var c Celsius
       var f Fahrenheit
       fmt.Println(c == 0)           // "true"
       fmt.Println(f >= 0)           // "true"
       fmt.Println(c == f)           // compile error: type mismatch
       fmt.Println(c == Celsius(f))  // "true"!
     #+end_src

     C 语言中 =typedef= 更像是一个别名，实际上还是同一个类型，而 Go 语言中的 =type= 则是定义了一个新类型。

** 包和文件
   每个 ~Go~ 程序都由 ~package~ 组成，程序从 =main= 包开始运行，Go 语言中一个包的源代码保存在一个或 *多个* 以 =.go= 为文件后缀名的源文件中，
   通常一个包所在目录路径的后缀是包的导入路径，例如包 =gopl.io/ch1/helloworld= 对应的目录路径是 =$GOPATH/src/gopl.io/ch1/helloworld=.

   每个包都对应一个独立的名字空间。例如，在 =image= 包中的 =Decode= 函数和在 =unicode/utf16= 包中的 =Decode= 函数是不同的。
   要在外部引用该函数，必须显式使用 =image.Decode= 或 =utf16.Decode= 形式访问。

   包还可以让我们通过控制哪些名字是外部可见的来隐藏内部实现信息。在 Go 语言中，一个简单的规则是：如果一个名字是大写字母开头的，
   那么该名字是导出的（因为汉字不区分大小写，因此汉字开头的名字是没有导出的）。

   #+begin_comment
   一般也不会用中文来命名吧……
   #+end_comment

   在 Go 语言程序中，每个包都有一个全局唯一的导入路径。导入语句中类似 "gopl.io/ch2/tempconv" 的字符串对应包的导入路径。
   Go 语言的规范并没有定义这些字符串的具体含义或包来自哪里，它们是由 *构建工具* 来解释的。
   #+begin_quote
   当使用 Go 语言自带的 go 工具箱时，一个导入路径代表一个目录中的一个或多个 Go 源文件。
   #+end_quote

   除了包的导入路径，每个包还有一个包名，包名一般是短小的名字（并不要求包名是唯一的），包名在包的声明处指定。按照惯例，
   一个包的名字和包的导入路径的最后一个字段相同，例如 =gopl.io/ch2/tempconv= 包的名字一般是 =tempconv=.

   包的初始化首先是解决包级变量的依赖顺序，然后按照包级变量声明出现的顺序依次初始化：
   #+begin_src go
     var a = b + c // a 第三个初始化, 为 3
     var b = f()   // b 第二个初始化, 为 2, 通过调用 f (依赖c)
     var c = 1     // c 第一个初始化, 为 1

     func f() int { return c + 1 }
   #+end_src

   如果包中含有多个 =.go= 源文件，它们将按照发给编译器的顺序进行初始化，Go 语言的构建工具首先会将 =.go= 文件根据文件名排序，然后依次调用编译器编译。

   对于在包级别声明的变量，如果有初始化表达式则用表达式初始化，还有一些没有初始化表达式的，可以用一个特殊的 =init= 初始化函数来简化初始化工作。
   每个文件都可以包含多个 =init= 初始化函数，这样的 =init= 初始化函数除了不能被调用或引用外，其他行为和普通函数类似。
   在每个文件中的 =init= 初始化函数，在程序开始执行时按照它们声明的顺序被自动调用。
   #+begin_src go
     func init() { /* ... */ }
   #+end_src

   比如，具有复杂初始化逻辑的包级变量的初始化：
   #+begin_src go
     var pc [256]byte

     func init() {
         for i := range pc {
             pc[i] = pc[i/2] + byte(i&1)
         }
     }
   #+end_src

   但也可以将初始化逻辑包装为一个匿名函数来进行处理：
   #+begin_src go
     var pc [256]byte = func() (pc [256]byte) {
         for i := range pc {
             pc[i] = pc[i/2] + byte(i&1)
         }
         return
     }()
   #+end_src

   每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次。因此，如果一个 =p= 包导入了 =q= 包，那么在 =p= 包初始化的时候可以认为 =q= 包必然已经初始化过了。
   初始化工作是自下而上进行的，main 包最后被初始化。以这种方式，可以确保在 =main= 函数执行之前，所有依赖的包都已经完成初始化工作了。

** 作用域
   Go 语言存在块级作用域，同时，按照由内到外的查找规则，内部作用域的名字可以覆盖外部作用域的名字：
   #+begin_src go
     func main() {
       a := 10
       {
         a := 100
         fmt.Println(a)  // 100
       }
       fmt.Println(a)      // 10
     }

   #+end_src

   Go 中的作用域大致可以分为如下几个级别：
   #+begin_src go
     全局作用域 -> 包级作用域 -> 函数作用域 -> 块级作用域
   #+end_src

   虽然说块级作用域挺好的，但有时候又希望它不存在，如果可以由用户来控制就好了，比如循环体上的变量。

* 数据类型
  Go 语言将数据类型分为四类：基础类型、复合类型、引用类型和接口类型。

** 基础类型
   通常，基础类型就是数值类型，但是，在这点上，Go 的风格更加接近 C 语言，因为，Go 中的字符串也是基础类型。
   
   + 整型 ::
     Go 语言同时提供了有符号和无符号类型的整数，主要有：
     #+begin_example
       int  int8  int16  int32  int64
       uint uint8 uint16 uint32 uint64
     #+end_example

     其中，类型 =int= 和 =uint= 的宽度可能是 =32= 或 =64= 位，由编译器和平台决定。

     同时，还存在一些其他的和整数类型相关的类型：
     #+begin_example
       byte     // alias for uint8
       rune     // alias for int32, represents a Unicode code point
       uintptr
     #+end_example

     下面是 Go 语言中关于算术运算、逻辑运算和比较运算的二元运算符，它们按照优先级递减的顺序排列：
     #+begin_example
       ,*      /      %      <<       >>     &       &^
       +      -      |      ^
       ==     !=     <      <=       >      >=
       &&
       ||
     #+end_example

     其中，算术运算符 +、-、* 和 / 可以适用于整数、浮点数和复数，但是取模运算符 % 仅用于整数间的运算，同时，
     在 Go 语言中，% 取模运算符的符号和被取模数的符号总是一致的，因此 -5 % 3 和 -5 % -3 结果都是 -2。
     
     Go 语言中提供了一个 =&^= 位运算操作符，作用为：如果对应 y 中 bit 位为 1 的话, 表达式 z = x &^ y 结果 z 的对应的 bit 位为 0，
     否则 z 对应的 bit 位等于 x 相应的 bit 位的值。

   + 浮点数 :: 
     Go 中提供了 =float32= 和 =float64= 两个浮点数类型，剩下感觉没啥好说的了。

   + 复数 :: 
     Go 是原生支持复数这一数值类型的语言，提供了 =complex64= 和 =complex128= 两个精度。内置的 =complex= 函数用于构建复数，
     内建的 =real= 和 =imag= 函数分别返回复数的实部和虚部：
     #+begin_src go
       var x complex128 = complex(1, 2) // 1+2i
       var y complex128 = complex(3, 4) // 3+4i
       fmt.Println(x*y)                 // "(-5+10i)"
       fmt.Println(real(x*y))           // "-5"
       fmt.Println(imag(x*y))           // "10"
     #+end_src

   + 布尔型 :: 
     布尔类型没啥好说的，只有 =true= 和 =false= 这两个值，存在短路行为，OVER。

   + 字符串 :: 
     字符串是一个不可改变的字节序列，可以包含任意的数据，包括 byte 值 0。文本字符串通常被解释为采用 UTF8 编码的 Unicode 码点（rune）序列。

     内置的 len 函数可以返回一个字符串中的 *字节* 数目（不是 rune 字符数目），索引操作 =s[i]= 返回第 =i= 个 *字节* 的字节值。

     字符串可以用比较运算符进行比较，比较通过逐个 *字节* 比较完成，因此比较的结果是字符串自然编码的顺序。
     也可以使用 =+= 操作符完成字符串拼接操作，但是只能拼接字符串或字符串切片。
     
     字符串的不变性意味如果两个字符串共享相同的底层数据的话也是安全的，这使得复制任何长度的字符串代价是低廉的。同样，
     一个字符串 =s= 和对应的子字符串切片 =s[7:]= 的操作也可以安全地共享相同的内存，因此字符串切片操作代价也是低廉的。
     在这两种情况下都没有必要分配新的内存。
     
     如图：
     #+HTML: <img src="https://books.studygolang.com/gopl-zh/images/ch3-04.png">

     字符串的字面量形式和其他语言差不多，值得注意的是，Go 中存在原生字符串，可以换行，不处理转义：
     #+begin_src go
       `This is a raw string.

       Yes, new line.

       \\\\\\\\\\
       `
     #+end_src

     Go 语言的 range 循环在处理字符串的时候，会自动隐式解码 UTF8 字符串（为什么字符串要设计成字节数组呢？）：
     #+HTML: <img src="https://books.studygolang.com/gopl-zh/images/ch3-05.png">

     PS: Go 在遇到一个错误的 UTF8 编码输入时会将生成一个特别的 Unicode 字符 \uFFFD。

     UTF8 字符串作为交换格式是非常方便的，但是在程序内部采用 rune 序列可能更方便，因为 rune 大小一致，支持数组索引和方便切割。
     将 =[]rune= 类型转换应用到 =UTF8= 编码的字符串，将返回字符串编码的 =Unicode= 码点序列：
     #+begin_src go
       // "program" in Japanese katakana
       s := "プログラム"
       fmt.Printf("% x\n", s) // "e3 83 97 e3 83 ad e3 82 b0 e3 83 a9 e3 83 a0"
       r := []rune(s)
       fmt.Printf("%x\n", r)  // "[30d7 30ed 30b0 30e9 30e0]"
     #+end_src

     如果是将一个 =[]rune= 类型的 Unicode 字符 =slice= 或数组转为 string，则对它们进行 UTF8 编码：
     #+begin_src go
       fmt.Println(string(r)) // "プログラム"
     #+end_src

     将一个整数转型为字符串意思是生成以只包含对应 Unicode 码点字符的 UTF8 字符串，如果对应码点的字符是无效的，
     则用 \uFFFD 无效字符作为替换：
     #+begin_src go
       fmt.Println(string(65))     // "A", not "65"
       fmt.Println(string(0x4eac)) // "京"
       fmt.Println(string(1234567)) // "�"
     #+end_src
     
     字符串是包含的只读字节数组，一旦创建，是不可变的。相比之下，字节切片的元素则可以自由地修改，两者可以相互转换：
     #+begin_src go
       s := "abc"
       b := []byte(s)
       s2 := string(b)
     #+end_src

     从概念上讲，一个 =[]byte(s)= 转换是分配了一个新的字节数组用于保存字符串数据的拷贝，然后引用这个底层的字节数组。
     编译器的优化可以避免在一些场景下分配和复制字符串数据，但总的来说需要确保在变量 b 被修改的情况下，
     原始的 s 字符串也不会改变。将一个字节切片转到字符串的 =string(b)= 操作则是构造一个字符串拷贝，
     以确保 s2 字符串是只读的。

     为了避免转换中不必要的内存分配，bytes 包和 strings 同时提供了许多实用函数：
     #+begin_src go
       // package string
       func Contains(s, substr string) bool
       func Count(s, sep string) int
       func Fields(s string) []string
       func HasPrefix(s, prefix string) bool
       func Index(s, sep string) int
       func Join(a []string, sep string) string

       // package bytes
       func Contains(b, subslice []byte) bool
       func Count(s, sep []byte) int
       func Fields(s []byte) [][]byte
       func HasPrefix(s, prefix []byte) bool
       func Index(s, sep []byte) int
       func Join(s [][]byte, sep []byte) []byte
     #+end_src

     它们之间唯一的区别是字符串类型参数被替换成了字节切片类型的参数。

     bytes 包还提供了 Buffer 类型用于字节 slice 的缓存。一个 Buffer 开始是空的，但是随着 string、byte 或 []byte 等类型数据的写入可以动态增长，
     一个 bytes.Buffer 变量并不需要初始化，因为零值也是有效的：
     #+begin_src go
       // intsToString is like fmt.Sprint(values) but adds commas.
       func intsToString(values []int) string {
           var buf bytes.Buffer
           buf.WriteByte('[')
           for i, v := range values {
               if i > 0 {
                   buf.WriteString(", ")
               }
               fmt.Fprintf(&buf, "%d", v)
           }
           buf.WriteByte(']')
           return buf.String()
       }

       func main() {
           fmt.Println(intsToString([]int{1, 2, 3})) // "[1, 2, 3]"
       }
     #+end_src

     标准库中对字符串处理尤为重要的四个包：bytes、strings、strconv 和 unicode。

   + 常量 :: 
     常量表达式的值在编译期计算，而不是在运行期（常见的编译期优化操作）。每种常量的潜在类型都是基础类型：boolean、string 或数字。

     常量间的所有算术运算、逻辑运算和比较运算的结果也是常量，对常量的类型转换操作或以下函数调用都是返回常量结果：
     + len、cap、real、imag、complex 和 unsafe.Sizeof
       
     因为它们的值是在编译期就确定的，因此常量可以是构成类型的一部分，例如用于指定数组类型的长度（Go 中动态声明二维数组也太恶心了）：
     #+begin_src go
       const IPv4Len = 4

       // parseIPv4 parses an IPv4 address (d.d.d.d).
       func parseIPv4(s string) IP {
           var p [IPv4Len]byte
           // ...
       }
     #+end_src

     如果是批量声明的常量，除了第一个外其它的常量右边的初始化表达式都可以省略，如果省略初始化表达式则表示使用前面常量的初始化表达式写法，
     对应的常量类型也一样的。例如：
     #+begin_src go
       const (
           a = 1
           b
           c = 2
           d
       )

       fmt.Println(a, b, c, d) // "1 1 2 2"
     #+end_src

     这个特性可以让我们使用 iota 常量生成器，它用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式。在一个 const 声明语句中，
     在第一个声明的常量所在的行，iota 将会被置为 0，然后在每一个有常量声明的行加一。
     
     可以将其用在复杂的表达式中：
     #+begin_src go
       const (
           _ = 1 << (10 * iota)
           KiB // 1024
           MiB // 1048576
           GiB // 1073741824
           TiB // 1099511627776             (exceeds 1 << 32)
           PiB // 1125899906842624
           EiB // 1152921504606846976
           ZiB // 1180591620717411303424    (exceeds 1 << 64)
           YiB // 1208925819614629174706176
       )
     #+end_src

     当常量没有一个确定的基础类型时，编译器为这些没有明确的基础类型的数字常量提供比基础类型更高精度的算术运算，主要包括：
     + 无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串

     通过延迟明确常量的具体类型，无类型的常量不仅可以提供更高的运算精度，而且可以直接用于更多的表达式而不需要显式的类型转换：
     #+begin_src go
       var x float32 = math.Pi
       var y float64 = math.Pi
       var z complex128 = math.Pi
     #+end_src
     
     对于常量面值，不同的写法可能会对应不同的类型。例如 0、0.0、0i 和 \u0000 虽然有着相同的常量值，但是它们分别对应无类型的整数、
     无类型的浮点数、无类型的复数和无类型的字符等不同的常量类型。同样，true 和 false 也是无类型的布尔类型，
     字符串面值常量是无类型的字符串类型。

     同时，除法运算符 =/= 会根据操作数的类型生成对应类型的结果。因此，不同写法的 *常量除法表达式* 可能对应不同的结果：
     #+begin_src go
       var f float64 = 212
       fmt.Println((f - 32) * 5 / 9)     // "100"; (f - 32) * 5 is a float64
       fmt.Println(5 / 9 * (f - 32))     // "0";   5/9 is an untyped integer, 0
       fmt.Println(5.0 / 9.0 * (f - 32)) // "100"; 5.0/9.0 is an untyped float
     #+end_src

     只有常量可以是无类型的。当一个无类型的常量被赋值给一个变量的时候，无类型的常量将会被隐式转换为对应的类型，如果转换合法的话：
     #+begin_src go
       var f float64 = 3 + 0i // untyped complex -> float64
       f = 2                  // untyped integer -> float64
       f = 1e123              // untyped floating-point -> float64
       f = 'a'                // untyped rune -> float64
     #+end_src

     无论是隐式或显式转换，将一种类型转换为另一种类型都要求目标可以表示原始值。对于浮点数和复数，可能会有舍入处理：
     #+begin_src go
       const (
           deadbeef = 0xdeadbeef // untyped int with value 3735928559
           a = uint32(deadbeef)  // uint32 with value 3735928559
           b = float32(deadbeef) // float32 with value 3735928576 (rounded up)
           c = float64(deadbeef) // float64 with value 3735928559 (exact)
           d = int32(deadbeef)   // compile error: constant overflows int32
           e = float64(1e309)    // compile error: constant overflows float64
           f = uint(-1)          // compile error: constant underflows uint
       )
     #+end_src

     对于一个没有显式类型的变量声明（包括简短变量声明），常量的形式将隐式决定变量的默认类型，就像下面的例子：
     #+begin_src go
       i := 0      // untyped integer;        implicit int(0)
       r := '\000' // untyped rune;           implicit rune('\000')
       f := 0.0    // untyped floating-point; implicit float64(0.0)
       c := 0i     // untyped complex;        implicit complex128(0i)
     #+end_src

     常量的默认类型：
     #+begin_src go
       fmt.Printf("%T\n", 0)      // "int"
       fmt.Printf("%T\n", 0.0)    // "float64"
       fmt.Printf("%T\n", 0i)     // "complex128"
       fmt.Printf("%T\n", '\000') // "int32" (rune)
     #+end_src

   + 字符 ::
     Go 语言中没有专门的字符类型，如果要存储单个字符（字母），一般使用 byte 来保存。字符串就是一串固定长度的字符连接起来的字符序列。
     Go 的字符串是由单个字节连接起来的。也就是说对于传统的字符串是由字符组成的，而 Go 的字符串不同，它是由字节组成的。

     #+begin_src go
       var chr = 'c'
     #+end_src

** 复合类型
   Go 语言中的复合数据类型为数组和结构体，支持结构体这一点感觉很不错。

   + 数组 ::
     数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。数组的每个元素可以通过索引下标来访问，
     索引下标的范围是从 0 开始到数组长度减 1 的位置。内置的 =len= 函数将返回数组中元素的个数。

     数组类型的声明方式，Go 又双叒叕走出来自己的路，大概是这个样子的：
     #+begin_src go
       var a = [4]int{1, 2, 3}    // len 4
       var b = [...]int{1, 2, 3}  // len 3
     #+end_src

     也可以指定一个索引和对应值列表的方式初始化，这样索引的顺序是无关紧要的，而且没用到的索引可以省略，
     未指定初始值的元素将用零值初始化：
     #+begin_src go
       type Currency int

       const (
           USD Currency = iota // 美元
           EUR                 // 欧元
           GBP                 // 英镑
           RMB                 // 人民币
       )

       symbol := [...]string{USD: "$", EUR: "€", GBP: "￡", RMB: "￥"}

       fmt.Println(RMB, symbol[RMB]) // "3 ￥"

       r := [...]int{99: -1}  // len 100
     #+end_src

     这里比较特殊的一点是，数组的长度也是数组类型的一部分，因此 =[3]int= 和 =[4]int= 算是不同的类型。

     如果一个数组的元素类型是可以相互比较的，那么数组类型也可以使用 ~==~ 和 ~!=~ 操作符进行比较。

     需要注意的是，Go 中数组是值类型而非引用类型，因此函数参数是数组时，大数组参数的传递效率可能很低。
     这时，可以考虑使用指针或 *切片* 来代替。

   + 结构体 ::
     结构体底层类型由结构体字段的顺序、名称、类型和所在的包确定：
     #+begin_quote
     Two struct types are identical if they have the same sequence of fields, and if corresponding fields have the same names, and identical types, and identical tags.
     Non-exported field names from different packages are always different.
     #+end_quote

     通常的声明方式为：
     #+begin_src go
       type A struct {
         x, y int
       }
     #+end_src

     其中，命名为 S 的结构体类型将不能再包含 S 类型的成员，但是可以包含 *S 指针类型的成员。

     结构体类型的零值是每个成员都是零值，其字面量值有两种形式，两种不同形式的写法不能混合使用，如果成员被忽略的话将默认用零值：
     #+begin_src go
       type Point struct{ X, Y int }

       p := Point{1, 2}

       // or

       p := Point{X: 1, Y: 2}
     #+end_src

     如果结构体的全部成员都是可以比较的，那么结构体也是可以比较的，那样的话两个结构体将可以使用 ~==~ 或 ~!=~ 运算符进行比较。
     相等比较运算符 ~==~ 将比较两个结构体的每个成员：
     #+begin_src go
       type Point struct{ X, Y int }

       p := Point{1, 2}
       q := Point{2, 1}
       fmt.Println(p.X == q.X && p.Y == q.Y) // "false"
       fmt.Println(p == q)                   // "false"
     #+end_src
     
     可比较的结构体类型和其他可比较的类型一样，可以用于 map 的 key 类型。

     Go 语言有一个特性让我们只声明一个成员对应的数据类型而不指名成员的名字，这类成员就叫匿名成员。
     匿名成员的数据类型必须是命名的类型或指向一个命名的类型的指针：
     #+begin_src go
       type Circle struct {
           Point             // named type
           Radius int
       }

       type Wheel struct {
           ,*Circle          // point
           Spokes int
       }
     #+end_src

     得益于匿名嵌入的特性，我们可以直接访问叶子属性而不需要给出完整的路径：
     #+begin_src go
       var w Wheel
       w.X = 8            // equivalent to w.Circle.Point.X = 8
       w.Y = 8            // equivalent to w.Circle.Point.Y = 8
       w.Radius = 5       // equivalent to w.Circle.Radius = 5
       w.Spokes = 20
     #+end_src

     在右边的注释中给出的显式形式访问这些叶子成员的语法依然有效，其中匿名成员 Circle 和 Point 都有自己的名字——就是命名的类型名字。

     不幸的是，结构体字面值并没有简短表示匿名成员的语法， 因此下面的语句都不能编译通过：
     #+begin_src go
       w = Wheel{8, 8, 5, 20}                       // compile error: unknown fields
       w = Wheel{X: 8, Y: 8, Radius: 5, Spokes: 20} // compile error: unknown fields

       // ok
       w = Wheel{
           Circle: Circle{
               Point:  Point{X: 8, Y: 8},
               Radius: 5,
           },
           Spokes: 20,
       }
     #+end_src

     特别的，在 C 语言中结构体指针访问成员值是 ~(*p).m~ 或 ~p->m~, 在 Go 里面直接用 ~p.m~ 就可以了：
     #+begin_src go
       p := &Vertex{1, 2}
       p.X = 100
     #+end_src
     
** 引用类型
   Go 语言中的引用和 Java 一样，更接近 C/C++ 中的指针，而不是 C++ 式的引用，引用类型的默认值为 nil，同时很多在 nil 上的操作都不会导致 NPE 的发生。

   PS：现在才知道 C++ 中的引用是何其卧槽，真的 NB!!!

   + 指针 ::
     Go 中存在指针，和 C 语言不同的是：
     1. Go 语言中的指针是不能偏移的，不能像 C 语言中那样，拿到个指针就可以到处飘了
     2. Go 语言中返回函数中局部变量的地址也是安全的

     这就使得下面这个操作的含义和 C 语言中的不一样，C 语言中是让指针 p 的值发生偏移，但是 Go 中是让 p 指向的变量的值加一：
     #+begin_src go
       func incr(p *int) int {
           ,*p++
           return *p
       }
     #+end_src

     可以通过内建函数 =new= 创建变量，表达式 =new(T)= 将创建一个 =T= 类型的匿名变量，初始化为 =T= 类型的零值，然后返回变量地址，类型为 =*T= 的指针，
     一定程度上等价于如下函数：
     #+begin_src go
       func newInt() *int {
           var dummy int
           return &dummy
       }
     #+end_src

   + 切片 ::
     Slice（切片）代表 *变长* 的序列，序列中每个元素都有相同的类型。一个 slice 类型一般写作 []T，其中 T 代表 slice 中元素的类型。

     数组和 Slice 之间有着紧密的联系。Slice 是一个轻量级的数据结构，提供了访问数组子序列（或者全部）元素的功能，
     而且 Slice 的底层确实引用一个数组对象。

     Slice 由三个部分构成：指针、长度和容量。指针指向第一个 Slice 元素对应的底层数组元素的地址，长度对应 Slice 中元素的数目，
     长度不能超过容量，容量一般是从 Slice 的开始位置到 *底层数据* 的结尾位置。
     因此，在切片上做的修改会反映到原数组上（和 Python 不一样）。

     需要注意 Slice 和数组字面量形式之间的区别，Slice 并没有指明序列的长度。这会隐式地创建一个合适大小的数组，然后 Slice 的指针指向底层的数组：
     #+begin_src go
       a := [...]int{1, 2, 3}  // array
       b := []int{1, 2, 3, 4}  // slice
     #+end_src

     多个 Slice 之间可以共享底层的数据，并且引用的数组部分区间可能重叠：
     #+begin_src go
       arr := [...]int{1, 2, 3, 4, 5}
       sl1 := arr[0:3]  // [1, 2, 3]
       sl2 := sl1[0:1]  // [1]
     #+end_src

     如果切片操作超出 =cap(s)= 的上限将导致一个 panic 异常，但是超出 =len(s)= 则是意味着扩展了 Slice，因为新 Slice 的长度会变大：
     #+begin_src go
       func main() {
         s := []int{2, 3, 5, 7, 11, 13}
         printSlice(s)

         // Slice the slice to give it zero length.
         s = s[:0]
         printSlice(s)

         // Extend its length.
         s = s[:4]
         printSlice(s)

         // Drop its first two values.
         s = s[2:]
         printSlice(s)
       }

       func printSlice(s []int) {
         fmt.Printf("len=%d cap=%d %v\n", len(s), cap(s), s)
       }

       // len=6 cap=6 [2 3 5 7 11 13]
       // len=0 cap=6 []
       // len=4 cap=6 [2 3 5 7]
       // len=2 cap=4 [5 7]
     #+end_src

     另外，字符串的切片操作和 =[]byte= 字节类型切片的切片操作是类似的。都写作 =x[m:n]= 并且都是返回一个原始字节系列的子序列，
     底层都是共享之前的底层数组，因此这种操作都是常量时间复杂度。

     和数组不同的是，Slice 之间不能比较，因此我们不能使用 ~==~ 操作符来判断两个 Slice 是否含有全部相等元素。
     其唯一合法的比较操作是和 =nil= 比较：
     #+begin_src go
       if summer == nil { /* ... */ }
     #+end_src

     PS： 其它引用类型好歹还可以通过 ~==~ 判断是否引用同一个对象 QAQ

     如果需要测试一个 Slice 是否是空的，使用 ~len(s) == 0~ 来判断来判断。除了和 nil 相等比较外，一个 nil 值的 slice 的行为和其它任意 0 长度的 Slice 一样。
     除了文档已经明确说明的地方，所有的 Go 语言函数应该以相同的方式对待 nil 值的 Slice 和 0 长度的 Slice。

     内置的 make 函数创建一个指定元素类型、长度和容量的 Slice。省略容量时，容量将等于长度：
     #+begin_src go
       make([]T, len)
       make([]T, len, cap) // same as make([]T, cap)[:len]
     #+end_src

     在底层，make 创建了一个匿名的数组变量，然后返回一个 slice。

     内置的 =append= 函数用于向 =slice= 追加元素：
     #+begin_src go
       var runes []rune
       for _, r := range "Hello, 世界" {
           runes = append(runes, r)
       }
       fmt.Printf("%q\n", runes) // "['H' 'e' 'l' 'l' 'o' ',' ' ' '世' '界']"
     #+end_src

     该函数的原理大致类似如下函数：
     #+begin_src go
       func appendInt(x []int, y int) []int {
           var z []int
           zlen := len(x) + 1
           if zlen <= cap(x) {
               // There is room to grow.  Extend the slice.
               z = x[:zlen]
           } else {
               // There is insufficient space.  Allocate a new array.
               // Grow by doubling, for amortized linear complexity.
               zcap := zlen
               if zcap < 2*len(x) {
                   zcap = 2 * len(x)
               }
               z = make([]int, zlen, zcap)
               copy(z, x) // a built-in function; see text
           }
           z[len(x)] = y
           return z
       }
     #+end_src

     #+begin_quote
     内置的 copy 函数可以方便地将一个 slice 复制另一个相同类型的 slice。copy 函数的第一个参数是要复制的目标 slice，
     第二个参数是源 slice，copy 函数将返回成功复制的元素的个数，等于两个 slice 中较小的长度，
     所以不用担心覆盖会超出目标 slice 的范围。
     #+end_quote

     为了提高内存使用效率，新分配的数组一般略大于保存 x 和 y 所需要的最低大小。

     函数 =append= 可以一次添加多个元素：
     #+begin_src go
       var x []int
       x = append(x, 1)
       x = append(x, 2, 3)
       x = append(x, 4, 5, 6)
       x = append(x, x...) // append the slice x
       fmt.Println(x)      // "[1 2 3 4 5 6 1 2 3 4 5 6]"
     #+end_src

     PS： 虽然 Go 切片语法和 Python 类似，但是，是不支持负数的。

   + Map ::
     在 Go 语言中，map 就是哈希表的引用，写为 map[K]V，所有的 key 都有相同的类型，所有的 value 也有着相同的类型。
     其中 K 对应的 key 必须是支持 ~==~ 比较运算符的数据类型。

     可以通过函数 =make= 或字面量的方式创建 map：
     #+begin_src go
       ages := make(map[string]int) // mapping from strings to ints
       ages := map[string]int{}
       ages := map[string]int{
           "alice":   31,
           "charlie": 34,
       }
     #+end_src
     
     map 的一些简单操作，其中，当 =key= 不存在时，获取操作默认返回零值，删除操作无影响：
     #+begin_src go
       // insert or update
       m[key] = elem

       // retrieve
       elem := m[key]

       // delete
       delete(m, key)

       // If key is in m, ok is true. If not, ok is false.
       // If key is not in the map, then elem is the zero value for the map's element type.
       elem, ok := m[key]
     #+end_src
   
     但是 map 中的元素并不是一个变量，因此我们不能对 map 的元素进行取址操作。
     
     要想遍历 map 中全部的 key/value 对的话，可以使用 range 风格的 for 循环实现：
     #+begin_src go
       for name, age := range ages {
           fmt.Printf("%s\t%d\n", name, age)
       }
     #+end_src

     map 上的大部分操作，包括查找、删除、len 和 range 循环都可以安全工作在 nil 值的 map 上，它们的行为和一个空的 map 类似。
     但是向一个 nil 值的 map 存入元素将导致一个 panic 异常。
     
     和 slice 一样，map 之间也不能进行相等比较，唯一的例外是和 nil 进行比较。

   + 函数 ::
     函数也是值，可以作为参数传递，但是好像说 Go 不适合函数式编程，不知道为啥：
     #+begin_src go
       func compute(fn func(float64, float64) float64) float64 {
         return fn(3, 4)
       }

       func main() {
         hypot := func(x, y float64) float64 {
           return math.Sqrt(x*x + y*y)
         }
         fmt.Println(hypot(5, 12))

         fmt.Println(compute(hypot))
         fmt.Println(compute(math.Pow))
       }
     #+end_src

     同时，函数值之间是不可比较的，也不能用函数值作为 map 的 key。
     
* 函数
  函数的声明从关键字 =func= 开始，参数的类型位于变量名称后面，这样做的理由- [[https://blog.golang.org/declaration-syntax][Go's Declaration Syntax - The Go Blog]]。
  #+begin_src go
    func name(parameter-list) (result-list) {
        body
    }
  #+end_src

  相邻参数类型相同时，可以省略前面参数的类型：
  #+begin_src go
    func add(x int , y int, c int) int {
      return x + y + c
    }

    // or

    func add(x, y, c int) int {
      return x + y + c
    }
  #+end_src

  函数可以很方便的返回多个值，同时，应该同时接收多个返回值：
  #+begin_src go
    func swap(x, y string) (string, string) {
      return y, x
    }

    func main() {
      a, b := swap("hello", "world")
      // use a and b
    }
  #+end_src

  可以为返回值命名，这些名称同样是变量，函数内部为其赋值不需要声明了，使用 ~return~ 时直接返回变量值（bare return），
  如果 ~return~ 有参数，就按照参数进行返回。
  #+begin_src go
    func split(sum int) (x, y int) {
      x = sum * 4 / 9
      y = sum - x
      return // y, x
    }
  #+end_src

  =return= 返回的参数数量要么和签名上的一样，要么为 0。

  拥有函数名的函数只能在 *包级语法块* 中被声明，匿名函数可以位于任意表达式中：
  #+begin_src go
    strings.Map(func(r rune) rune { return r + 1 }, "HAL-9000")
  #+end_src
  
  匿名函数可以访问完整的词法环境（lexical environment），这意味着在函数中定义的内部函数可以引用该函数的变量。
  利用这一特性时，如果位于循环体内部，捕获循环变量时需要在声明一次。
  
  Go 函数支持可变参数，调用者会隐式的创建一个数组，并将原始参数复制到数组中，再把数组的一个切片作为参数传给被调函数：
  #+begin_src go
    func sum(vals ...int) int {
        total := 0
        for _, val := range vals {
            total += val
        }
        return total
    }
  #+end_src
  
  如果参数就是切片，那么可以这样调用：
  #+begin_src go
    values := []int{1, 2, 3, 4}
    fmt.Println(sum(values...)) // "10"
  #+end_src

* 异常
  当 panic 异常发生时，程序会中断运行，并立即执行在该 =goroutine= 中被 =defer= 的函数。对于大部分漏洞，我们应该使用 Go 提供的错误机制，
  而不是 panic，尽量避免程序的崩溃。
  
  如果在 deferred 函数中调用了内置函数 recover，并且定义该 defer 语句的函数发生了 panic 异常，recover 会使程序从 panic 中恢复，
  并返回 panic value。导致 panic 异常的函数不会继续运行，但能正常返回。在未发生 panic 时调用 recover，recover 会返回 nil。
  
  例子：
  #+begin_src go
    func main() {
        a := returnN()
        fmt.Println(a)
    }

    func returnN() (result int) {
        defer func() {
            if p := recover(); p != nil {
                result = p.(int)
            }
        }()
        panic(3)
    }
  #+end_src

* 方法
  在函数声明时，在其名字之前放上一个变量，即是一个方法。这个附加的参数会将该函数附加到这种类型上，即相当于为这种类型定义了一个独占的方法：
  #+begin_src go
    func (receiver T) name(parameter-list) (result-list) {
      body
    }
  #+end_src

  可以给 *同一个包* 内的任意命名类型定义方法，只要这个命名类型的底层类型不是指针或者 interface。

  方法的 =receiver= 可以是指针，也就是说，传递引用而非值（二级指针是不允许的）：
  #+begin_src go
    func (v *Vertex) Scale(f float64) {
      v.X = v.X * f
      v.Y = v.Y * f
    }
  #+end_src

  当 =receiver= 类型为指针时，调用 =v.Scale= 会自动转换为 =(&v).Scale=, 但是函数参数不行：
  #+begin_src go
    // function
    var v Vertex
    ScaleFunc(v, 5)  // Compile error!
    ScaleFunc(&v, 5) // OK

    // method
    var v Vertex
    v.Scale(5)  // OK
    p := &v
    p.Scale(10) // OK
  #+end_src

  当 =receiver= 类型不是指针时，调用 =v.Scale= 也可以自动转换为 =(*p).Scale=, 函数参数同样不行：
  #+begin_src go
    var v Vertex
    fmt.Println(AbsFunc(v))  // OK
    fmt.Println(AbsFunc(&v)) // Compile error!

    var v Vertex
    fmt.Println(v.Abs()) // OK
    p := &v
    fmt.Println(p.Abs()) // OK
  #+end_src

  简单来说，对于函数参数来说，指针是指针，值是值，对于方法 =receiver= 来说，两者可以自动转换。同时，当接受者类型是指针时，
  空指针的方法调用不会抛出异常，而是将 =nil= 传递给接受者，如果接受者不是指针但指针值是 =nil= 时，调用会抛出异常。

  PS: 可以选择指针或值作为方法 =receiver=, 一般可能会选择指针，但是，两者中只能选择一个。
  
  结构体中的 *匿名字段* 的 *成员* 和 *方法* 都可以直接访问，即：
  #+begin_src go
    Circle.Point.X         // Circle.X
    Circle.Point.Method()  // Circle.Method()
  #+end_src
  
  这需要确保多个匿名字段引入的成员和方法不存在二义性，这是一个很有用的特性，比如将：
  #+begin_src go
    var (
        mu sync.Mutex // guards mapping
        mapping = make(map[string]string)
    )

    func Lookup(key string) string {
        mu.Lock()
        v := mapping[key]
        mu.Unlock()
        return v
    }
  #+end_src

  写成：
  #+begin_src go
    var cache = struct {
        sync.Mutex
        mapping map[string]string
    }{
        mapping: make(map[string]string),
    }


    func Lookup(key string) string {
        cache.Lock()
        v := cache.mapping[key]
        cache.Unlock()
        return v
    }
  #+end_src

  -----

  特定对象的方法可以通过 *方法值* 来表示，我们把类似 =obj.Method= 叫做选择器，该选择器返回一个值，该值为将方法绑定到特定接收器变量的函数。
  类似函数的柯里化：
  #+begin_src go
    p := Point{1, 2}
    q := Point{4, 6}

    distanceFromP := p.Distance        // method value
    fmt.Println(distanceFromP(q))      // "5"
    var origin Point                   // {0, 0}
    fmt.Println(distanceFromP(origin)) // "2.23606797749979", sqrt(5)
  #+end_src

  特定类型的方法可以通过 *方法表达式* 来表示，类似于 =T.Method= 或 =(*T).Method= 的形式，我们可以为方法表达式指定 =receiver= 和调用参数，
  这个和 JavaScript 中 =Function.prototype.call= 有点像。

  简单来说就是一个指定了 =receiver= 一个没指定。

  -----

  和其他语言不同，Go 语言中封装的最小单位是包，而且是通过名称首字母大小写来控制的。

* 接口
  Go 语言中接口类型的独特之处在于它是满足隐式实现的。也就是说，我们没有必要对于给定的具体类型定义所有满足的接口类型，
  简单地拥有一些必需的方法就足够了。

  这种设计可以让你创建一个新的接口类型满足已经存在的具体类型却不会去改变这些类型的定义。

  #+begin_comment
  我喜欢这样的设定，这样可以更好的管理 接口 <=> 实现 之间的关系
  #+end_comment

  -----

  接口类型具体描述了一系列方法的集合，一个实现了这些方法的具体类型是这个接口类型的实例。其定义方式如下：
  #+begin_src go
    type InterfaceName interface {
        (method-list)
    }
  #+end_src

  同时，新的接口类型可以通过组合已经有的接口来定义，和结构体的匿名字段类似，接口中的方法顺序没有影响，：
  #+begin_src go
    type ReadWriter interface {
        Read(p []byte) (n int, err error)
        Write(p []byte) (n int, err error)
    }

    type ReadWriter interface {
        Read(p []byte) (n int, err error)
        Writer
    }

    type ReadWriter interface {
        Reader
        Writer
    }
  #+end_src

  和一般的方法调用不一样，一般的方法调用可以根据 =receiver= 的类型自动在值和指针之间进行转换，但是接口不行，接口底层持有 =(value, type)= 元组，
  其中需要找到和类型匹配的方法才表示实现了该接口，这个类型是根据 =receiver= 来确定的。

  这使得接口的零值 =nil= 也有两种情况：
   1. 只是 =value= 为零值，但是 =type= 是存在的，这时，加入 =receiver= 的类型为指针，那么就会传递 =nil= 值到方法，值直接传对应类型的零值就行了
   2. =(value, type)= 都是零值，那么，此时调用方法就会出现运行时异常

  接口值可以使用 ~==~ 和 ~!=~ 来进行比较。两个接口值相等仅当它们都是 =nil= 值或者它们的动态类型相同并且动态值也根据这个动态类型的 ~==~ 操作相等。
  因为接口值是可比较的，所以它们可以用在 =map= 的键或者作为 =switch= 语句的操作数。
 
  然而，如果两个接口值的动态类型相同，但是这个动态类型是不可比较的（比如切片），将它们进行比较就会失败并且 panic：
  #+begin_src go
    var x interface{} = []int{1, 2, 3}
    fmt.Println(x == x) // panic: comparing uncomparable type []int
  #+end_src

  -----
  
  类型断言是一个使用在接口值上的操作。语法上它看起来像 =x.(T)= 被称为断言类型，这里 =x= 表示一个接口的类型和 =T= 表示一个类型。
  一个类型断言检查它操作对象的动态类型是否和断言的类型匹配。

  这里有两种可能：
  1. 如果断言的类型 =T= 是一个具体类型，然后类型断言检查 =x= 的动态类型是否和 =T= 相同。如果这个检查成功了，类型断言的结果是 =x= 的动态值，
     当然它的类型是 T。换句话说，具体类型的类型断言从它的操作对象中获得具体的值。如果检查失败，接下来这个操作会抛出 panic
     #+begin_src go
       var w io.Writer
       w = os.Stdout
       f := w.(*os.File)      // success: f == os.Stdout
       c := w.(*bytes.Buffer) // panic: interface holds *os.File, not *bytes.Bufferc
     #+end_src
  2. 如果断言的类型 =T= 是一个接口类型，然后类型断言检查 =x= 的动态类型是否匹配 =T= 接口。如果成功，就相当于将 =x= 转换为了 =T= 接口类型，
     否则抛出 panic
     #+begin_src go
       var w io.Writer
       w = os.Stdout
       rw := w.(io.ReadWriter) // success: *os.File has both Read and Write
       w = new(ByteCounter)
       rw = w.(io.ReadWriter) // panic: *ByteCounter has no Read method
     #+end_src

  当然，如果断言操作的对象是一个 =(nil, nil)= 接口值，那么不论被断言的类型是什么这个类型断言都会失败。

  通过如下方式可以避免失败时抛出 panic 错误，这是很有用的特性：
  #+begin_src go
    v, ok := i.(T)

    // example
    if f, ok := w.(*os.File); ok {
        // ...use f...
    }
  #+end_src

  也可以通过 =switch type= 语句根据具体的类型进行不同的操作：
   #+begin_src go
     switch x := x.(type) {
     case T:
         // here v has type T
     case S:
         // here v has type S
     default:
         // no match; here v has the same type as i
     }
   #+end_src

* 并发
  
