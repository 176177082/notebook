<!DOCTYPE html>
<html lang="zh-CN">
<head>
<!-- 2021-01-09 周六 19:46 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>GoLang</title>
<meta name="generator" content="Org mode">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="https://rgb-24bit.github.io/blog/misc/style.css">
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-125860001-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-125860001-1');
</script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="https://rgb-24bit.github.io/notebook/"> UP </a>
 |
 <a accesskey="H" href="https://rgb-24bit.github.io"> HOME </a>
</div><div id="content">
<h1 class="title">GoLang</h1>
<div id="table-of-contents">
<h2>&#30446;&#24405;</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgf1ea939">1. Go 语言起源</a></li>
<li><a href="#orge7b723e">2. 基本语法</a>
<ul>
<li><a href="#org82071dd">2.1. 分号</a></li>
<li><a href="#org8c9835e">2.2. 控制流</a></li>
<li><a href="#org3144b4f">2.3. range</a></li>
</ul>
</li>
<li><a href="#org310f1a4">3. 程序结构</a>
<ul>
<li><a href="#orgd659277">3.1. 命名</a></li>
<li><a href="#org7995496">3.2. 声明</a></li>
<li><a href="#orgcad9af7">3.3. 包和文件</a></li>
<li><a href="#org20defe9">3.4. 作用域</a></li>
</ul>
</li>
<li><a href="#org3df3d9d">4. 数据类型</a>
<ul>
<li><a href="#orgc35d5a5">4.1. 基础类型</a></li>
<li><a href="#orge1a97ed">4.2. 复合类型</a></li>
<li><a href="#org02d6956">4.3. 引用类型</a></li>
</ul>
</li>
<li><a href="#orge2a2057">5. 函数</a></li>
<li><a href="#org25c938f">6. 异常</a></li>
<li><a href="#org8f1de6c">7. 方法</a></li>
<li><a href="#orga209365">8. 接口</a></li>
<li><a href="#org3e5cedd">9. 并发</a></li>
<li><a href="#orgcd8ed10">10. 并发控制</a></li>
<li><a href="#org2039138">11. 反射</a></li>
<li><a href="#org07dd093">12. 底层编程</a></li>
<li><a href="#orgd2ce856">13. 相关链接</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgf1ea939" class="outline-2">
<h2 id="orgf1ea939"><span class="section-number-2">1</span> Go 语言起源</h2>
<div class="outline-text-2" id="text-1">
<p>
Go 语言的设计主要受到 CSP、Pascal 和 C 三个分支的影响，其中，CSP 只是一个用于描述并发性基本概念的描述语言，并不是一个可以编写可执行程序的通用编程语言。
</p>

<p>
在 CSP 中，程序是一组中间没有共享状态的平行运行的处理过程，它们之间使用 <b>管道</b> 进行通信和控制同步。
</p>

<img src="https://books.studygolang.com/gopl-zh/images/ch0-01.png">

<p>
Go 语言的设计虽然参考了其他语言，但是，本身的设计上是很简单的，也就是说，缺少一些在其他语言中很常见的特性。例如，它没有隐式的数值转换，没有构造函数和析构函数，没有运算符重载，没有默认参数，也没有继承，没有泛型，没有异常，没有宏，没有函数修饰，更没有线程局部存储。
</p>

<p>
这体现了 Go 语言的一个设计哲学——少即是多（感觉某些时候会很蛋疼）
</p>

<p>
可以参考：
</p>
<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/Communicating_sequential_processes">Communicating sequential processes - Wikipedia</a></li>
<li><a href="https://books.studygolang.com/gopl-zh/ch0/ch0-01.html">Go语言起源 | Go语言圣经</a></li>
<li><a href="https://books.studygolang.com/gopl-zh/ch0/ch0-02.html">Go语言项目 | Go语言圣经</a></li>
</ul>
</div>
</div>

<div id="outline-container-orge7b723e" class="outline-2">
<h2 id="orge7b723e"><span class="section-number-2">2</span> 基本语法</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org82071dd" class="outline-3">
<h3 id="org82071dd"><span class="section-number-3">2.1</span> 分号</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Go 语言不需要在语句或者声明的末尾添加分号，除非一行上有多条语句，因为编译器会主动把特定符号后的换行符转换为分号，主要包括以下情况：
</p>
<ul class="org-ul">
<li>行末是标识符、整数、浮点数、虚数、字符或字符串文字、关键字 break、continue、fallthrough 或 return 中的一个</li>
<li>行末是运算符和分隔符 ++、&#x2013;、)、] 或 } 中的一个</li>
</ul>

<div class="org-src-container">
<pre class="src src-go">f(
  a(), b(), c()   // error
)

f(
  a(), b(), c(),  // ok
)
</pre>
</div>
</div>
</div>

<div id="outline-container-org8c9835e" class="outline-3">
<h3 id="org8c9835e"><span class="section-number-3">2.2</span> 控制流</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Go 语言里面 <code>for</code> 循环就是唯一的循环控制语句了，几个特点：
</p>
<ul class="org-ul">
<li>由 init statement、condition expression 和 post statement 组成</li>
<li><p>
总是有大括号但是没有小括号：
</p>
<div class="org-src-container">
<pre class="src src-go">for i := 0; i &lt; 10; i++ {
  sum += i
}
</pre>
</div></li>
<li>循环语句上声明的变量作用域仅限于循环语句内部</li>
<li><p>
init statement 和 post statement 是可选的：
</p>
<div class="org-src-container">
<pre class="src src-go">for ; sum &lt; 1000; {
  sum += sum
}
</pre>
</div>

<p>
删除分号就约等于 <code>while</code> 语句了：
</p>
<div class="org-src-container">
<pre class="src src-go">for sum &lt; 1000 {
  sum += sum
}
</pre>
</div>

<p>
啥都不要就是死循环：
</p>
<div class="org-src-container">
<pre class="src src-go">for {
}
</pre>
</div></li>
</ul>

<p>
条件判断语句 <code>if</code> 也不要小括号但是要大括号：
</p>
<div class="org-src-container">
<pre class="src src-go">func sqrt(x float64) string {
  if x &lt; 0 {
    return sqrt(-x) + "i"
  }
  return fmt.Sprint(math.Sqrt(x))
}
</pre>
</div>

<p>
条件表达式前面可以有一个短语句，如果是声明变量，那么作用域仅限于条件语句：
</p>
<div class="org-src-container">
<pre class="src src-go">if v := math.Pow(x, n); v &lt; lim {
  return v
}
</pre>
</div>

<p>
作用域是包括 <code>else</code> 块的：
</p>
<div class="org-src-container">
<pre class="src src-go">if v := math.Pow(x, n); v &lt; lim {
  return v
} else {
  fmt.Printf("%g &gt;= %g\n", v, lim)
}
</pre>
</div>

<p>
Go 语言支持 <code>switch</code> 语句：
</p>
<div class="org-src-container">
<pre class="src src-go">switch os := runtime.GOOS; os {
case "darwin":
  fmt.Println("OS X.")
case "linux":
  fmt.Println("Linux.")
default:
  // freebsd, openbsd,
  // plan9, windows...
  fmt.Printf("%s.\n", os)
}
</pre>
</div>

<p>
但是它的 <code>case</code> 可以是表达式：
</p>
<div class="org-src-container">
<pre class="src src-go">switch time.Saturday {
case today + 0:
  fmt.Println("Today.")
case today + 1:
  fmt.Println("Tomorrow.")
case today + 2:
  fmt.Println("In two days.")
default:
  fmt.Println("Too far away.")
}
</pre>
</div>

<p>
因此，可以不要条件：
</p>
<div class="org-src-container">
<pre class="src src-go">switch {
case t.Hour() &lt; 12:
  fmt.Println("Good morning!")
case t.Hour() &lt; 17:
  fmt.Println("Good afternoon.")
default:
  fmt.Println("Good evening.")
}
</pre>
</div>

<p>
同时，比较特殊的是，Go 中匹配一个 case 项后不会自动执行后面的 case 项，除非使用了 <code>fallthrough</code> 关键字：
</p>
<div class="org-src-container">
<pre class="src src-go">switch (v) {
case 1:
  fmt.Println(1)
  fallthrough
case 2:
  fmt.Println(2)
}
</pre>
</div>

<p>
PS：感觉 <code>break</code> 的方式更加符合使用习惯才对……
</p>

<p>
defer 语句将函数的执行推迟到函数返回之前，但是参数还是会立即计算出来：
</p>
<div class="org-src-container">
<pre class="src src-go">defer fmt.Println("world")

fmt.Println("hello")
</pre>
</div>

<p>
多个 defer 函数调用：
</p>
<div class="org-src-container">
<pre class="src src-go">func main() {
  fmt.Println("counting")

  for i := 0; i &lt; 10; i++ {
    defer fmt.Println(i)
  }

  fmt.Println("done")
}
</pre>
</div>

<p>
运行结果为，可以看到是后进先出的：
</p>
<pre class="example">
counting
done
9
8
7
6
5
4
3
2
1
0
</pre>

<p>
更多可以参考：
</p>
<ul class="org-ul">
<li><a href="https://blog.golang.org/defer-panic-and-recover">Defer, Panic, and Recover - The Go Blog</a></li>
</ul>
</div>
</div>

<div id="outline-container-org3144b4f" class="outline-3">
<h3 id="org3144b4f"><span class="section-number-3">2.3</span> range</h3>
<div class="outline-text-3" id="text-2-3">
<p>
range 可以用于 <code>for</code> 循环迭代切片、数组和 <code>Map</code> 的索引和值：
</p>
<div class="org-src-container">
<pre class="src src-go">for i, v := range pow {
  fmt.Printf("2**%d = %d\n", i, v)
}
</pre>
</div>

<p>
忽略另一个值：
</p>
<div class="org-src-container">
<pre class="src src-go">pow := make([]int, 10)
for i := range pow {
  pow[i] = 1 &lt;&lt; uint(i) // == 2**i
}
for _, value := range pow {
  fmt.Printf("%d\n", value)
}
</pre>
</div>

<p>
PS: _ 是不能作为值使用的……
</p>
</div>
</div>
</div>

<div id="outline-container-org310f1a4" class="outline-2">
<h2 id="org310f1a4"><span class="section-number-2">3</span> 程序结构</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-orgd659277" class="outline-3">
<h3 id="orgd659277"><span class="section-number-3">3.1</span> 命名</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Go 语言中标识符必须以字母（Unicode 字母）或下划线开头，后面跟任意数量的字母、数组或下划线，大小写敏感。
</p>

<p>
关键字和内建名字有：
</p>
<pre class="example">
Keywords:
    break      default       func     interface   select
    case       defer         go       map         struct
    chan       else          goto     package     switch
    const      fallthrough   if       range       type
    continue   for           import   return      var

Built-in Constants:
    true false iota nil

Built-in Types:
    int     int8    int16      int32     int64
    uint    uint8   uint16     uint32    uint64 uintptr
    float32 float64 complex128 complex64
    bool    byte    rune       string    error

Built-in Functions:
    make    len     cap  new append copy close delete
    complex real    imag
    panic   recover
</pre>

<blockquote>
<p>
内建名字可以被从新定义，但是也要注意避免过度而引起语义混乱。
</p>
</blockquote>

<p>
如果一个名字是在函数内部定义，那么它的就只在函数内部有效。如果是在函数外部定义，那么将在当前包的所有文件中都可以访问。名字的开头字母的大小写决定了名字在包外的可见性。如果一个名字是大写字母开头的，那么它将是导出的。
</p>

<p>
名字的长度没有逻辑限制，但是 Go 语言的风格是尽量使用短小的名字，对于局部变量尤其是这样。
</p>

<p>
同时，在习惯上，Go 语言程序员推荐使用 <b>驼峰式</b> 命名，当名字有几个单词组成的时优先使用大小写分隔，而不是优先用下划线分隔。
</p>
</div>
</div>

<div id="outline-container-org7995496" class="outline-3">
<h3 id="org7995496"><span class="section-number-3">3.2</span> 声明</h3>
<div class="outline-text-3" id="text-3-2">
<p>
声明语句定义了程序的各种实体对象以及部分或全部的属性。Go 语言主要有四种类型的声明语句：var、const、type 和 func，分别对应变量、常量、类型和函数实体对象的声明。
</p>

<p>
Go 语言编写的程序对应一个或多个以 <code>.go</code> 为文件后缀名的源文件中。每个源文件以包的声明语句开始，说明该源文件是属于哪个包。包声明语句之后是 <code>import</code> 语句导入依赖的其它包，然后是包一级的类型、变量、常量、函数的声明语句，包一级的各种类型的声明语句的顺序无关紧要（函数内部的名字则必须先声明之后才能使用）。
</p>
<div class="org-src-container">
<pre class="src src-go">// =============================================================================
// package declare
// =============================================================================

package main

// =============================================================================
// import statement
// =============================================================================

import "fmt"

// =============================================================================
// package-level declarations of types, variables, constants, and functions
// =============================================================================

func main() {
    fmt.Println("Hello, World!")
}
</pre>
</div>

<dl class="org-dl">
<dt>变量</dt><dd><p>
可以通过 <code>var</code> 关键字声明变量，类型放在最后面，只能有一个类型：
</p>
<div class="org-src-container">
<pre class="src src-go">var c, python, java bool
</pre>
</div>

<p>
使用初始值是可以通过类型推断自动判断类型，可以有多个类型的值：
</p>
<div class="org-src-container">
<pre class="src src-go">var c, python, java = true, false, "no!"
</pre>
</div>

<p>
可以使用 <code>:=</code> 代理具有隐式类型声明的 <code>var</code> 语句，这需要左值为一个新的变量，由于函数外面的语句必须由关键字开始，因此函数外面无法使用这一语句：
</p>
<div class="org-src-container">
<pre class="src src-go">c, python, java := true, false, "no!"
</pre>
</div>

<p>
变量的生命周期为：
</p>
<ul class="org-ul">
<li>对于包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的</li>
<li>对于局部变量来说，它们的生命周期为每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收</li>
<li>编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，这由变量的作用域确定，有点类似 Rust 中的所有权</li>
</ul>

<p>
其中，函数的参数变量和返回值变量都是局部变量，它们在函数每次被调用的时候创建。
</p>

<p>
可以参考：《Go 程序设计语言 2.3.4 节》
</p></dd>

<dt>赋值</dt><dd><p>
Go 语言和 Python 一样，支持元组赋值，这是很棒的一个特性，至少，交换变量值就不需要手动写一个中间变量了：
</p>
<div class="org-src-container">
<pre class="src src-go">x, y = y, x
</pre>
</div>

<p>
同时，函数可以返回多个值，这些值就是一个元组，这时，左边变量的数目必须和右边函数的返回值数量一致。
</p>

<p>
一些特殊的操作返回的值数量受到左值数量的影响,可以通过空白标识符 <code>_</code> 来丢弃不需要的值：
</p>
<div class="org-src-container">
<pre class="src src-go">v = m[key]                // map 查找，失败时返回零值
v = x.(T)                 // type 断言，失败时 panic 异常
v = &lt;-ch                  // 管道接收，失败时返回零值

_, ok = m[key]            // map 返回 2 个值
_, ok = mm[""], false     // map 返回 1 个值
_ = mm[""]                // map 返回 1 个值
</pre>
</div></dd>

<dt>类型</dt><dd><p>
Go 语言中可以通过 <b>类型声明</b> 语句来声明类型，但是需要注意的是，Go 语言中的类型和其他一些语言中的类不一样，反而更接近 C 语言中的 <code>typedef</code> 和结构体：
</p>
<div class="org-src-container">
<pre class="src src-go">type 类型名字 底层类型
</pre>
</div>

<p>
可以简单的为一个类型添加不同的别名，但是，这些别名属于不同的类型，因此它们不可以被相互比较或混在一个表达式运算。
</p>
<div class="org-src-container">
<pre class="src src-go">type Celsius float64     // 摄氏温度
type Fahrenheit float64  // 华氏温度
</pre>
</div>

<p>
Go 语言不允许隐式类型转换，只能使用 <code>T(v)</code> 表达式完成显式类型转换，只有当两个类型的底层基础类型相同时，才允许这种转型操作，或者是两者都是指向相同底层结构的指针类型，这些转换只改变类型而不会影响值本身。
</p>

<p>
当然，数值类型之间的转型是被允许的，并且在字符串和一些特定类型的 <code>slice</code> 之间也是可以转换的。
</p>
<div class="org-src-container">
<pre class="src src-go">(*int)(0)  // Convert to *int
</pre>
</div>

<p>
底层数据类型决定了内部结构和表达方式，也决定是否可以像底层类型一样对内置运算符的支持：
</p>
<div class="org-src-container">
<pre class="src src-go">var v Celsius = 1.0
v += 1
</pre>
</div>

<p>
比较运算符以用来比较一个命名类型的变量和另一个有相同类型的变量，或有着 <b>相同底层类型</b> 的 <b>未命名类型的值</b> 之间做比较，但是如果两个值有着不同的类型，则不能直接进行比较：
</p>
<div class="org-src-container">
<pre class="src src-go">var c Celsius
var f Fahrenheit
fmt.Println(c == 0)           // "true"
fmt.Println(f &gt;= 0)           // "true"
fmt.Println(c == f)           // compile error: type mismatch
fmt.Println(c == Celsius(f))  // "true"!
</pre>
</div>

<p>
C 语言中 <code>typedef</code> 更像是一个别名，实际上还是同一个类型，而 Go 语言中的 <code>type</code> 则是定义了一个新类型。
</p></dd>
</dl>
</div>
</div>

<div id="outline-container-orgcad9af7" class="outline-3">
<h3 id="orgcad9af7"><span class="section-number-3">3.3</span> 包和文件</h3>
<div class="outline-text-3" id="text-3-3">
<p>
每个 <code>Go</code> 程序都由 <code>package</code> 组成，程序从 <code>main</code> 包开始运行，Go 语言中一个包的源代码保存在一个或 <b>多个</b> 以 <code>.go</code> 为文件后缀名的源文件中，通常一个包所在目录路径的后缀是包的导入路径，例如包 <code>gopl.io/ch1/helloworld</code> 对应的目录路径是 <code>$GOPATH/src/gopl.io/ch1/helloworld</code>.
</p>

<p>
每个包都对应一个独立的名字空间。例如，在 <code>image</code> 包中的 <code>Decode</code> 函数和在 <code>unicode/utf16</code> 包中的 <code>Decode</code> 函数是不同的。要在外部引用该函数，必须显式使用 <code>image.Decode</code> 或 <code>utf16.Decode</code> 形式访问。
</p>

<p>
包还可以让我们通过控制哪些名字是外部可见的来隐藏内部实现信息。在 Go 语言中，一个简单的规则是：如果一个名字是大写字母开头的，那么该名字是导出的（因为汉字不区分大小写，因此汉字开头的名字是没有导出的）。
</p>

<p>
在 Go 语言程序中，每个包都有一个全局唯一的导入路径。导入语句中类似 "gopl.io/ch2/tempconv" 的字符串对应包的导入路径。
Go 语言的规范并没有定义这些字符串的具体含义或包来自哪里，它们是由 <b>构建工具</b> 来解释的。
</p>
<blockquote>
<p>
当使用 Go 语言自带的 go 工具箱时，一个导入路径代表一个目录中的一个或多个 Go 源文件。
</p>
</blockquote>

<p>
除了包的导入路径，每个包还有一个包名，包名一般是短小的名字（并不要求包名是唯一的），包名在包的声明处指定。按照惯例，一个包的名字和包的导入路径的最后一个字段相同，例如 <code>gopl.io/ch2/tempconv</code> 包的名字一般是 <code>tempconv</code>.
</p>

<p>
可以通过 <code>_</code> 只导入包（副作用），或者在包路径前添加别名：
</p>
<div class="org-src-container">
<pre class="src src-go">import _ "/path/to/package"
import alias "/path/to/package"
</pre>
</div>

<p>
包的初始化首先是解决包级变量的依赖顺序，然后按照包级变量声明出现的顺序依次初始化：
</p>
<div class="org-src-container">
<pre class="src src-go">var a = b + c // a 第三个初始化, 为 3
var b = f()   // b 第二个初始化, 为 2, 通过调用 f (依赖c)
var c = 1     // c 第一个初始化, 为 1

func f() int { return c + 1 }
</pre>
</div>

<p>
如果包中含有多个 <code>.go</code> 源文件，它们将按照发给编译器的顺序进行初始化，Go 语言的构建工具首先会将 <code>.go</code> 文件根据文件名排序，然后依次调用编译器编译。
</p>

<p>
对于在包级别声明的变量，如果有初始化表达式则用表达式初始化，还有一些没有初始化表达式的，可以用一个特殊的 <code>init</code> 初始化函数来简化初始化工作。每个文件都可以包含多个 <code>init</code> 初始化函数，这样的 <code>init</code> 初始化函数除了不能被调用或引用外，其他行为和普通函数类似。在每个文件中的 <code>init</code> 初始化函数，在程序开始执行时按照它们声明的顺序被自动调用。
</p>
<div class="org-src-container">
<pre class="src src-go">func init() { /* ... */ }
</pre>
</div>

<p>
比如，具有复杂初始化逻辑的包级变量的初始化：
</p>
<div class="org-src-container">
<pre class="src src-go">var pc [256]byte

func init() {
    for i := range pc {
	pc[i] = pc[i/2] + byte(i&amp;1)
    }
}
</pre>
</div>

<p>
但也可以将初始化逻辑包装为一个匿名函数来进行处理：
</p>
<div class="org-src-container">
<pre class="src src-go">var pc [256]byte = func() (pc [256]byte) {
    for i := range pc {
	pc[i] = pc[i/2] + byte(i&amp;1)
    }
    return
}()
</pre>
</div>

<p>
每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次。因此，如果一个 <code>p</code> 包导入了 <code>q</code> 包，那么在 <code>p</code> 包初始化的时候可以认为 <code>q</code> 包必然已经初始化过了。初始化工作是自下而上进行的，main 包最后被初始化。以这种方式，可以确保在 <code>main</code> 函数执行之前，所有依赖的包都已经完成初始化工作了。
</p>
</div>
</div>

<div id="outline-container-org20defe9" class="outline-3">
<h3 id="org20defe9"><span class="section-number-3">3.4</span> 作用域</h3>
<div class="outline-text-3" id="text-3-4">
<p>
Go 语言存在块级作用域，同时，按照由内到外的查找规则，内部作用域的名字可以覆盖外部作用域的名字：
</p>
<div class="org-src-container">
<pre class="src src-go">func main() {
  a := 10
  {
    a := 100
    fmt.Println(a)  // 100
  }
  fmt.Println(a)      // 10
}

</pre>
</div>

<p>
Go 中的作用域大致可以分为如下几个级别：
</p>
<div class="org-src-container">
<pre class="src src-go">全局作用域 -&gt; 包级作用域 -&gt; 函数作用域 -&gt; 块级作用域
</pre>
</div>

<p>
虽然说块级作用域挺好的，但有时候又希望它不存在，如果可以由用户来控制就好了，比如循环体上的变量。
</p>
</div>
</div>
</div>

<div id="outline-container-org3df3d9d" class="outline-2">
<h2 id="org3df3d9d"><span class="section-number-2">4</span> 数据类型</h2>
<div class="outline-text-2" id="text-4">
<p>
Go 语言将数据类型分为四类：基础类型、复合类型、引用类型和接口类型。
</p>
</div>

<div id="outline-container-orgc35d5a5" class="outline-3">
<h3 id="orgc35d5a5"><span class="section-number-3">4.1</span> 基础类型</h3>
<div class="outline-text-3" id="text-4-1">
<p>
通常，基础类型就是数值类型，但是，在这点上，Go 的风格更加接近 C 语言，因为，Go 中的字符串也是基础类型。
</p>

<dl class="org-dl">
<dt>整型</dt><dd><p>
Go 语言同时提供了有符号和无符号类型的整数，主要有：
</p>
<pre class="example">
int  int8  int16  int32  int64
uint uint8 uint16 uint32 uint64
</pre>

<p>
其中，类型 <code>int</code> 和 <code>uint</code> 的宽度可能是 <code>32</code> 或 <code>64</code> 位，由编译器和平台决定。
</p>

<p>
同时，还存在一些其他的和整数类型相关的类型：
</p>
<pre class="example">
byte     // alias for uint8
rune     // alias for int32, represents a Unicode code point
uintptr
</pre>

<p>
下面是 Go 语言中关于算术运算、逻辑运算和比较运算的二元运算符，它们按照优先级递减的顺序排列：
</p>
<pre class="example">
*      /      %      &lt;&lt;       &gt;&gt;     &amp;       &amp;^
+      -      |      ^
==     !=     &lt;      &lt;=       &gt;      &gt;=
&amp;&amp;
||
</pre>

<p>
其中，算术运算符 +、-、* 和 / 可以适用于整数、浮点数和复数，但是取模运算符 % 仅用于整数间的运算，同时，在 Go 语言中，% 取模运算符的符号和被取模数的符号总是一致的，因此 -5 % 3 和 -5 % -3 结果都是 -2。
</p>

<p>
Go 语言中提供了一个 <code>&amp;^</code> 位运算操作符，作用为：如果对应 y 中 bit 位为 1 的话, 表达式 z = x &amp;^ y 结果 z 的对应的 bit 位为 0，否则 z 对应的 bit 位等于 x 相应的 bit 位的值。
</p></dd>

<dt>浮点数</dt><dd>Go 中提供了 <code>float32</code> 和 <code>float64</code> 两个浮点数类型，剩下感觉没啥好说的了。</dd>

<dt>复数</dt><dd><p>
Go 是原生支持复数这一数值类型的语言，提供了 <code>complex64</code> 和 <code>complex128</code> 两个精度。内置的 <code>complex</code> 函数用于构建复数，内建的 <code>real</code> 和 <code>imag</code> 函数分别返回复数的实部和虚部：
</p>
<div class="org-src-container">
<pre class="src src-go">var x complex128 = complex(1, 2) // 1+2i
var y complex128 = complex(3, 4) // 3+4i
fmt.Println(x*y)                 // "(-5+10i)"
fmt.Println(real(x*y))           // "-5"
fmt.Println(imag(x*y))           // "10"
</pre>
</div></dd>

<dt>布尔型</dt><dd>布尔类型没啥好说的，只有 <code>true</code> 和 <code>false</code> 这两个值，存在短路行为，OVER。</dd>

<dt>字符串</dt><dd><p>
字符串是一个不可改变的字节序列，可以包含任意的数据，包括 byte 值 0。文本字符串通常被解释为采用 UTF8 编码的 Unicode 码点（rune）序列。
</p>

<p>
内置的 len 函数可以返回一个字符串中的 <b>字节</b> 数目（不是 rune 字符数目），索引操作 <code>s[i]</code> 返回第 <code>i</code> 个 <b>字节</b> 的字节值。
</p>

<p>
字符串可以用比较运算符进行比较，比较通过逐个 <b>字节</b> 比较完成，因此比较的结果是字符串自然编码的顺序。也可以使用 <code>+</code> 操作符完成字符串拼接操作，但是只能拼接字符串或字符串切片。
</p>

<p>
字符串的不变性意味如果两个字符串共享相同的底层数据的话也是安全的，这使得复制任何长度的字符串代价是低廉的。同样，一个字符串 <code>s</code> 和对应的子字符串切片 <code>s[7:]</code> 的操作也可以安全地共享相同的内存，因此字符串切片操作代价也是低廉的。在这两种情况下都没有必要分配新的内存。
</p>

<p>
如图：
</p>
<img src="https://books.studygolang.com/gopl-zh/images/ch3-04.png">

<p>
字符串的字面量形式和其他语言差不多，值得注意的是，Go 中存在原生字符串，可以换行，不处理转义：
</p>
<div class="org-src-container">
<pre class="src src-go">`This is a raw string.

Yes, new line.

\\\\\\\\\\
`
</pre>
</div>

<p>
Go 语言的 range 循环在处理字符串的时候，会自动隐式解码 UTF8 字符串（为什么字符串要设计成字节数组呢？）：
</p>
<img src="https://books.studygolang.com/gopl-zh/images/ch3-05.png">

<p>
PS: Go 在遇到一个错误的 UTF8 编码输入时会将生成一个特别的 Unicode 字符 \uFFFD。
</p>

<p>
UTF8 字符串作为交换格式是非常方便的，但是在程序内部采用 rune 序列可能更方便，因为 rune 大小一致，支持数组索引和方便切割。将 <code>[]rune</code> 类型转换应用到 <code>UTF8</code> 编码的字符串，将返回字符串编码的 <code>Unicode</code> 码点序列：
</p>
<div class="org-src-container">
<pre class="src src-go">// "program" in Japanese katakana
s := "プログラム"
fmt.Printf("% x\n", s) // "e3 83 97 e3 83 ad e3 82 b0 e3 83 a9 e3 83 a0"
r := []rune(s)
fmt.Printf("%x\n", r)  // "[30d7 30ed 30b0 30e9 30e0]"
</pre>
</div>

<p>
如果是将一个 <code>[]rune</code> 类型的 Unicode 字符 <code>slice</code> 或数组转为 string，则对它们进行 UTF8 编码：
</p>
<div class="org-src-container">
<pre class="src src-go">fmt.Println(string(r)) // "プログラム"
</pre>
</div>

<p>
将一个整数转型为字符串意思是生成以只包含对应 Unicode 码点字符的 UTF8 字符串，如果对应码点的字符是无效的，则用 \uFFFD 无效字符作为替换：
</p>
<div class="org-src-container">
<pre class="src src-go">fmt.Println(string(65))     // "A", not "65"
fmt.Println(string(0x4eac)) // "京"
fmt.Println(string(1234567)) // "�"
</pre>
</div>

<p>
字符串是包含的只读字节数组，一旦创建，是不可变的。相比之下，字节切片的元素则可以自由地修改，两者可以相互转换：
</p>
<div class="org-src-container">
<pre class="src src-go">s := "abc"
b := []byte(s)
s2 := string(b)
</pre>
</div>

<p>
从概念上讲，一个 <code>[]byte(s)</code> 转换是分配了一个新的字节数组用于保存字符串数据的拷贝，然后引用这个底层的字节数组。编译器的优化可以避免在一些场景下分配和复制字符串数据，但总的来说需要确保在变量 b 被修改的情况下，原始的 s 字符串也不会改变。将一个字节切片转到字符串的 <code>string(b)</code> 操作则是构造一个字符串拷贝，以确保 s2 字符串是只读的。
</p>

<p>
为了避免转换中不必要的内存分配，bytes 包和 strings 同时提供了许多实用函数：
</p>
<div class="org-src-container">
<pre class="src src-go">// package string
func Contains(s, substr string) bool
func Count(s, sep string) int
func Fields(s string) []string
func HasPrefix(s, prefix string) bool
func Index(s, sep string) int
func Join(a []string, sep string) string

// package bytes
func Contains(b, subslice []byte) bool
func Count(s, sep []byte) int
func Fields(s []byte) [][]byte
func HasPrefix(s, prefix []byte) bool
func Index(s, sep []byte) int
func Join(s [][]byte, sep []byte) []byte
</pre>
</div>

<p>
它们之间唯一的区别是字符串类型参数被替换成了字节切片类型的参数。
</p>

<p>
bytes 包还提供了 Buffer 类型用于字节 slice 的缓存。一个 Buffer 开始是空的，但是随着 string、byte 或 []byte 等类型数据的写入可以动态增长，一个 bytes.Buffer 变量并不需要初始化，因为零值也是有效的：
</p>
<div class="org-src-container">
<pre class="src src-go">// intsToString is like fmt.Sprint(values) but adds commas.
func intsToString(values []int) string {
    var buf bytes.Buffer
    buf.WriteByte('[')
    for i, v := range values {
	if i &gt; 0 {
	    buf.WriteString(", ")
	}
	fmt.Fprintf(&amp;buf, "%d", v)
    }
    buf.WriteByte(']')
    return buf.String()
}

func main() {
    fmt.Println(intsToString([]int{1, 2, 3})) // "[1, 2, 3]"
}
</pre>
</div>

<p>
标准库中对字符串处理尤为重要的四个包：bytes、strings、strconv 和 unicode。
</p></dd>

<dt>常量</dt><dd><p>
常量表达式的值在编译期计算，而不是在运行期（常见的编译期优化操作）。每种常量的潜在类型都是基础类型：boolean、string 或数字。
</p>

<p>
常量间的所有算术运算、逻辑运算和比较运算的结果也是常量，对常量的类型转换操作或以下函数调用都是返回常量结果：
</p>
<ul class="org-ul">
<li>len、cap、real、imag、complex 和 unsafe.Sizeof</li>
</ul>

<p>
因为它们的值是在编译期就确定的，因此常量可以是构成类型的一部分，例如用于指定数组类型的长度（Go 中动态声明二维数组也太恶心了）：
</p>
<div class="org-src-container">
<pre class="src src-go">const IPv4Len = 4

// parseIPv4 parses an IPv4 address (d.d.d.d).
func parseIPv4(s string) IP {
    var p [IPv4Len]byte
    // ...
}
</pre>
</div>

<p>
如果是批量声明的常量，除了第一个外其它的常量右边的初始化表达式都可以省略，如果省略初始化表达式则表示使用前面常量的初始化表达式写法，对应的常量类型也一样的。例如：
</p>
<div class="org-src-container">
<pre class="src src-go">const (
    a = 1
    b
    c = 2
    d
)

fmt.Println(a, b, c, d) // "1 1 2 2"
</pre>
</div>

<p>
这个特性可以让我们使用 iota 常量生成器，它用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式。在一个 const 声明语句中，在第一个声明的常量所在的行，iota 将会被置为 0，然后在每一个有常量声明的行加一。
</p>

<p>
可以将其用在复杂的表达式中：
</p>
<div class="org-src-container">
<pre class="src src-go">const (
    _ = 1 &lt;&lt; (10 * iota)
    KiB // 1024
    MiB // 1048576
    GiB // 1073741824
    TiB // 1099511627776             (exceeds 1 &lt;&lt; 32)
    PiB // 1125899906842624
    EiB // 1152921504606846976
    ZiB // 1180591620717411303424    (exceeds 1 &lt;&lt; 64)
    YiB // 1208925819614629174706176
)
</pre>
</div>

<p>
当常量没有一个确定的基础类型时，编译器为这些没有明确的基础类型的数字常量提供比基础类型更高精度的算术运算，主要包括：
</p>
<ul class="org-ul">
<li>无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串</li>
</ul>

<p>
通过延迟明确常量的具体类型，无类型的常量不仅可以提供更高的运算精度，而且可以直接用于更多的表达式而不需要显式的类型转换：
</p>
<div class="org-src-container">
<pre class="src src-go">var x float32 = math.Pi
var y float64 = math.Pi
var z complex128 = math.Pi
</pre>
</div>

<p>
对于常量面值，不同的写法可能会对应不同的类型。例如 0、0.0、0i 和 \u0000 虽然有着相同的常量值，但是它们分别对应无类型的整数、无类型的浮点数、无类型的复数和无类型的字符等不同的常量类型。同样，true 和 false 也是无类型的布尔类型，字符串面值常量是无类型的字符串类型。
</p>

<p>
同时，除法运算符 <code>/</code> 会根据操作数的类型生成对应类型的结果。因此，不同写法的 <b>常量除法表达式</b> 可能对应不同的结果：
</p>
<div class="org-src-container">
<pre class="src src-go">var f float64 = 212
fmt.Println((f - 32) * 5 / 9)     // "100"; (f - 32) * 5 is a float64
fmt.Println(5 / 9 * (f - 32))     // "0";   5/9 is an untyped integer, 0
fmt.Println(5.0 / 9.0 * (f - 32)) // "100"; 5.0/9.0 is an untyped float
</pre>
</div>

<p>
只有常量可以是无类型的。当一个无类型的常量被赋值给一个变量的时候，无类型的常量将会被隐式转换为对应的类型，如果转换合法的话：
</p>
<div class="org-src-container">
<pre class="src src-go">var f float64 = 3 + 0i // untyped complex -&gt; float64
f = 2                  // untyped integer -&gt; float64
f = 1e123              // untyped floating-point -&gt; float64
f = 'a'                // untyped rune -&gt; float64
</pre>
</div>

<p>
无论是隐式或显式转换，将一种类型转换为另一种类型都要求目标可以表示原始值。对于浮点数和复数，可能会有舍入处理：
</p>
<div class="org-src-container">
<pre class="src src-go">const (
    deadbeef = 0xdeadbeef // untyped int with value 3735928559
    a = uint32(deadbeef)  // uint32 with value 3735928559
    b = float32(deadbeef) // float32 with value 3735928576 (rounded up)
    c = float64(deadbeef) // float64 with value 3735928559 (exact)
    d = int32(deadbeef)   // compile error: constant overflows int32
    e = float64(1e309)    // compile error: constant overflows float64
    f = uint(-1)          // compile error: constant underflows uint
)
</pre>
</div>

<p>
对于一个没有显式类型的变量声明（包括简短变量声明），常量的形式将隐式决定变量的默认类型，就像下面的例子：
</p>
<div class="org-src-container">
<pre class="src src-go">i := 0      // untyped integer;        implicit int(0)
r := '\000' // untyped rune;           implicit rune('\000')
f := 0.0    // untyped floating-point; implicit float64(0.0)
c := 0i     // untyped complex;        implicit complex128(0i)
</pre>
</div>

<p>
常量的默认类型：
</p>
<div class="org-src-container">
<pre class="src src-go">fmt.Printf("%T\n", 0)      // "int"
fmt.Printf("%T\n", 0.0)    // "float64"
fmt.Printf("%T\n", 0i)     // "complex128"
fmt.Printf("%T\n", '\000') // "int32" (rune)
</pre>
</div></dd>

<dt>字符</dt><dd><p>
Go 语言中没有专门的字符类型，如果要存储单个字符（字母），一般使用 byte 来保存。字符串就是一串固定长度的字符连接起来的字符序列。
Go 的字符串是由单个字节连接起来的。也就是说对于传统的字符串是由字符组成的，而 Go 的字符串不同，它是由字节组成的。
</p>

<div class="org-src-container">
<pre class="src src-go">var chr = 'c'
</pre>
</div></dd>
</dl>
</div>
</div>

<div id="outline-container-orge1a97ed" class="outline-3">
<h3 id="orge1a97ed"><span class="section-number-3">4.2</span> 复合类型</h3>
<div class="outline-text-3" id="text-4-2">
<p>
Go 语言中的复合数据类型为数组和结构体，支持结构体这一点感觉很不错。
</p>

<dl class="org-dl">
<dt>数组</dt><dd><p>
数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。数组的每个元素可以通过索引下标来访问，索引下标的范围是从 0 开始到数组长度减 1 的位置。内置的 <code>len</code> 函数将返回数组中元素的个数。
</p>

<p>
数组类型的声明方式，Go 又双叒叕走出来自己的路，大概是这个样子的：
</p>
<div class="org-src-container">
<pre class="src src-go">var a = [4]int{1, 2, 3}    // len 4
var b = [...]int{1, 2, 3}  // len 3
</pre>
</div>

<p>
也可以指定一个索引和对应值列表的方式初始化，这样索引的顺序是无关紧要的，而且没用到的索引可以省略，未指定初始值的元素将用零值初始化：
</p>
<div class="org-src-container">
<pre class="src src-go">type Currency int

const (
    USD Currency = iota // 美元
    EUR                 // 欧元
    GBP                 // 英镑
    RMB                 // 人民币
)

symbol := [...]string{USD: "$", EUR: "€", GBP: "￡", RMB: "￥"}

fmt.Println(RMB, symbol[RMB]) // "3 ￥"

r := [...]int{99: -1}  // len 100
</pre>
</div>

<p>
这里比较特殊的一点是，数组的长度也是数组类型的一部分，因此 <code>[3]int</code> 和 <code>[4]int</code> 算是不同的类型。
</p>

<p>
如果一个数组的元素类型是可以相互比较的，那么数组类型也可以使用 <code>==</code> 和 <code>!=</code> 操作符进行比较。
</p>

<p>
需要注意的是，Go 中数组是值类型而非引用类型，因此函数参数是数组时，大数组参数的传递效率可能很低。这时，可以考虑使用指针或 <b>切片</b> 来代替。
</p></dd>

<dt>结构体</dt><dd><p>
结构体底层类型由结构体字段的顺序、名称、类型和所在的包确定：
</p>
<blockquote>
<p>
Two struct types are identical if they have the same sequence of fields, and if corresponding fields have the same names, and identical types, and identical tags.
Non-exported field names from different packages are always different.(<a href="https://golang.org/ref/spec#Struct_types">Type identity ¶</a>)
</p>
</blockquote>

<p>
通常的声明方式为：
</p>
<div class="org-src-container">
<pre class="src src-go">type A struct {
  x, y int
}
</pre>
</div>

<p>
其中，命名为 S 的结构体类型将不能再包含 S 类型的成员，但是可以包含 *S 指针类型的成员。
</p>

<p>
结构体类型的零值是每个成员都是零值，其字面量值有两种形式，两种不同形式的写法不能混合使用，如果成员被忽略的话将默认用零值：
</p>
<div class="org-src-container">
<pre class="src src-go">type Point struct{ X, Y int }

p := Point{1, 2}

// or

p := Point{X: 1, Y: 2}
</pre>
</div>

<p>
如果结构体的全部成员都是可以比较的，那么结构体也是可以比较的，那样的话两个结构体将可以使用 <code>==</code> 或 <code>!=</code> 运算符进行比较。相等比较运算符 <code>==</code> 将比较两个结构体的每个成员：
</p>
<div class="org-src-container">
<pre class="src src-go">type Point struct{ X, Y int }

p := Point{1, 2}
q := Point{2, 1}
fmt.Println(p.X == q.X &amp;&amp; p.Y == q.Y) // "false"
fmt.Println(p == q)                   // "false"
</pre>
</div>

<p>
可比较的结构体类型和其他可比较的类型一样，可以用于 map 的 key 类型。
</p>

<p>
Go 语言有一个特性让我们只声明一个成员对应的数据类型而不指名成员的名字，这类成员就叫匿名成员。匿名成员的数据类型必须是命名的类型或指向一个命名的类型的指针：
</p>
<div class="org-src-container">
<pre class="src src-go">type Circle struct {
    Point             // named type
    Radius int
}

type Wheel struct {
    *Circle          // point
    Spokes int
}
</pre>
</div>

<p>
得益于匿名嵌入的特性，我们可以直接访问叶子属性而不需要给出完整的路径：
</p>
<div class="org-src-container">
<pre class="src src-go">var w Wheel
w.X = 8            // equivalent to w.Circle.Point.X = 8
w.Y = 8            // equivalent to w.Circle.Point.Y = 8
w.Radius = 5       // equivalent to w.Circle.Radius = 5
w.Spokes = 20
</pre>
</div>

<p>
在右边的注释中给出的显式形式访问这些叶子成员的语法依然有效，其中匿名成员 Circle 和 Point 都有自己的名字——就是命名的类型名字。
</p>

<p>
不幸的是，结构体字面值并没有简短表示匿名成员的语法， 因此下面的语句都不能编译通过：
</p>
<div class="org-src-container">
<pre class="src src-go">w = Wheel{8, 8, 5, 20}                       // compile error: unknown fields
w = Wheel{X: 8, Y: 8, Radius: 5, Spokes: 20} // compile error: unknown fields

// ok
w = Wheel{
    Circle: Circle{
	Point:  Point{X: 8, Y: 8},
	Radius: 5,
    },
    Spokes: 20,
}
</pre>
</div>

<p>
特别的，在 C 语言中结构体指针访问成员值是 <code>(*p).m</code> 或 <code>p-&gt;m</code>, 在 Go 里面直接用 <code>p.m</code> 就可以了：
</p>
<div class="org-src-container">
<pre class="src src-go">p := &amp;Vertex{1, 2}
p.X = 100
</pre>
</div>

<p>
相关：
</p>
<ul class="org-ul">
<li><a href="trick.html#MissingReference">☞ Go Trick::类型转换</a></li>
</ul></dd>
</dl>
</div>
</div>

<div id="outline-container-org02d6956" class="outline-3">
<h3 id="org02d6956"><span class="section-number-3">4.3</span> 引用类型</h3>
<div class="outline-text-3" id="text-4-3">
<p>
Go 语言中的引用和 Java 一样，更接近 C/C++ 中的指针，而不是 C++ 式的引用，引用类型的默认值为 nil，同时很多在 nil 上的操作都不会导致 NPE 的发生。
</p>

<p>
PS：现在才知道 C++ 中的引用是何其卧槽，真的 NB!!!
</p>

<dl class="org-dl">
<dt>指针</dt><dd><p>
Go 中存在指针，和 C 语言不同的是：
</p>
<ol class="org-ol">
<li>Go 语言中的指针是不能偏移的，不能像 C 语言中那样，拿到个指针就可以到处飘了</li>
<li>Go 语言中返回函数中局部变量的地址也是安全的</li>
</ol>

<p>
这就使得下面这个操作的含义和 C 语言中的不一样，C 语言中是让指针 p 的值发生偏移，但是 Go 中是让 p 指向的变量的值加一：
</p>
<div class="org-src-container">
<pre class="src src-go">func incr(p *int) int {
    *p++
    return *p
}
</pre>
</div>

<p>
可以通过内建函数 <code>new</code> 创建变量，表达式 <code>new(T)</code> 将创建一个 <code>T</code> 类型的匿名变量，初始化为 <code>T</code> 类型的零值，然后返回变量地址，类型为 <code>*T</code> 的指针，一定程度上等价于如下函数：
</p>
<div class="org-src-container">
<pre class="src src-go">func newInt() *int {
    var dummy int
    return &amp;dummy
}
</pre>
</div></dd>

<dt>切片</dt><dd><p>
Slice（切片）代表 <b>变长</b> 的序列，序列中每个元素都有相同的类型。一个 slice 类型一般写作 []T，其中 T 代表 slice 中元素的类型。
</p>

<p>
数组和 Slice 之间有着紧密的联系。Slice 是一个轻量级的数据结构，提供了访问数组子序列（或者全部）元素的功能，而且 Slice 的底层确实引用一个数组对象。
</p>

<p>
Slice 由三个部分构成：指针、长度和容量。指针指向第一个 Slice 元素对应的底层数组元素的地址，长度对应 Slice 中元素的数目，长度不能超过容量，容量一般是从 Slice 的开始位置到 <b>底层数据</b> 的结尾位置。因此，在切片上做的修改会反映到原数组上（和 Python 不一样）。
</p>

<p>
需要注意 Slice 和数组字面量形式之间的区别，Slice 并没有指明序列的长度。这会隐式地创建一个合适大小的数组，然后 Slice 的指针指向底层的数组：
</p>
<div class="org-src-container">
<pre class="src src-go">a := [...]int{1, 2, 3}  // array
b := []int{1, 2, 3, 4}  // slice
</pre>
</div>

<p>
多个 Slice 之间可以共享底层的数据，并且引用的数组部分区间可能重叠：
</p>
<div class="org-src-container">
<pre class="src src-go">arr := [...]int{1, 2, 3, 4, 5}
sl1 := arr[0:3]  // [1, 2, 3]
sl2 := sl1[0:1]  // [1]
</pre>
</div>

<p>
如果切片操作超出 <code>cap(s)</code> 的上限将导致一个 panic 异常，但是超出 <code>len(s)</code> 则是意味着扩展了 Slice，因为新 Slice 的长度会变大：
</p>
<div class="org-src-container">
<pre class="src src-go">func main() {
  s := []int{2, 3, 5, 7, 11, 13}
  printSlice(s)

  // Slice the slice to give it zero length.
  s = s[:0]
  printSlice(s)

  // Extend its length.
  s = s[:4]
  printSlice(s)

  // Drop its first two values.
  s = s[2:]
  printSlice(s)
}

func printSlice(s []int) {
  fmt.Printf("len=%d cap=%d %v\n", len(s), cap(s), s)
}

// len=6 cap=6 [2 3 5 7 11 13]
// len=0 cap=6 []
// len=4 cap=6 [2 3 5 7]
// len=2 cap=4 [5 7]
</pre>
</div>

<p>
另外，字符串的切片操作和 <code>[]byte</code> 字节类型切片的切片操作是类似的。都写作 <code>x[m:n]</code> 并且都是返回一个原始字节系列的子序列，底层都是共享之前的底层数组，因此这种操作都是常量时间复杂度。
</p>

<p>
和数组不同的是，Slice 之间不能比较，因此我们不能使用 <code>==</code> 操作符来判断两个 Slice 是否含有全部相等元素。其唯一合法的比较操作是和 <code>nil</code> 比较：
</p>
<div class="org-src-container">
<pre class="src src-go">if summer == nil { /* ... */ }
</pre>
</div>

<p>
PS： 其它引用类型好歹还可以通过 <code>==</code> 判断是否引用同一个对象 QAQ
</p>

<p>
如果需要测试一个 Slice 是否是空的，使用 <code>len(s) == 0</code> 来判断来判断。除了和 nil 相等比较外，一个 nil 值的 slice 的行为和其它任意 0 长度的 Slice 一样。除了文档已经明确说明的地方，所有的 Go 语言函数应该以相同的方式对待 nil 值的 Slice 和 0 长度的 Slice。
</p>

<p>
内置的 make 函数创建一个指定元素类型、长度和容量的 Slice。省略容量时，容量将等于长度：
</p>
<div class="org-src-container">
<pre class="src src-go">make([]T, len)
make([]T, len, cap) // same as make([]T, cap)[:len]
</pre>
</div>

<p>
在底层，make 创建了一个匿名的数组变量，然后返回一个 slice。
</p>

<p>
内置的 <code>append</code> 函数用于向 <code>slice</code> 追加元素：
</p>
<div class="org-src-container">
<pre class="src src-go">var runes []rune
for _, r := range "Hello, 世界" {
    runes = append(runes, r)
}
fmt.Printf("%q\n", runes) // "['H' 'e' 'l' 'l' 'o' ',' ' ' '世' '界']"
</pre>
</div>

<p>
该函数的原理大致类似如下函数：
</p>
<div class="org-src-container">
<pre class="src src-go">func appendInt(x []int, y int) []int {
    var z []int
    zlen := len(x) + 1
    if zlen &lt;= cap(x) {
	// There is room to grow.  Extend the slice.
	z = x[:zlen]
    } else {
	// There is insufficient space.  Allocate a new array.
	// Grow by doubling, for amortized linear complexity.
	zcap := zlen
	if zcap &lt; 2*len(x) {
	    zcap = 2 * len(x)
	}
	z = make([]int, zlen, zcap)
	copy(z, x) // a built-in function; see text
    }
    z[len(x)] = y
    return z
}
</pre>
</div>

<blockquote>
<p>
内置的 copy 函数可以方便地将一个 slice 复制另一个相同类型的 slice。copy 函数的第一个参数是要复制的目标 slice，第二个参数是源 slice，copy 函数将返回成功复制的元素的个数，等于两个 slice 中较小的长度，所以不用担心覆盖会超出目标 slice 的范围。
</p>
</blockquote>

<p>
为了提高内存使用效率，新分配的数组一般略大于保存 x 和 y 所需要的最低大小。
</p>

<p>
函数 <code>append</code> 可以一次添加多个元素：
</p>
<div class="org-src-container">
<pre class="src src-go">var x []int
x = append(x, 1)
x = append(x, 2, 3)
x = append(x, 4, 5, 6)
x = append(x, x...) // append the slice x
fmt.Println(x)      // "[1 2 3 4 5 6 1 2 3 4 5 6]"
</pre>
</div>

<p>
PS： 虽然 Go 切片语法和 Python 类似，但是，是不支持负数的。
</p></dd>

<dt>Map</dt><dd><p>
在 Go 语言中，map 就是哈希表的引用，写为 map[K]V，所有的 key 都有相同的类型，所有的 value 也有着相同的类型。其中 K 对应的 key 必须是支持 <code>==</code> 比较运算符的数据类型。
</p>

<p>
可以通过函数 <code>make</code> 或字面量的方式创建 map：
</p>
<div class="org-src-container">
<pre class="src src-go">ages := make(map[string]int) // mapping from strings to ints
ages := map[string]int{}
ages := map[string]int{
    "alice":   31,
    "charlie": 34,
}
</pre>
</div>

<p>
map 的一些简单操作，其中，当 <code>key</code> 不存在时，获取操作默认返回零值，删除操作无影响：
</p>
<div class="org-src-container">
<pre class="src src-go">// insert or update
m[key] = elem

// retrieve
elem := m[key]

// delete
delete(m, key)

// If key is in m, ok is true. If not, ok is false.
// If key is not in the map, then elem is the zero value for the map's element type.
elem, ok := m[key]
</pre>
</div>

<p>
但是 map 中的元素并不是一个变量，因此我们不能对 map 的元素进行取址操作。
</p>

<p>
要想遍历 map 中全部的 key/value 对的话，可以使用 range 风格的 for 循环实现：
</p>
<div class="org-src-container">
<pre class="src src-go">for name, age := range ages {
    fmt.Printf("%s\t%d\n", name, age)
}
</pre>
</div>

<p>
map 上的大部分操作，包括查找、删除、len 和 range 循环都可以安全工作在 nil 值的 map 上，它们的行为和一个空的 map 类似。但是向一个 nil 值的 map 存入元素将导致一个 panic 异常。
</p>

<p>
和 slice 一样，map 之间也不能进行相等比较，唯一的例外是和 nil 进行比较。
</p></dd>

<dt>函数</dt><dd><p>
函数也是值，可以作为参数传递，但是好像说 Go 不适合函数式编程，不知道为啥：
</p>
<div class="org-src-container">
<pre class="src src-go">func compute(fn func(float64, float64) float64) float64 {
  return fn(3, 4)
}

func main() {
  hypot := func(x, y float64) float64 {
    return math.Sqrt(x*x + y*y)
  }
  fmt.Println(hypot(5, 12))

  fmt.Println(compute(hypot))
  fmt.Println(compute(math.Pow))
}
</pre>
</div>

<p>
同时，函数值之间是不可比较的，也不能用函数值作为 map 的 key。
</p></dd>
</dl>
</div>
</div>
</div>

<div id="outline-container-orge2a2057" class="outline-2">
<h2 id="orge2a2057"><span class="section-number-2">5</span> 函数</h2>
<div class="outline-text-2" id="text-5">
<p>
函数的声明从关键字 <code>func</code> 开始，参数的类型位于变量名称后面，这样做的理由- <a href="https://blog.golang.org/declaration-syntax">Go's Declaration Syntax - The Go Blog</a>。
</p>
<div class="org-src-container">
<pre class="src src-go">func name(parameter-list) (result-list) {
    body
}
</pre>
</div>

<p>
相邻参数类型相同时，可以省略前面参数的类型：
</p>
<div class="org-src-container">
<pre class="src src-go">func add(x int , y int, c int) int {
  return x + y + c
}

// or

func add(x, y, c int) int {
  return x + y + c
}
</pre>
</div>

<p>
函数可以很方便的返回多个值，同时，应该同时接收多个返回值：
</p>
<div class="org-src-container">
<pre class="src src-go">func swap(x, y string) (string, string) {
  return y, x
}

func main() {
  a, b := swap("hello", "world")
  // use a and b
}
</pre>
</div>

<p>
可以为返回值命名，这些名称同样是变量，函数内部为其赋值不需要声明了，使用 <code>return</code> 时直接返回变量值（bare return），如果 <code>return</code> 有参数，就按照参数进行返回。
</p>
<div class="org-src-container">
<pre class="src src-go">func split(sum int) (x, y int) {
  x = sum * 4 / 9
  y = sum - x
  return // y, x
}
</pre>
</div>

<p>
<code>return</code> 返回的参数数量要么和签名上的一样，要么为 0。
</p>

<p>
拥有函数名的函数只能在 <b>包级语法块</b> 中被声明，匿名函数可以位于任意表达式中：
</p>
<div class="org-src-container">
<pre class="src src-go">strings.Map(func(r rune) rune { return r + 1 }, "HAL-9000")
</pre>
</div>

<p>
匿名函数可以访问完整的词法环境（lexical environment），这意味着在函数中定义的内部函数可以引用该函数的变量。利用这一特性时，如果位于循环体内部，捕获循环变量时需要在声明一次。
</p>

<p>
Go 函数支持可变参数，调用者会隐式的创建一个数组，并将原始参数复制到数组中，再把数组的一个切片作为参数传给被调函数：
</p>
<div class="org-src-container">
<pre class="src src-go">func sum(vals ...int) int {
    total := 0
    for _, val := range vals {
	total += val
    }
    return total
}
</pre>
</div>

<p>
如果参数就是切片，那么可以这样调用：
</p>
<div class="org-src-container">
<pre class="src src-go">values := []int{1, 2, 3, 4}
fmt.Println(sum(values...)) // "10"
</pre>
</div>
</div>
</div>

<div id="outline-container-org25c938f" class="outline-2">
<h2 id="org25c938f"><span class="section-number-2">6</span> 异常</h2>
<div class="outline-text-2" id="text-6">
<p>
当 panic 异常发生时，程序会中断运行，并立即执行在该 <code>goroutine</code> 中被 <code>defer</code> 的函数。对于大部分漏洞，我们应该使用 Go 提供的错误机制，而不是 panic，尽量避免程序的崩溃。
</p>

<p>
如果在 deferred 函数中调用了内置函数 recover，并且定义该 defer 语句的函数发生了 panic 异常，recover 会使程序从 panic 中恢复，并返回 panic value。导致 panic 异常的函数不会继续运行，但能正常返回。在未发生 panic 时调用 recover，recover 会返回 nil。
</p>

<p>
NOTE：如果没有通过 recover 捕获 panic，那么程序就会异常终止！
</p>

<p>
例子：
</p>
<div class="org-src-container">
<pre class="src src-go">func main() {
    a := returnN()
    fmt.Println(a)
}

func returnN() (result int) {
    defer func() {
	if p := recover(); p != nil {
	    result = p.(int)
	}
    }()
    panic(3)
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org8f1de6c" class="outline-2">
<h2 id="org8f1de6c"><span class="section-number-2">7</span> 方法</h2>
<div class="outline-text-2" id="text-7">
<p>
在函数声明时，在其名字之前放上一个变量，即是一个方法。这个附加的参数会将该函数附加到这种类型上，即相当于为这种类型定义了一个独占的方法：
</p>
<div class="org-src-container">
<pre class="src src-go">func (receiver T) name(parameter-list) (result-list) {
  body
}
</pre>
</div>

<p>
可以给 <b>同一个包</b> 内的任意命名类型定义方法，只要这个命名类型的底层类型不是指针或者 interface。
</p>

<p>
方法的 <code>receiver</code> 可以是指针，也就是说，传递引用而非值（二级指针是不允许的）：
</p>
<div class="org-src-container">
<pre class="src src-go">func (v *Vertex) Scale(f float64) {
  v.X = v.X * f
  v.Y = v.Y * f
}
</pre>
</div>

<p>
当 <code>receiver</code> 类型为指针时，调用 <code>v.Scale</code> 会自动转换为 <code>(&amp;v).Scale</code>, 但是函数参数不行：
</p>
<div class="org-src-container">
<pre class="src src-go">// function
var v Vertex
ScaleFunc(v, 5)  // Compile error!
ScaleFunc(&amp;v, 5) // OK

// method
var v Vertex
v.Scale(5)  // OK
p := &amp;v
p.Scale(10) // OK
</pre>
</div>

<p>
当 <code>receiver</code> 类型不是指针时，调用 <code>v.Scale</code> 也可以自动转换为 <code>(*p).Scale</code>, 函数参数同样不行：
</p>
<div class="org-src-container">
<pre class="src src-go">var v Vertex
fmt.Println(AbsFunc(v))  // OK
fmt.Println(AbsFunc(&amp;v)) // Compile error!

var v Vertex
fmt.Println(v.Abs()) // OK
p := &amp;v
fmt.Println(p.Abs()) // OK
</pre>
</div>

<p>
简单来说，对于函数参数来说，指针是指针，值是值，对于方法 <code>receiver</code> 来说，两者可以自动转换。同时，当接受者类型是指针时，空指针的方法调用不会抛出异常，而是将 <code>nil</code> 传递给接受者，如果接受者不是指针但指针值是 <code>nil</code> 时，调用会抛出异常。
</p>

<p>
PS: 可以选择指针或值作为方法 <code>receiver</code>, 一般可能会选择指针，但是，两者中只能选择一个。
</p>

<p>
结构体中的 <b>匿名字段</b> 的 <b>成员</b> 和 <b>方法</b> 都可以直接访问，即：
</p>
<div class="org-src-container">
<pre class="src src-go">Circle.Point.X         // Circle.X
Circle.Point.Method()  // Circle.Method()
</pre>
</div>

<p>
这需要确保多个匿名字段引入的成员和方法不存在二义性，这是一个很有用的特性，比如将：
</p>
<div class="org-src-container">
<pre class="src src-go">var (
    mu sync.Mutex // guards mapping
    mapping = make(map[string]string)
)

func Lookup(key string) string {
    mu.Lock()
    v := mapping[key]
    mu.Unlock()
    return v
}
</pre>
</div>

<p>
写成：
</p>
<div class="org-src-container">
<pre class="src src-go">var cache = struct {
    sync.Mutex
    mapping map[string]string
}{
    mapping: make(map[string]string),
}


func Lookup(key string) string {
    cache.Lock()
    v := cache.mapping[key]
    cache.Unlock()
    return v
}
</pre>
</div>

<hr>

<p>
特定对象的方法可以通过 <b>方法值</b> 来表示，我们把类似 <code>obj.Method</code> 叫做选择器，该选择器返回一个值，该值为将方法绑定到特定接收器变量的函数。类似函数的柯里化：
</p>
<div class="org-src-container">
<pre class="src src-go">p := Point{1, 2}
q := Point{4, 6}

distanceFromP := p.Distance        // method value
fmt.Println(distanceFromP(q))      // "5"
var origin Point                   // {0, 0}
fmt.Println(distanceFromP(origin)) // "2.23606797749979", sqrt(5)
</pre>
</div>

<p>
特定类型的方法可以通过 <b>方法表达式</b> 来表示，类似于 <code>T.Method</code> 或 <code>(*T).Method</code> 的形式，我们可以为方法表达式指定 <code>receiver</code> 和调用参数，这个和 JavaScript 中 <code>Function.prototype.call</code> 有点像。
</p>

<p>
简单来说就是一个指定了 <code>receiver</code> 一个没指定。
</p>

<hr>

<p>
和其他语言不同，Go 语言中封装的最小单位是包，而且是通过名称首字母大小写来控制的。
</p>

<hr>

<p>
需要注意的一件事，当 reciver 是值的时候，传递过来的也就只有值，直接在这个值上的改动是 <b>不能</b> 反馈到原对象上的。
</p>

<p>
同时，如果 receiver 是一个指针，通过 <code>*reciver = xxx</code> 修改这个指针的指向也是不会影响原值的。
</p>

<hr>

<p>
需要注意的另一件事，Go 中结构体和 Java 中的对象是不一样的（写习惯了 Java 在这一点上容易被坑），在 Java 中，新创建一个对象的时候会分配新的内存，但是在 Go 中，执行 Type{} 不一定会分配内存：
</p>
<div class="org-src-container">
<pre class="src src-go">type User struct {
  name string
}

func main() {
  user := User{name: "name"}  // 为 user 分配内存
  user = User{}               // 不会为 user 分配新的内存，只是用 User{} 的值覆盖原内存的值
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orga209365" class="outline-2">
<h2 id="orga209365"><span class="section-number-2">8</span> 接口</h2>
<div class="outline-text-2" id="text-8">
<p>
Go 语言中接口类型的独特之处在于它是满足隐式实现的。也就是说，我们没有必要对于给定的具体类型定义所有满足的接口类型，简单地拥有一些必需的方法就足够了。
</p>

<p>
这种设计可以让你创建一个新的接口类型满足已经存在的具体类型却不会去改变这些类型的定义。
</p>

<hr>

<p>
接口类型具体描述了一系列方法的集合，一个实现了这些方法的具体类型是这个接口类型的实例。其定义方式如下：
</p>
<div class="org-src-container">
<pre class="src src-go">type InterfaceName interface {
    (method-list)
}
</pre>
</div>

<p>
同时，新的接口类型可以通过组合已经有的接口来定义，和结构体的匿名字段类似，接口中的方法顺序没有影响，：
</p>
<div class="org-src-container">
<pre class="src src-go">type ReadWriter interface {
    Read(p []byte) (n int, err error)
    Write(p []byte) (n int, err error)
}

type ReadWriter interface {
    Read(p []byte) (n int, err error)
    Writer
}

type ReadWriter interface {
    Reader
    Writer
}
</pre>
</div>

<p>
和一般的方法调用不一样，一般的方法调用可以根据 <code>receiver</code> 的类型自动在值和指针之间进行转换，但是接口不行，接口底层持有 <code>(value, type)</code> 元组，其中需要找到和类型匹配的方法才表示实现了该接口，这个类型是根据 <code>receiver</code> 来确定的。
</p>

<p>
这使得接口的零值 <code>nil</code> 也有两种情况：
</p>
<ol class="org-ol">
<li>只是 <code>value</code> 为零值，但是 <code>type</code> 是存在的，这时，加入 <code>receiver</code> 的类型为指针，那么就会传递 <code>nil</code> 值到方法，值直接传对应类型的零值就行了</li>
<li><code>(value, type)</code> 都是零值，那么，此时调用方法就会出现运行时异常</li>
</ol>

<p>
接口值可以使用 <code>==</code> 和 <code>!=</code> 来进行比较。两个接口值相等仅当它们都是 <code>nil</code> 值或者它们的动态类型相同并且动态值也根据这个动态类型的 <code>==</code> 操作相等。因为接口值是可比较的，所以它们可以用在 <code>map</code> 的键或者作为 <code>switch</code> 语句的操作数。
</p>

<p>
然而，如果两个接口值的动态类型相同，但是这个动态类型是不可比较的（比如切片），将它们进行比较就会失败并且 panic：
</p>
<div class="org-src-container">
<pre class="src src-go">var x interface{} = []int{1, 2, 3}
fmt.Println(x == x) // panic: comparing uncomparable type []int
</pre>
</div>

<hr>

<p>
类型断言是一个使用在接口值上的操作。语法上它看起来像 <code>x.(T)</code> 被称为断言类型，这里 <code>x</code> 表示一个接口的类型和 <code>T</code> 表示一个类型。一个类型断言检查它操作对象的动态类型是否和断言的类型匹配。
</p>

<p>
这里有两种可能：
</p>
<ol class="org-ol">
<li><p>
如果断言的类型 <code>T</code> 是一个具体类型，然后类型断言检查 <code>x</code> 的动态类型是否和 <code>T</code> 相同。如果这个检查成功了，类型断言的结果是 <code>x</code> 的动态值，当然它的类型是 T。换句话说，具体类型的类型断言从它的操作对象中获得具体的值。如果检查失败，接下来这个操作会抛出 panic
</p>
<div class="org-src-container">
<pre class="src src-go">var w io.Writer
w = os.Stdout
f := w.(*os.File)      // success: f == os.Stdout
c := w.(*bytes.Buffer) // panic: interface holds *os.File, not *bytes.Bufferc
</pre>
</div></li>
<li><p>
如果断言的类型 <code>T</code> 是一个接口类型，然后类型断言检查 <code>x</code> 的动态类型是否匹配 <code>T</code> 接口。如果成功，就相当于将 <code>x</code> 转换为了 <code>T</code> 接口类型，否则抛出 panic
</p>
<div class="org-src-container">
<pre class="src src-go">var w io.Writer
w = os.Stdout
rw := w.(io.ReadWriter) // success: *os.File has both Read and Write
w = new(ByteCounter)
rw = w.(io.ReadWriter) // panic: *ByteCounter has no Read method
</pre>
</div></li>
</ol>

<p>
当然，如果断言操作的对象是一个 <code>(nil, nil)</code> 接口值，那么不论被断言的类型是什么这个类型断言都会失败。
</p>

<p>
通过如下方式可以避免失败时抛出 panic 错误，这是很有用的特性：
</p>
<div class="org-src-container">
<pre class="src src-go">v, ok := i.(T)

// example
if f, ok := w.(*os.File); ok {
    // ...use f...
}
</pre>
</div>

<p>
也可以通过 <code>switch type</code> 语句根据具体的类型进行不同的操作：
</p>
<div class="org-src-container">
<pre class="src src-go">switch x := x.(type) {
case T:
    // here v has type T
case S:
    // here v has type S
default:
    // no match; here v has the same type as i
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org3e5cedd" class="outline-2">
<h2 id="org3e5cedd"><span class="section-number-2">9</span> 并发</h2>
<div class="outline-text-2" id="text-9">
<p>
Go 并发建立在 Goroutines 和 Channels 的基础上，可以将 Goroutines 看做是 Go 运行时管理的轻量级线程（虽然并不是），通过关键字 <code>go</code> 启动一个 Goroutines：
</p>
<div class="org-src-container">
<pre class="src src-go">go function(argument...)
</pre>
</div>

<p>
其中，函数和参数的计算在当前 Goroutines 中完成，而函数的执行在新的 Goroutines 中完成。
</p>

<p>
注：Goroutines 不是线程，当 <code>main</code> 方法退出后没有其他线程的情况下 Goroutines 就不会继续执行了。
</p>

<p>
Channels 可以看做是一个管道，可以通过 <code>&lt;-</code> 操作符接收或传送值，它的零值是 nil，两个相同类型的 channel 可以使用 == 运算符比较。如果两个 channel 引用的是相同的对象，那么比较的结果为真。一个 channel 也可以和 nil 进行比较：
</p>
<div class="org-src-container">
<pre class="src src-go">ch &lt;- v    // Send v to channel ch.
v := &lt;-ch  // Receive from ch, and assign value to v.
</pre>
</div>

<p>
Channels 必须在使用前通过 <code>make</code> 函数创建：
</p>
<div class="org-src-container">
<pre class="src src-go">ch := make(chan int)
</pre>
</div>

<p>
比如：
</p>
<div class="org-src-container">
<pre class="src src-go">func sum(s []int, c chan int) {
  sum := 0
  for _, v := range s {
    sum += v
  }
  c &lt;- sum // send sum to c
}

func main() {
  s := []int{7, 2, 8, -9, 4, 0}

  c := make(chan int)
  go sum(s[:len(s)/2], c)
  go sum(s[len(s)/2:], c)
  x, y := &lt;-c, &lt;-c // receive from c

  fmt.Println(x, y, x+y)
}
</pre>
</div>

<p>
可以为 Channels 定义缓冲区的大小，Channels 只在缓冲区满或空的情况下阻塞，感觉和阻塞队列差不多：
</p>
<div class="org-src-container">
<pre class="src src-go">func main() {
  ch := make(chan int, 2)
  ch &lt;- 1
  ch &lt;- 2
  fmt.Println(&lt;-ch)
  fmt.Println(&lt;-ch)
}
</pre>
</div>

<p>
可以使用 <code>close</code> 函数关闭一个 Channels（只能关闭一次），向一个关闭了的 Channels 传送值会抛出异常，接收时可以通过如下方式判断是否关闭：
</p>
<div class="org-src-container">
<pre class="src src-go">v, ok := &lt;-ch
</pre>
</div>

<p>
也可以用在 <code>for range</code> 循环中，这样循环会在 Channels 关闭时结束：
</p>
<div class="org-src-container">
<pre class="src src-go">for i := range c {
}
</pre>
</div>

<p>
可以使用 Select 语句同时等待多个 Channels，当有 Channels 准备好以后，就可以执行对应的操作，多个准备好就随机选择一个：
</p>
<div class="org-src-container">
<pre class="src src-go">package main

import "fmt"

func fibonacci(c, quit chan int) {
  x, y := 0, 1
  for {
    select {
    case c &lt;- x:
      x, y = y, x+y
    case &lt;-quit:
      fmt.Println("quit")
      return
    }
  }
}

func main() {
  c := make(chan int)
  quit := make(chan int)
  go func() {
    for i := 0; i &lt; 10; i++ {
      fmt.Println(&lt;-c)
    }
    quit &lt;- 0
  }()
  fibonacci(c, quit)
}

</pre>
</div>

<p>
Select 可以有默认项：
</p>
<div class="org-src-container">
<pre class="src src-go">func main() {
  tick := time.Tick(100 * time.Millisecond)
  boom := time.After(500 * time.Millisecond)
  for {
    select {
    case &lt;-tick:
      fmt.Println("tick.")
    case &lt;-boom:
      fmt.Println("BOOM!")
      return
    default:
      fmt.Println("    .")
      time.Sleep(50 * time.Millisecond)
    }
  }
}
</pre>
</div>

<p>
channels 的容量可以在 make 时指定，并通过 len 函数判断已用的长度。
</p>
</div>
</div>

<div id="outline-container-orgcd8ed10" class="outline-2">
<h2 id="orgcd8ed10"><span class="section-number-2">10</span> 并发控制</h2>
<div class="outline-text-2" id="text-10">
<p>
我们可以通过 channel 来进行并发控制，但 Go 也提供了预置的工具，使用互斥锁 sync.Mutex，它有 Lock 和 UnLock 两个方法：
</p>
<div class="org-src-container">
<pre class="src src-go">// SafeCounter is safe to use concurrently.
type SafeCounter struct {
  v   map[string]int
  mux sync.Mutex
}

// Inc increments the counter for the given key.
func (c *SafeCounter) Inc(key string) {
  c.mux.Lock()
  // Lock so only one goroutine at a time can access the map c.v.
  c.v[key]++
  c.mux.Unlock()
}

// Value returns the current value of the counter for the given key.
func (c *SafeCounter) Value(key string) int {
  c.mux.Lock()
  // Lock so only one goroutine at a time can access the map c.v.
  defer c.mux.Unlock()
  return c.v[key]
}

func main() {
  c := SafeCounter{v: make(map[string]int)}
  for i := 0; i &lt; 1000; i++ {
    go c.Inc("somekey")
  }

  time.Sleep(time.Second)
  fmt.Println(c.Value("somekey"))
}
</pre>
</div>

<p>
可以用 <code>defer mutex.UnLock</code> 保证函数推出时会执行 Unlock 逻辑，但是锁粒度会变大。
</p>

<p>
注：sync.Mutex 是不可以重入的！
</p>

<p>
其他的锁：
</p>
<div class="org-src-container">
<pre class="src src-go">sync.RWMutex  // RLock, RUnlock, Locl, Unlock
</pre>
</div>

<p>
Go 没有提供类似 volatile 的机制，所以可能的话，将变量限定在 goroutine 内部，如果是多个 goroutine 都需要访问的变量，使用互斥条件来访问。
</p>

<p>
Go 下并发环境下的惰性初始化可以通过 sync.Once 完成：
</p>
<div class="org-src-container">
<pre class="src src-go">var icons map[string]image.Image

func loadIcons() {
  icons = map[string]image.Image{
    "spades.png":   loadIcon("spades.png"),
    "hearts.png":   loadIcon("hearts.png"),
    "diamonds.png": loadIcon("diamonds.png"),
    "clubs.png":    loadIcon("clubs.png"),
  }
}

var loadIconsOnce sync.Once

// Concurrency-safe.
func Icon(name string) image.Image {
  loadIconsOnce.Do(loadIcons)
  return icons[name]
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org2039138" class="outline-2">
<h2 id="org2039138"><span class="section-number-2">11</span> 反射</h2>
<div class="outline-text-2" id="text-11">
<p>
我们知道接口底层持有 <code>(value, type)</code> 元组，可以通过 <code>reflect.Type</code> 和 <code>reflect.Value</code> 获取操作这两个信息：
</p>
<div class="org-src-container">
<pre class="src src-go">func TypeOf(i interface{}) Type
func ValueOf(i interface{}) Value
</pre>
</div>

<p>
可以通过 <code>reflect.Value.Kind</code> 方法对类型进行判断：
</p>
<div class="org-src-container">
<pre class="src src-go">func formatAtom(v reflect.Value) string {
  switch v.Kind() {
  case reflect.Invalid:
    return "invalid"
  case reflect.Int, reflect.Int8, reflect.Int16,
    reflect.Int32, reflect.Int64:
    return strconv.FormatInt(v.Int(), 10)
  case reflect.Uint, reflect.Uint8, reflect.Uint16,
    reflect.Uint32, reflect.Uint64, reflect.Uintptr:
    return strconv.FormatUint(v.Uint(), 10)
    // ...floating-point and complex cases omitted for brevity...
  case reflect.Bool:
    return strconv.FormatBool(v.Bool())
  case reflect.String:
    return strconv.Quote(v.String())
  case reflect.Chan, reflect.Func, reflect.Ptr, reflect.Slice, reflect.Map:
    return v.Type().String() + " 0x" +
      strconv.FormatUint(uint64(v.Pointer()), 16)
  default: // reflect.Array, reflect.Struct, reflect.Interface
    return v.Type().String() + " value"
  }
}
</pre>
</div>

<p>
对不同类型的值的获取：
</p>
<div class="org-src-container">
<pre class="src src-go">func display(path string, v reflect.Value) {
    switch v.Kind() {
    case reflect.Invalid:
	fmt.Printf("%s = invalid\n", path)
    case reflect.Slice, reflect.Array:
	for i := 0; i &lt; v.Len(); i++ {
	    display(fmt.Sprintf("%s[%d]", path, i), v.Index(i))
	}
    case reflect.Struct:
	for i := 0; i &lt; v.NumField(); i++ {
	    fieldPath := fmt.Sprintf("%s.%s", path, v.Type().Field(i).Name)
	    display(fieldPath, v.Field(i))
	}
    case reflect.Map:
	for _, key := range v.MapKeys() {
	    display(fmt.Sprintf("%s[%s]", path,
		formatAtom(key)), v.MapIndex(key))
	}
    case reflect.Ptr:
	if v.IsNil() {
	    fmt.Printf("%s = nil\n", path)
	} else {
	    display(fmt.Sprintf("(*%s)", path), v.Elem())
	}
    case reflect.Interface:
	if v.IsNil() {
	    fmt.Printf("%s = nil\n", path)
	} else {
	    fmt.Printf("%s.type = %s\n", path, v.Elem().Type())
	    display(path+".value", v.Elem())
	}
    default: // basic types, channels, funcs
	fmt.Printf("%s = %s\n", path, formatAtom(v))
    }
}
</pre>
</div>

<p>
可以通过 <code>reflect.Value</code> 修改值，需要目标对象是可以被取址的，这通常需要通过 <code>reflect.ValueOf(&amp;x)</code> 的形式创建 <code>Value</code> 对象。
</p>

<p>
结构体字段的标签可以通过 <code>v.Type().Field(i).Tag</code> 来获取操作。
</p>

<p>
获取方法：
</p>
<div class="org-src-container">
<pre class="src src-go">func Print(x interface{}) {
  // reflect.Type 同理
  v := reflect.ValueOf(x)
  t := v.Type()
  fmt.Printf("type %s\n", t)

  for i := 0; i &lt; v.NumMethod(); i++ {
    methType := v.Method(i).Type()
    fmt.Printf("func (%s) %s%s\n", t, t.Method(i).Name,
      strings.TrimPrefix(methType.String(), "func"))
  }
}
</pre>
</div>

<p>
需要注意，基于反射的代码通常比正常的代码运行速度慢一到两个数量级，对于性能要求较高的场景应该考虑使用其他方式替代。
</p>

<p>
可以参考：
</p>
<ul class="org-ul">
<li><a href="https://books.studygolang.com/gopl-zh/ch12/ch12.html">反射 · Go语言圣经</a></li>
</ul>
</div>
</div>

<div id="outline-container-org07dd093" class="outline-2">
<h2 id="org07dd093"><span class="section-number-2">12</span> 底层编程</h2>
<div class="outline-text-2" id="text-12">
<p>
Go 语言的实现刻意隐藏了很多底层细节，使用 unsafe 包可以在一定程度上摆脱 Go 语言规则带来的限制。这个包是采用特殊方式实现的包。虽然它可以和普通包一样的导入和使用，但它实际上是由编译器实现的。它提供了一些访问语言内部特性的方法，特别是内存布局相关的细节。
</p>

<p>
可以通过 Sizeof、Alignof 和 Offsetof 获取类型大小、对齐倍数和偏移量等信息，这在使用指针操作值的时候是很有用的：
</p>
<div class="org-src-container">
<pre class="src src-go">var x struct {
  a bool
  b int16
  c []int
}

// 32 bit os
// Sizeof(x)   = 16  Alignof(x)   = 4
// Sizeof(x.a) = 1   Alignof(x.a) = 1 Offsetof(x.a) = 0
// Sizeof(x.b) = 2   Alignof(x.b) = 2 Offsetof(x.b) = 2
// Sizeof(x.c) = 12  Alignof(x.c) = 4 Offsetof(x.c) = 4

// 64 bit os
// Sizeof(x)   = 32  Alignof(x)   = 8
// Sizeof(x.a) = 1   Alignof(x.a) = 1 Offsetof(x.a) = 0
// Sizeof(x.b) = 2   Alignof(x.b) = 2 Offsetof(x.b) = 2
// Sizeof(x.c) = 24  Alignof(x.c) = 8 Offsetof(x.c) = 8
</pre>
</div>

<p>
而 Pointer 就更加爽了，可以包含任意类型变量的地址，然后通过其他方式来操作。
</p>
</div>
</div>

<div id="outline-container-orgd2ce856" class="outline-2">
<h2 id="orgd2ce856"><span class="section-number-2">13</span> 相关链接</h2>
<div class="outline-text-2" id="text-13">
<ul class="org-ul">
<li><a href="https://draveness.me/golang/">Go 语言设计与实现 | Go 语言设计与实现</a></li>
<li><a href="https://chai2010.cn/advanced-go-programming-book/">Introduction · Go语言高级编程</a></li>
<li><a href="https://tour.golang.org/welcome/1">A Tour of Go</a></li>
<li><a href="https://books.studygolang.com/gopl-zh/">Go 语言圣经</a></li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
版权声明：本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
<div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_shortname = 'rgb-24bit';
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
</div>
</body>
</html>
