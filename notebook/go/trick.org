#+TITLE:      Go Trick

* 目录                                                    :TOC_4_gh:noexport:
- [[#类型转换][类型转换]]
- [[#uintptr--unsafepointer][uintptr & unsafe.Pointer]]
- [[#short-variable-declarations][Short variable declarations]]
- [[#匿名字段][匿名字段]]
- [[#type-switch][type switch]]
- [[#comparison-operators][Comparison operators]]

* 类型转换
  当两个结构体忽略 tag 后拥有相同的底层类型，那么就可以进行显示类型转换：
  #+begin_quote
  A non-constant value x can be converted to type T in any of these cases:
  + ignoring struct tags (see below), x's type and T have identical underlying types.
  + ignoring struct tags (see below), x's type and T are pointer types that are not defined types, and their pointer base types have identical underlying types.
  #+end_quote

  参考：
  + [[https://golang.org/ref/spec#Conversions][Conversions ¶]]
    
* uintptr & unsafe.Pointer
  Go 中的指针是不支持指针偏移运算的，也就是说，指针的值要么是固定的，要么通过取址操作给它一个新值。

  但是，我们可以通过将指针转换为 uintptr 来绕过这一限制。

  uintptr 是 Go 的内置类型，是能存储指针的整型，能够进行整数运算，此时，通过搭配 unsafe.Offsetof 我们就可以得到结构体某个字段的偏移地址，然后进行操作：
  #+begin_src go
    pb := (*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(&x)) + unsafe.Offsetof(x.b)))
  #+end_src

  这里需要注意的是，不要试图引入一个 uintptr 类型的临时变量，因为有时候垃圾回收器会移动一些变量以降低内存碎片等问题。

  当一个变量被移动，所有的保存改变量旧地址的指针必须同时被更新为变量移动后的新地址。从垃圾收集器的视角来看，一个 unsafe.Pointer 是一个指向变量的指针，
  因此当变量被移动是对应的指针也必须被更新；但是 uintptr 类型的临时变量只是一个普通的数字，所以其值不应该被改变。

  也就是说，下面的代码存在安全隐患：
  #+begin_src go
    tmp := uintptr(unsafe.Pointer(&x)) + unsafe.Offsetof(x.b)
    pb := (*int16)(unsafe.Pointer(tmp))
  #+end_src

  参考：
  + [[https://www.cnblogs.com/sunsky303/p/11820500.html][你不知道的 Go unsafe.Pointer uintptr 原理和玩法 - sunsky303 - 博客园]]

* Short variable declarations
  在满足下列条件时，已被声明的变量 v 可出现在 := 声明中：
  + 本次声明与已声明的 v 处于同一作用域中（若 v 已在外层作用域中声明过，则此次声明会创建一个新的变量）
  + 在初始化中与其类型相应的值才能赋予 v，且
  + 在此次声明中至少另有一个变量是新声明的

* 匿名字段
  我们可以利用匿名字段的特性，定义一个接口并提供默认的实现，这时，只要其他结构体包含该匿名字段，那么，它就实现了该接口。

* type switch
  使用 type switch 的时候，可以通过如下方式避免再次进行类型断言：
  #+begin_src go
    switch v := i.(type) {
    case T:
        // here v has type T
    case S:
        // here v has type S
    default:
        // no match; here v has the same type as i
    }
  #+end_src

* Comparison operators
  在使用 struct{}{} 作为 context 的 key 的时候遇到的问题，两个包下面的 key 值被判相等了 QAQ

  原因：
  #+begin_quote
  + Interface values are comparable. Two interface values are equal if they have identical dynamic types and equal dynamic values or if both have value nil.
  + Struct values are comparable if all their fields are comparable. Two struct values are equal if their corresponding non-blank fields are equal.
  #+end_quote

  context 的 key 就被转换为 interface 存储，根据 [[file:go.org::*复合类型][复合类型]] 中的描述，当两个结构体不存在 private 字段，同时 public 字段相同时，他们的类型便是一样的。

  而 struct{}{}，不存在任何字段，因此，在任意地方，它们的类型都是一样的，值也是一样的。

  可以通过声明一个类型的方式避免这种情况：
  #+begin_src go
    type TA struct{}
    type TB struct{}
  #+end_src

  这里 TA 和 TB 是两个类型，同时，TA{} 和 TA{} 的值相等。

  参考：
  + [[https://en.wikipedia.org/wiki/Bottom_type][Bottom type - Wikipedia]]
  + [[https://golang.org/ref/spec#Comparison_operators][Comparison operators ¶]]
  + [[https://en.wikipedia.org/wiki/Unit_type][Unit type - Wikipedia]]

