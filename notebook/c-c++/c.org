#+TITLE:      C 语言笔记

* 目录                                                    :TOC_4_gh:noexport:
- [[#语法相关][语法相关]]
  - [[#赋值语句][赋值语句]]
  - [[#逗号][逗号]]
  - [[#自增运算][自增运算]]
  - [[#声明和定义][声明和定义]]
  - [[#字符串字面量][字符串字面量]]
- [[#类型转换][类型转换]]
  - [[#有符号数--无符号数][有符号数 & 无符号数]]
  - [[#隐式类型转换规则][隐式类型转换规则]]
- [[#内存分区与生命周期问题][内存分区与生命周期问题]]
  - [[#关键字-static-的作用][关键字 static 的作用]]
- [[#预处理器][预处理器]]
  - [[#替换文本宏的使用][替换文本宏的使用]]
    - [[#关键字参数的模拟实现][关键字参数的模拟实现]]
- [[#数组相关][数组相关]]
  - [[#数组的初始化][数组的初始化]]
  - [[#数组大小的获取][数组大小的获取]]
  - [[#柔性数组的定义][柔性数组的定义]]
- [[#结构体相关][结构体相关]]
  - [[#结构体字段内存对齐][结构体字段内存对齐]]
  - [[#结构体的嵌套与位域][结构体的嵌套与位域]]
  - [[#结构体的初始化][结构体的初始化]]
- [[#枚举类型][枚举类型]]

* 语法相关
** 赋值语句
   + 条件语句中的赋值语句：
     #+BEGIN_SRC C
       if (x = func()) {
         // ...
       }
     #+END_SRC

   + 连续赋值语句，分为在声明时和使用时两种情况：
     #+BEGIN_SRC C
       int x = y = 2;  // 声明时 y 并没有定义，所以会出错
       x = y = 2;      // 使用时， x 和 y 都已定义，可以这样赋值
     #+END_SRC

** 逗号
   通过逗号可以将两个语句放在同一行：
   #+BEGIN_SRC C
     x = func(10), y = func(20);  // 可以这样将简短的语句放在一行
   #+END_SRC

   在 Java 中是不可以这样操作的。

** 自增运算
   + 自增运算通常的使用场景：
     #+BEGIN_SRC C
       #include <stdio.h>

       int main(void) {
         int num = 0, count = 0;

         for (int i = 0; i < 10; ++i) {
           num = count++;  // 7
         }

         return 0;
       }
     #+END_SRC

     第七行对应汇编代码：
     #+BEGIN_SRC asm
         // count in -4(rbb), num in -8(rbp)
         0x0000000000401594 <+36>:    mov    -0x4(%rbp),%eax
         0x0000000000401597 <+39>:    lea    0x1(%rax),%edx
         0x000000000040159a <+42>:    mov    %edx,-0x4(%rbp)
         0x000000000040159d <+45>:    mov    %eax,-0x8(%rbp)
     #+END_SRC

   + 当做操作数和右操作数相同时：
     #+BEGIN_SRC C
       #include <stdio.h>

       int main(void) {
         int count = 0;

         for (int i = 0; i < 10; ++i) {
           count = count++;  // 7
         }

         return 0;
       }
     #+END_SRC

     第七行对应汇编代码：
     #+BEGIN_SRC asm
         // count in -4(rbp)
         0x000000000040158d <+29>:    mov    -0x4(%rbp),%eax
         0x0000000000401590 <+32>:    lea    0x1(%rax),%edx
         0x0000000000401593 <+35>:    mov    %edx,-0x4(%rbp)
         0x0000000000401596 <+38>:    mov    %eax,-0x4(%rbp)
     #+END_SRC

   + 具体的执行过程：
     1) 取有右操作数的值放入寄存器 eax
     2) eax + 1 放入寄存器 edx
     3) edx 的值放入右操作数地址
     4) eax 的值放入左操作数地址

   + 导致的结果理解：
     在这样的操作中，编译器使用了两个寄存器来保存 *自增前* 和 *自增后* 的值。

     然后首先将 *自增后* 的值保存，然后将 *自增前* 的值赋给 *左值*.

     因此 ~count = count++~ 不会改变 ~count~ 的值。

     这是一个运算优先级的问题。先赋值在自增指的只是赋给 *左值* 的值是 *自增前* 的值。

     而 ~++count~ 赋的是 *自增后* 的值。

** 声明和定义
   1) 声明可以出现在任意作用域，包括在函数体内部
      #+BEGIN_SRC C
        int main(int argc, char* argv[]) {
          int func(int, int);
        }
      #+END_SRC

   2) 函数定义不能嵌套，但结构体可以
      #+BEGIN_SRC C
        int main(int argc, char* argv[]) {
          ing func(int a, int b) {
            // error
          }
        }
      #+END_SRC

      PS: GCC 支持嵌套函数

   3) 枚举声明的同时必须定义
      #+BEGIN_SRC C
        typedef enum COLOR {
          RED, GREEN, BLUE
        } COLOR;
      #+END_SRC

   4) 枚举定义后其成员在定义它的 *作用域* 全局有效

   参考：[[https://zh.cppreference.com/w/c/language/declarations][声明 - cppreference.com]]

** 字符串字面量
   支持的字符串字面量形式及支持该新式的标准：
   #+BEGIN_SRC C
     char* str = "Test string";
     char* str = u8"Test string";    // C11
     char16_t* str = u"Test string"; // C11
     char32_t* str = U"Test string"; // C11
     wchar_t* str = L"Test string";
   #+END_SRC

   若在字符串字面量中合法十六进制数位后随十六进制转义，则这会作为非法的转义序列导致编译失败，但能以字符串连接为变通方式：
   #+BEGIN_SRC C
     //char* p = "\xfff"; // 错误：十六进制转义在范围外
     char* p = "\xff""f"; // OK ：字面量为 char[3] ，保有 {'\xff', 'f', '\0'}
   #+END_SRC

   + [[https://zh.cppreference.com/w/c/language/string_literal][字符串字面量 - cppreference.com]]

* 类型转换
** 有符号数 & 无符号数
   整数字面值默认为 *有符号数*, 定义无符号数可以使用后缀 ~u~ 或 ~U~.

   如果一个运算同时存在有符号数和无符号数， 那么会隐式的将有符号数转换为无符号数：
   #+BEGIN_SRC C
     // 1st. -2147483647 - 1 = -2147483648
     // 2st. -2147483648 ==> 2147483648U
     // 3st. 2147483647 > 2147483648U

     2147483647U > -2147483647 - 1;  // false
   #+END_SRC

** 隐式类型转换规则
   C 语言中隐式类型转换的一般规则：将 *比较窄* 的操作数转换为 *比较宽* 的操作数。
   #+BEGIN_EXAMPLE
     char --> short --> int --> unsigned --> long --> double <-- float
   #+END_EXAMPLE
  
   + [[https://zh.cppreference.com/w/c/language/conversion][隐式转换 - cppreference.com]]

* 内存分区与生命周期问题
  + 栈区，由编译器在需要的时候分配，在不需要的时候自动清处的变量的存储区。里面的变量通常是局部变量、函数参数等。

  + 堆区，new 操作（C++）分配的内存块，它们的释放编译器不去管， 由应用程序去控制，一般一个 ~new~ 就要对应一个 ~delete~.
    如果程序没有释放掉，那么在程序结束后，操作系统会自动回收。

  + 自由存储区，由 ~malloc~ 等分配的内存块，它和堆十分相似，不过它是用 ~free~ 来结束自己的生命的。

  + 全局/静态存储区，局部变量和静态变量被分配到同一块内存中，在 ~C~ 语言中，全局变量又分为初始化的和未初始化的，
    在 ~C++~ 里面没有这个区分， 它们共同占用同一块内存区。

  + 常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。但可以通过指针直接修改。

** 关键字 static 的作用
   1) 在修饰变量的时候，static 修饰的静态局部变量只执行一次，而且延长了局部变量的生命周期，直到程序运行结束以后才释放
   2) static 修饰全局变量的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问，即便是 extern 外部声明也不可以
   3) static 修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用
   4) static 修饰的局部变量存放在全局数据区的静态变量区, 初始化的时候自动初始化为 0
     
   使用：
   1) 不想被释放的时候，可以使用 static 修饰。比如修饰函数中存放在栈空间的数组。如果不想让这个数组在函数调用结束释放可以使用 static 修饰
   2) 考虑到数据安全性（当程序想要使用全局变量的时候应该先考虑使用 static）

* 预处理器
  C 语言中 *宏* 是一个很重要的工具，和 C++ 不同，C 语言本身的语法特性少的可伶，只能通过宏的方式来实现灵活的编程方式。

  需要注意的是，预处理是发生在编译之前的处理过程，使用宏其实就相当于通过一些指令指示预处理器来修改你的源代码，这样是再说，
  C 语言不存在名称空间这种东西，它都是直接把文件中的内容包含进来的，所以，头文件和源代码的分离很重要。

  在使用宏的过程中，如果内容太多一行装不下，可以用 ~\~ 换行：
  #+BEGIN_SRC C
    #define EXAMPLE for (int i = 0; i < 10; ++i) { \
      printf("Hello World !");                     \
      }
  #+END_SRC

  可以用操作符 ~##~ 链接宏中的两个标识符：
  #+BEGIN_SRC C
    #define FUNCTION(name, a) int fun_##name(int x) { return (a) * x; }
  #+END_SRC

  可以通过宏 ~__FILE__~ 得到当前的文件名。

  除了宏以外，预处理还会做的一些事：
  + 预处理器会将仅用 *空白字符* 分隔的字符串常量序列串联起来：
    #+BEGIN_EXAMPLE
      "123"  "456" ==> "123456"
    #+END_EXAMPLE

  预处理器的相关内容很多，可以参考：[[https://zh.cppreference.com/w/c/preprocessor][预处理器 - cppreference.com]].

** 替换文本宏的使用
   通过宏 *__VA_ARGS__* 定义可变参数宏：
   #+BEGIN_SRC C
     #define F(...) func(__VA_ARGS__)
   #+END_SRC

   *#* 出现在 *__VA_ARGS__* 前时，将整个展开的 *__VA_ARGS__* 放入引号：
   #+BEGIN_SRC C
     #define showlist(...) puts(#__VA_ARGS__)
     showlist();             // 展开成 puts("")
     showlist(1, "x", int);  // 展开成 puts("1, \"x\", int")
   #+END_SRC

   一些编译器提供允许 *##* 出现在逗号后和 *__VA_ARGS__* 前的扩展，在此情况下 *##* 在 *__VA_ARGS__* 非空时无效，
   但在 *__VA_ARGS__* 为空时移除逗号。

   这使得可以定义如 fprintf (stderr, format, ##__VA_ARGS__) 的宏：
   #+BEGIN_SRC C
     #define pf(...) fprintf(stderr, format, ##__VA_ARGS__)

     pf();        // fprintf(stderr, format)
     pf(a, b, c)  // fprintf(stderr, format, a, b, c)
   #+END_SRC

   如下情况会导致编译出错：
   #+BEGIN_SRC C
     printf("string", );
   #+END_SRC

*** 关键字参数的模拟实现
    #+BEGIN_SRC C
      typedef struct KWARGS {
        int key;
        int val;
      } KWARGS;

      int func(KWARGS kwargs) {
        return kwargs.key + kwargs.val;
      }

      #define func(...) func((KWARGS){__VA_ARGS__})

      func(.key = 10, .val = 100);  // func(KWARGS {.key = 10, .val = 100})
    #+END_SRC

    实质上就是通过文本替换宏创建匿名的结构体变量，大括号前面必须有分号、逗号或括号。

* 数组相关
** 数组的初始化
   #+BEGIN_SRC C
     int arr[] = {1, 2, 3};   // int arr[3] = {1, 2, 3}
     int arr[4] = {1, 2, 3};  // int arr[4] = {1, 2, 3, 0}
   #+END_SRC

** 数组大小的获取
   #+BEGIN_SRC C
     sizeof(arr) / sizeof(arr[0]);
   #+END_SRC

** 柔性数组的定义
   将结构体最后一个成员定义为长度为 0 的数组，这个数组的实际大小为 0，
   数组的地址就是结构体后内存区域的地址。

   实际的例子：
   #+BEGIN_SRC C
     struct Example {
       int num;
       char data[];
     }
   #+END_SRC

   + [[https://coolshell.cn/articles/11377.html][C 语言结构体里的成员数组和指针 | 酷 壳 - CoolShell]]

* 结构体相关
** 结构体字段内存对齐
   结构体的内存对齐只要能满足对齐规则，就尽量少补，因此，结构体内部字段的字段对齐只发生在下一个字段无法对齐的情况：
   #+BEGIN_SRC C
     struct Example {  // 0x4
       int i;   // 4, 4 % 4 == 0
       char c;  // 5, 5 % 1 == 0
       char d;  // 8, 8 % 8 == 0
       long j;  // 16
     }
   #+END_SRC

** 结构体的嵌套与位域
   嵌套的结构体只能在结构体内部定义变量, 在结构体外不能使用：
   #+BEGIN_SRC C
     struct Outside {
       static Inside {
         int val;
       } _inside;
       int val;
     };

     struct Outside out;

     out.val = 0;
     out._insiade.val = 0;
   #+END_SRC

   对于结构体中不需要占用一个完整的字节的内容，可以通过位域让它们共享一段内存：
   #+BEGIN_SRC C
     typedef {
       unsigned int readable : 1;
       unsigned int writable : 1;
     } Mode;
   #+END_SRC  

   + [[http://www.cnblogs.com/bigrabbit/archive/2012/09/20/2695543.html][C 结构体之位域 - 大兔子_快跑 - 博客园]]

** 结构体的初始化
   结构体可以使用的初始化方式：
   #+BEGIN_SRC C
     typedef struct Pair {
       int left;
       int right;
     } Pair;

     // 顺序初始化
     Pair pair = {10, 20};

     // 乱序初始化
     Pair pair = {
       .left = 10,
       .right = 20,
     };
   #+END_SRC

* 枚举类型
  枚举值在其作用域中可直接使用，不需要使用枚举类型名访问。

  #+BEGIN_SRC C
    enum DAY {
      MON=1, TUE, WED, THU, FRI, SAT, SUN
    };

    enum DAY yesterday = MON;
  #+END_SRC

  枚举声明可以在函数体内部，也可以在函数体外，结构体，联合体一样。

  + [[https://www.cnblogs.com/JCSU/articles/1299051.html][C语言详解 - 枚举类型]]

