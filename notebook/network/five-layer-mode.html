<!DOCTYPE html>
<html lang="zh-CN">
<head>
<!-- 2021-01-09 周六 19:44 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>计算机网络 - 谢希仁 - 五层模型</title>
<meta name="generator" content="Org mode">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="https://rgb-24bit.github.io/blog/misc/style.css">
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-125860001-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-125860001-1');
</script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="https://rgb-24bit.github.io/notebook/"> UP </a>
 |
 <a accesskey="H" href="https://rgb-24bit.github.io"> HOME </a>
</div><div id="content">
<h1 class="title">计算机网络 - 谢希仁 - 五层模型</h1>
<div id="table-of-contents">
<h2>&#30446;&#24405;</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org8395aed">1. 概述</a>
<ul>
<li><a href="#orgbc01f8b">1.1. 互联网的组成</a></li>
<li><a href="#orgd910861">1.2. 网络分类</a></li>
<li><a href="#org32ea24c">1.3. 性能指标</a></li>
<li><a href="#org6da5413">1.4. 分层模型</a></li>
</ul>
</li>
<li><a href="#org324c5cf">2. 物理层</a></li>
<li><a href="#org47f1d2b">3. 数据链路层</a>
<ul>
<li><a href="#org252116d">3.1. ARP 协议</a></li>
<li><a href="#orgeda9dee">3.2. 模 2 运算</a></li>
</ul>
</li>
<li><a href="#orgfdedce4">4. 网络层</a>
<ul>
<li><a href="#orgc18d59d">4.1. 分类的 IP 地址</a></li>
<li><a href="#org5efe7c8">4.2. 公网和私网划分</a></li>
<li><a href="#org06daeeb">4.3. 分组转发算法</a></li>
<li><a href="#org489bd0f">4.4. 子网划分和 NAT</a></li>
<li><a href="#org380d8fa">4.5. RIP 协议和 OSPF 协议</a></li>
</ul>
</li>
<li><a href="#orgeeb9c66">5. 运输层</a></li>
<li><a href="#org38a5f54">6. 应用层</a></li>
</ul>
</div>
</div>

<div id="outline-container-org8395aed" class="outline-2">
<h2 id="org8395aed"><span class="section-number-2">1</span> 概述</h2>
<div class="outline-text-2" id="text-1">
<p>
<b>重要事项：</b> 国内的计算机网络教材（谢希仁版）为了方便综合了 OSI 的七层模型和 TCP/IP 的四层模型搞了个五层模型出来，但是，这个模式只是为了方便教学而设置的，并非真实存在！！！
</p>

<p>
计算机网络中一些名词的含义：
</p>
<ul class="org-ul">
<li><code>Internet</code> - 中文译名为因特网或互联网，其中因特网为推荐的但未得到推广的译名，互联网这个译名最为流行</li>
<li><code>internet</code> - 互连网，泛指多个计算机网络互连而成的计算机网络</li>
<li>互联网是覆盖全球的，仅在局部范围互连起来的计算机网络只能称为互连网</li>
<li>互联网的基本特点是连通性和共享性，可以快速和网络中的其他用户传递信息，可以方便和其他用户共享资源</li>
<li>计算机网络由若干 <b>结点</b> 和连接这些结点的 <b>链路</b> 组成，结点可以是计算机、集线器、交换机、路由等</li>
<li>计算机网络之间通过路由器连接起来就形成了互连网，也就是说：结点组成网络、网络组成互连网，与网络相连的计算机称为主机</li>
<li>互联网的标准化工作流程为：互联网草案 -&gt; 建议标准 RFC -&gt; 互联网标准 STD</li>
</ul>
</div>

<div id="outline-container-orgbc01f8b" class="outline-3">
<h3 id="orgbc01f8b"><span class="section-number-3">1.1</span> 互联网的组成</h3>
<div class="outline-text-3" id="text-1-1">
<p>
互联网的组成可以分为边缘部分和核心部分，边缘部分为连接在互联网上的所有主机，而核心部分是连接这些网络的路由器。
</p>

<p>
互联网边缘部分的主机又称为端系统，端系统之间的通信方式主要有：客户-服务器（C/S）方式和对等连接（P2P）方式。而核心部分的路由器的作用则是 <b>转发分组</b>, 
是实现 <b>分组交换</b> 的关键构建，通过分组交换的方式，可以避免一直占用通信资源，提高通信资源的利用率。
</p>

<p>
分组交换采用的是 <b>存储转发</b> 技术，将要发送的整块数据称为 <b>报文</b>, 将报文划分成等长的小数据段，每个数据段加上有必要的控制信息组成的 <b>首部</b> 后，就构成一个分组。分组又称为 <b>包</b>, 包的首部 称为 <b>包头</b>.
</p>

<p>
分组交换的优点为：高效、灵活、迅速、可靠，但是，路由器存储转发需要排队，这会造成一定的时延。因此，当传送时间远大于建立连接的时间是，时延电路交换的传输效率较快。而分组交换便适合传输突发数据。
</p>

<p>
同时，路由器必须经常交换彼此掌握的路由信息，以便动态创建和维护路由器中的转发表。
</p>
</div>
</div>

<div id="outline-container-orgd910861" class="outline-3">
<h3 id="orgd910861"><span class="section-number-3">1.2</span> 网络分类</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>按照网络的作用范围划分：广域网 WAN、城域网 MAN、局域网 LAN、个人局域网 PAN、无线局域网 WLAN、虚拟局域网 VLAN</li>
<li>按照网络的使用者划分：公用网和专用网，公用网指电信公司出资建造的大型网络，所有愿意按照电信公司的规定缴纳费用的人都可以使用</li>
<li>接入网：用于把用户接入互联网的网络</li>
</ul>
</div>
</div>

<div id="outline-container-org32ea24c" class="outline-3">
<h3 id="org32ea24c"><span class="section-number-3">1.3</span> 性能指标</h3>
<div class="outline-text-3" id="text-1-3">
<p>
性能指标及其含义与计算方式：
</p>
<pre class="example">
|--------------+------------+------------+------------------------------------------+---------------------|
| 指标         | 子指标     | 基本单位   | 含义                                     | 计算方式            |
|--------------+------------+------------+------------------------------------------+---------------------|
| 速率         |            | bit/s、bps | 单位时间传输的 bit 数                    | 略                  |
|--------------+------------+------------+------------------------------------------+---------------------|
| 带宽         |            |            |                                          |                     |
|              | 频带宽度   | HZ         | 某信号具有的频带宽度                     | 略                  |
|              | 最高数据率 | bit/s      | 最大速率                                 | 略                  |
|--------------+------------+------------+------------------------------------------+---------------------|
| 吞吐量       |            | bit/s      | 实际速率                                 | 略                  |
|--------------+------------+------------+------------------------------------------+---------------------|
| 时延         |            |            |                                          |                     |
|              | 发送时延   | s          | 发送数据需要的时间                       | 数据帧长度/发送速率 |
|              | 传播时延   | s          | 电磁波在信道中传播一定距离需要花费的时间 | 信道长度/传播速率   |
|              | 处理时延   | s          | 处理分组数据的时间，GFW 增加的时延       |                     |
|              | 排队时延   | s          | 分组在路由器中的排队时间                 |                     |
|--------------+------------+------------+------------------------------------------+---------------------|
| 时延带宽积   |            | bit        | 以比特为单位的链路长度                   | 传播时延 x 带宽     |
|--------------+------------+------------+------------------------------------------+---------------------|
| 往返时间 RTT |            | s          | 数据发送后等待返回数据的时间             |                     |
|--------------+------------+------------+------------------------------------------+---------------------|
| 利用率       |            |            |                                          |                     |
|              | 信道利用率 |            | 信道有百分之几的时间有数据提供           |                     |
|              | 网络利用率 |            | 全网络信道利用率的加权平均值             |                     |
|--------------+------------+------------+------------------------------------------+---------------------|
</pre>

<p>
网络的利用率不是越高越好，令网络空闲时延为 D0， 当前时延为 D， 网络利用率为 U，那么： D = D0/(1 - U)
</p>
</div>
</div>

<div id="outline-container-org6da5413" class="outline-3">
<h3 id="org6da5413"><span class="section-number-3">1.4</span> 分层模型</h3>
<div class="outline-text-3" id="text-1-4">
<p>
OSI 七层模型、TCP/IP 四层模型和五层模型之间的关系：
</p>
<ul class="org-ul">
<li>五层模型是结合了 OSI 和 TCP/IP 模型的优点，用于概念解释的模型</li>
<li>TCP/IP 四层模型是事实上的国际标准，得到了市场的认可</li>
<li>OSI 七层模型是法律上的国际标准，但未得到广泛的使用</li>
</ul>

<p>
模型层次划分：
</p>
<pre class="example">
|------------+------------+------------+----------------------|
| OSI        | TCP/IP     | 五层协议   | 传输数据单元/协议    |
|------------+------------+------------+----------------------|
| 应用层     | 应用层     | 应用层     | 报文                 |
| 表示层     |            |            |                      |
| 会话层     |            |            |                      |
|------------+------------+------------+----------------------|
| 运输层     | 运输层     | 运输层     | TCP/UDP 数据报       |
|------------+------------+------------+----------------------|
| 网络层     | 网际层 IP  | 网络层     | IP 数据报（分组）/IP |
|------------+------------+------------+----------------------|
| 数据链路层 | 网络接口层 | 数据链路层 | 帧                   |
| 物理层     |            | 物理层     | 比特                 |
|------------+------------+------------+----------------------|
</pre>

<p>
图：
</p>
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E4%B8%83%E5%B1%82%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9B%BE.png">
</div>
</div>
</div>

<div id="outline-container-org324c5cf" class="outline-2">
<h2 id="org324c5cf"><span class="section-number-2">2</span> 物理层</h2>
<div class="outline-text-2" id="text-2">
<p>
在物理层上所传送的数据单位是比特。物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。
</p>

<p>
信道的概念：
</p>
<ul class="org-ul">
<li>信道一般是用来标识向某 <b>一个方向</b> 传送信息的媒体，因此，一条通信电路往往包含一条发送信道和接收信道</li>
<li>根据通信双方信息交互的方式可以分为：单向、双向交替、双向（全双工）同时通信</li>
</ul>

<p>
来自信源的信号通常称为基带信号，通常需要经过调制才能发送，调制方式有：
</p>
<ul class="org-ul">
<li>基带调制（编码）：对基带信号波形进行变换 ，包括：不归零制、归零值、曼切斯特编码、差分曼切斯特编码</li>
<li>带通调制：把基带信号评率范围搬移到较高的频段，包括：调幅、调频、调相</li>
</ul>

<p>
信道复用技术包括：频分复用、时分复用、波分复用、码分复用。
</p>
</div>
</div>

<div id="outline-container-org47f1d2b" class="outline-2">
<h2 id="org47f1d2b"><span class="section-number-2">3</span> 数据链路层</h2>
<div class="outline-text-2" id="text-3">
<p>
数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。
</p>

<p>
数据链路层需要解决的三个基本问题为：封装成帧、透明传输、差错控制：
</p>
<ul class="org-ul">
<li><p>
封装成帧是在得到上一层的数据后添加首部和尾部，构成一个帧，首部和尾部包含必要的控制信息
</p>

<p>
帧的数据部分的最大长度称为 MTU，当传递的数据是 ASCII 字符时，可以使用 SOH 和 EOT 字符作为边界字符
</p></li>

<li><p>
如果传输的数据包含了这些特殊字符，为了避免传输出错，需要对这些数据进行处理，达到透明传输：无论传输什么数据，都能无差错的传输
</p>

<p>
简单的处理方式是在每个特殊字符前面添加转义字符 ESC，在 ESC 前面也添加 ESC，读取时去掉就可以了
</p></li>

<li><p>
差错控制可以通过 CRC 循环效验实现，通过 CRC 算法生成冗余码添加到要传输的数据尾部，形成帧效验序列 FCS
</p>

<p>
通过差错控制只能达到无差错接受，不能达到可靠传输，因为只能保证接受到的数据是正确的，但不能避免丢失、重复、顺序紊乱
</p></li>
</ul>

<p>
需要注意不同协议传输的帧是不一样的，点对点协议 是 PPP 帧，而以太网-广播信道是 MAC 帧。
</p>
</div>

<div id="outline-container-org252116d" class="outline-3">
<h3 id="org252116d"><span class="section-number-3">3.1</span> ARP 协议</h3>
<div class="outline-text-3" id="text-3-1">
<p>
主机在连接到不同的网络时 IP 地址会发生改变，但是 MAC 地址不会发生变化，而底层发送数据依赖的也是 MAC 地址，使用 IP 的原因主要是为了屏蔽底层的细节。
</p>

<p>
因此，发送数据报时还需要找到目标 IP 对应的 MAC 地址，这一点通过 ARP 协议完成。
</p>

<p>
ARP 协议全称为地址解析协议，其工作原理十分简单：
</p>
<ol class="org-ol">
<li>在每一台主机上都设有一个 ARP 高速缓存，里面保存有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表</li>
<li>发送数据报找不到目标 IP 的 MAC 地址时，就向本局域网上的所有主机发送广播，符合目标 IP 地址的主机将自己的 MAC 发送回来</li>
<li>当目标 IP 不在本局域网上时，就由路由器来转发数据报，进而间接获取目标主机的 MAC 地址</li>
</ol>

<p>
ARP 分组的格式：
</p>
<ul class="org-ul">
<li>请求分组：本机 IP，本机硬件地址，目标 IP</li>
<li>响应分组：本机 IP，本机硬件地址</li>
</ul>

<p>
使用 ARP 的四种典型情况：
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">发送方</th>
<th scope="col" class="org-left">目标</th>
<th scope="col" class="org-left">操作</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">主机</td>
<td class="org-left">同网络上的其他主机</td>
<td class="org-left">直接发送请求分组，等待响应</td>
</tr>

<tr>
<td class="org-left">主机</td>
<td class="org-left">其他网络上的主机</td>
<td class="org-left">发送请求分组（广播）给路由器，剩下工作由路由器完成</td>
</tr>

<tr>
<td class="org-left">路由器</td>
<td class="org-left">同网络上的主机</td>
<td class="org-left">直接发送请求分组，等待响应</td>
</tr>

<tr>
<td class="org-left">路由器</td>
<td class="org-left">其他网络上的主机</td>
<td class="org-left">发送请求分组（广播）给另一个路由器</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgeda9dee" class="outline-3">
<h3 id="orgeda9dee"><span class="section-number-3">3.2</span> 模 2 运算</h3>
<div class="outline-text-3" id="text-3-2">
<p>
模 2 运算的核心就是异或运算：
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">运算</th>
<th scope="col" class="org-left">规则</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">模 2 加法</td>
<td class="org-left">异或</td>
</tr>

<tr>
<td class="org-left">模 2 减法</td>
<td class="org-left">异或</td>
</tr>

<tr>
<td class="org-left">模 2 乘法</td>
<td class="org-left">将每步的中间结果用模 2 加法的方式相加</td>
</tr>

<tr>
<td class="org-left">模 2 除法</td>
<td class="org-left">每步使用模 2 减法进行运算</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-orgfdedce4" class="outline-2">
<h2 id="orgfdedce4"><span class="section-number-2">4</span> 网络层</h2>
<div class="outline-text-2" id="text-4">
<p>
在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报，简称数据报。
</p>

<p>
网络层只向上提供简单灵活的、无连接的、尽最大努力交付的数据包服务，不提供服务质量的承诺，因此往往需要通过 TCP 协议来确保传输质量，其中，交付方式可以分为直接交付与间接交付：
</p>
<ul class="org-ul">
<li>直接交付：当目标主机就在本网络，就直接将数据报发送给目标主句，不经过路由器转发</li>
<li>间接交付：当目标主机不在本网络，就将数据报交付给路由器间接转发</li>
</ul>
</div>

<div id="outline-container-orgc18d59d" class="outline-3">
<h3 id="orgc18d59d"><span class="section-number-3">4.1</span> 分类的 IP 地址</h3>
<div class="outline-text-3" id="text-4-1">
<p>
分类的 IP 地址将 IP 地址划分为 5 类，分别为 A、B、C、D、E 类，其中：
</p>
<ul class="org-ul">
<li>A、B、C 类地址为单播地址，属于最常用的地址</li>
<li>D 类地址为多播地址，即：一对多通信</li>
<li>E 类地址属于保留地址</li>
</ul>

<p>
划分方式是将 IP 地址划分为两个部分，分别为网络号和主机号，不同网络的类型通过前缀区分。
</p>

<p>
A、B、C 三类网络地址中的保留地址：
</p>
<pre class="example">
|------+-----------------+--------------------------------------------------------------------------|
| 分类 |        保留地址 | 解释                                                                     |
|------+-----------------+--------------------------------------------------------------------------|
| A    |         0.0.0.0 | 网络号全为零表示本网络，主机号全为零表示本主机，即：表示本网络上的本主机 |
|      | 127.xxx.xxx.xxx | 网络号为 127，保留作为本地软件环回测试地址                               |
|------+-----------------+--------------------------------------------------------------------------|
| B    |       128.0.0.0 | 保留不做指派，最小网络地址为 128.1.0.0                                   |
|------+-----------------+--------------------------------------------------------------------------|
| C    |       192.0.0.0 | 保留不做指派，最小网络地址为 192.1.0.0                                   |
|------+-----------------+--------------------------------------------------------------------------|
</pre>

<p>
除了网络地址的划分以外，还有主机地址的划分，其中，主机号全为 0 和主机号全为 1 的地址都是不划分的，分别用作表示本主机和本网络上的所有主机使用。
</p>

<p>
特殊的 IP 地址汇总：
</p>
<ol class="org-ol">
<li>网络号全为 0 的 IP 地址，只存在于 A 类地址之中，表示本网络，只能作为源地址使用</li>
<li>主机号全为 0 的 IP 地址，表示本主机</li>
<li>主机号全为 1 的 IP 地址，表示本网络上的所有主机，只能作为广播地址使用</li>
<li>网络号为 127 的 IP 地址，只存在于 A 类地址之中，用于本地软件的环回测试</li>
<li>IP 地址 255.255.255.255，网络号和主机号都是 1，用于在本网络上进行广播，只能作为目的地址</li>
</ol>

<p>
IP 地址的重要特点：
</p>
<ol class="org-ol">
<li>IP 地址管理机构只分配网络号，主机号由分配到网络号的机构进行分配，路由器也只根据网络号转发分组</li>
<li>一个设备连接到两个网络上时必然存在两个 IP 地址，两个地址的网络号必然不同</li>
<li>一个网络是只具有相同网络号的主机的集合，也就是说，只要网络号一样，不管你是怎么连起来的，就都是一个网络</li>
<li>所有分配到网络号的网络都是平等的</li>
</ol>
</div>
</div>

<div id="outline-container-org5efe7c8" class="outline-3">
<h3 id="org5efe7c8"><span class="section-number-3">4.2</span> 公网和私网划分</h3>
<div class="outline-text-3" id="text-4-2">
<p>
早在 IPv4 规划的时候担心 IP 会有不足的情况，同时为了应付某些企业内部的网络设定，于是私有 IP (Private IP) 就产生了。私有 IP 也分别在 A, B, C 三类当中各保留一段作为私有 IP 网段：
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">类别</th>
<th scope="col" class="org-left">IP范围</th>
<th scope="col" class="org-left">私有地址范围</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">A</td>
<td class="org-left">1.0.0.0 ~ 126.255.255.255</td>
<td class="org-left">10.0.0.0 ~ 10.255.255.255</td>
</tr>

<tr>
<td class="org-left">B</td>
<td class="org-left">128.0.0.0 ~ 191.255.255.255</td>
<td class="org-left">172.16.0.0 ~ 172.31.255.255</td>
</tr>

<tr>
<td class="org-left">C</td>
<td class="org-left">192.0.0.0 ~ 223.255.255.255</td>
<td class="org-left">192.168.0.0 ~ 192.168.255.255</td>
</tr>
</tbody>
</table>

<p>
参考：
</p>
<ul class="org-ul">
<li><a href="https://blog.csdn.net/gui951753/article/details/79210535">详解公网 IP 和私网 IP - 小小呆的博客 - CSDN 博客</a></li>
</ul>
</div>
</div>

<div id="outline-container-org06daeeb" class="outline-3">
<h3 id="org06daeeb"><span class="section-number-3">4.3</span> 分组转发算法</h3>
<div class="outline-text-3" id="text-4-3">
<p>
路由表中包含目标 <b>网络地址</b> 和 <b>下一跳地址</b> 的映射数据，转发数据时根据网络地址和下一跳地址决定：
</p>
<ol class="org-ol">
<li>从数据包首部得到目标主机的网络地址 N</li>
<li>如果 N 就是与路由器相连的网络就直接交付，否则进行间接交付，执行 3</li>
<li>如果路由表中存在和目标 IP 相同的特定 <b>主机路由</b>, 就把数据报发送给指定的下一跳路由，否则执行 4</li>
<li>如果路由表中存在到的网络 N 的路由，就把数据报发送给指定的下一跳路由，否则执行 5</li>
<li>如果路由表中存在默认路由，就将数据包转发给默认路由，否则执行 6</li>
<li>报告转发分组出错</li>
</ol>
</div>
</div>

<div id="outline-container-org489bd0f" class="outline-3">
<h3 id="org489bd0f"><span class="section-number-3">4.4</span> 子网划分和 NAT</h3>
<div class="outline-text-3" id="text-4-4">
<p>
子网划分的方法是从主机号借几位来作为子网号，因此，子网 IP 的格式为：网络号 + 子网号 + 主机号。通过将 IP 地址和子网掩码进行 <b>与运算</b> 便可以得到目标网络号。
</p>

<p>
子网中进行分组转发时，路由表中包含目表 <b>网络地址</b> + <b>子网掩码</b> + <b>下一跳地址</b> 的映射数据，转发规则为：
</p>
<ol class="org-ol">
<li>从数据包首部得到目标 IP 地址 D</li>
<li>先将 D 与路由器直接相连的网络逐个检查，用各网络的子网掩码和 D 进行与运算，如果网络地址匹配，就直接交付，否则执行 3</li>
<li>如果路由表中存在和目标 IP 相同的特定 <b>主机路由</b>, 就把数据报发送给指定的下一跳路由，否则执行 4</li>
<li>对路由器中的每一行，用其中的子网掩码和 D 进行与运算，得到网络地址 N，如果和该行匹配，就转发到指明的下一跳路由器，否则执行 5</li>
<li>如果路由表中存在默认路由，就将数据包转发给默认路由，否则执行 6</li>
<li>报告转发分组出错</li>
</ol>

<p>
通过子网划分的方式，我们可以让一个子网中的所有主机公用一个公网 IP 地址，通过 NAT 技术来完成私网 IP 和公网 IP 之间的转换，参考：
</p>
<ul class="org-ul">
<li><a href="https://blog.csdn.net/gui951753/article/details/79593307?utm_source=distribute.pc_relevant.none-task">NAT(地址转换技术)详解_网络_小小呆的博客-CSDN博客</a></li>
</ul>

<p>
PS: 还是分级索引的套路……
</p>
</div>
</div>

<div id="outline-container-org380d8fa" class="outline-3">
<h3 id="org380d8fa"><span class="section-number-3">4.5</span> RIP 协议和 OSPF 协议</h3>
<div class="outline-text-3" id="text-4-5">
<p>
RIP 协议和 OSPF 协议都是路由选择算法，当多个路由都可以到的目标网络时，就需要通过路由选择算法选择一个更加高效快速的路由。
</p>

<p>
RIP 协议和相邻的路由交换路由表信息，每间隔一段时间就进行一次交换。
</p>

<p>
RIP 使用的方法是距离向量算法，其中距离通常用 <b>跳数</b> 来衡量，对每个相邻路由法过来的 RIP 报文，进行以下操作：
</p>
<ol class="org-ol">
<li>对于地址 X 的相邻路由发来的 RIP 报文，首先把报文所有项目中的下一跳地址都修改为 X，并将距离加 1.</li>
<li>根据报文中的目标网络进行更新操作：
<ul class="org-ul">
<li>路由表中无该目标网络，就添加到路由表</li>
<li>路由表中有该目标网络，下一跳和 X 相同，进行更新</li>
<li>路由表中有该目标网络，下一跳和 X 不同，比较更新</li>
</ul></li>
<li>若连续三分钟没有收到相邻路由器的更新路由表，就把此路由表记为不可达的路由器，及把距离设为 16</li>
</ol>

<p>
报文包含：目标网络，距离，下一跳路由器
</p>

<p>
OSPF 协议会将相邻路由的状态信息发送至所有路由器，路由器将保存所有信息，然后根据保存的数据构造出路由表，可以用 Dijkstra 算法实现。
</p>

<p>
和 RIP 协议的差别：
</p>
<ul class="org-ul">
<li>OSPF 向所有路由器发送信息，RIP 只想相邻路由发送信息</li>
<li>OSPF 发送的是链路状态信息，RIP 发送的是到所有网络的距离和下一跳路由器</li>
<li>OSPF 只有在链路状态变化时才进行发送，RIP 每隔一段时间发送一次</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgeeb9c66" class="outline-2">
<h2 id="orgeeb9c66"><span class="section-number-2">5</span> 运输层</h2>
<div class="outline-text-2" id="text-5">
<p>
运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。
</p>

<p>
运输层主要使用的两种协议为 TCP 协议和 UDP 协议。
</p>
</div>
</div>

<div id="outline-container-org38a5f54" class="outline-2">
<h2 id="org38a5f54"><span class="section-number-2">6</span> 应用层</h2>
<div class="outline-text-2" id="text-6">
<p>
应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。我们把应用层交互的数据单元称为报文。
</p>

<p>
使用 UDP 和 TCP 协议的各种应用程序和应用层协议：
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">应用</th>
<th scope="col" class="org-left">应用层协议</th>
<th scope="col" class="org-left">运输层协议</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">域名解析</td>
<td class="org-left">DNS</td>
<td class="org-left">UDP</td>
</tr>

<tr>
<td class="org-left">电子邮件</td>
<td class="org-left">SMTP</td>
<td class="org-left">TCP</td>
</tr>

<tr>
<td class="org-left">万维网</td>
<td class="org-left">HTTP</td>
<td class="org-left">TCP</td>
</tr>

<tr>
<td class="org-left">文件传送</td>
<td class="org-left">FTP</td>
<td class="org-left">TCP</td>
</tr>

<tr>
<td class="org-left">远程终端接入</td>
<td class="org-left">TELNET</td>
<td class="org-left">TCP</td>
</tr>

<tr>
<td class="org-left">路由选择协议</td>
<td class="org-left">RIP</td>
<td class="org-left">UDP</td>
</tr>

<tr>
<td class="org-left">IP 地址配置</td>
<td class="org-left">DHCP</td>
<td class="org-left">UDP</td>
</tr>

<tr>
<td class="org-left">文件传送</td>
<td class="org-left">TFTP</td>
<td class="org-left">UDP</td>
</tr>

<tr>
<td class="org-left">网络管理</td>
<td class="org-left">SNMP</td>
<td class="org-left">UDP</td>
</tr>

<tr>
<td class="org-left">远程文件服务器</td>
<td class="org-left">NFS</td>
<td class="org-left">UDP</td>
</tr>

<tr>
<td class="org-left">IP 电话</td>
<td class="org-left">专用协议</td>
<td class="org-left">UDP</td>
</tr>

<tr>
<td class="org-left">流式多媒体通信</td>
<td class="org-left">专用协议</td>
<td class="org-left">UDP</td>
</tr>

<tr>
<td class="org-left">多播</td>
<td class="org-left">IGMP</td>
<td class="org-left">UDP</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="postamble" class="status">
版权声明：本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
<div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_shortname = 'rgb-24bit';
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
</div>
</body>
</html>
