#+TITLE:      HTTP Protocol

* 目录                                                    :TOC_4_gh:noexport:
- [[#http-请求头和响应头][HTTP 请求头和响应头]]
- [[#http-长连接和短连接][HTTP 长连接和短连接]]
- [[#multipart][MultiPart]]
- [[#http-api-认证授权][HTTP API 认证授权]]
- [[#http-缓存][HTTP 缓存]]
- [[#断点续传][断点续传]]
- [[#相关问题][相关问题]]
  - [[#http-header-大小写敏感吗][HTTP Header 大小写敏感吗]]
  - [[#http-协议中的无状态是什么意思][HTTP 协议中的无状态是什么意思]]

* HTTP 请求头和响应头
  HTTP 消息头支持自定义，自定义的专用消息头一般会添加 ~X-~ 前缀，常用的 HTTP 请求头和响应头可以参考：
  + [[https://itbilu.com/other/relate/EJ3fKUwUx.html][HTTP 消息头 － 常用的 HTTP 请求头与响应头 - IT 笔录]]

  响应头中包含相应的状态码，大致的状态码划分为：
  |--------+---------------+----------------------------|
  | 状态码 | 类别          | 原因短语                   |
  |--------+---------------+----------------------------|
  |    1xx | Informational | 接收的请求正在处理         |
  |    2xx | Success       | 请求正常处理完毕           |
  |    3xx | Redirection   | 需要进行附加操作以完成请求 |
  |    4xx | Client Error  | 服务器无法处理请求         |
  |    5xx | Server Error  | 服务器处理请求错误         |
  |--------+---------------+----------------------------|

* HTTP 长连接和短连接
  在 HTTP/1.0 中默认使用短连接。也就是说，客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。

  这样是极为耗费资源的，因此，从 HTTP/1.1 起，默认使用长连接，用以保持连接特性。使用长连接的 HTTP 协议，会在响应头加入这行代码：
  #+BEGIN_EXAMPLE
    Connection: keep-alive
  #+END_EXAMPLE

  在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，
  会继续使用这一条已经建立的连接。Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件中设定这个时间。

* MultiPart
  MultiPart 类型的请求常用于文件的上传，是一种基于 POST 请求的请求格式。对于 MultiPart 类型的请求，需要指定 ~Content-Type~ 为如下格式：
  #+begin_example
    Content-Type: multipart/form-data; boundary=MjkyMTI5NjktMUVCNy00NENELUFFMTctREQ1Q0YzREM3NUY5Cg
  #+end_example
  
  请求体中的每一部分以 ~--boundary~ 开始，最后一个部分以 ~--boundary--~ 结束，每个部分需要通过 ~Content-Disposition~ 指定该部分对应的字段名称：
  #+begin_example
    Content-Disposition: form-data; name="user";
    Content-Disposition: form-data; name="user"; filename="hello.txt"
  #+end_example

  每个部分可以拥有自己的请求头，然后空一行跟请求体：
  #+begin_example
    POST /t2/upload.do HTTP/1.1
    User-Agent: SOHUWapRebot
    Accept-Language: zh-cn,zh;q=0.5
    Accept-Charset: GBK,utf-8;q=0.7,*;q=0.7
    Connection: keep-alive
    Content-Length: 60408
    Content-Type:multipart/form-data; boundary=ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC
    Host: w.sohu.com

    --ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC
    Content-Disposition: form-data; name="city"

    Santa colo
    --ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC
    Content-Disposition: form-data;name="desc"
    Content-Type: text/plain; charset=UTF-8
    Content-Transfer-Encoding: 8bit
 
    ...
    --ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC
    Content-Disposition: form-data;name="pic"; filename="photo.jpg"
    Content-Type: application/octet-stream
    Content-Transfer-Encoding: binary
 
    ... binary data of the jpg ...
    --ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC--
  #+end_example
  
  参考：
  + [[https://stackoverflow.com/questions/16958448/what-is-http-multipart-request][What is http multipart request? - Stack Overflow]]
  + [[https://www.jianshu.com/p/29e38bcc8a1d][深入解析 multipart/form-data - 简书]]

* HTTP API 认证授权
  + [[https://coolshell.cn/articles/19395.html][HTTP API 认证授权术 || 酷 壳 - CoolShell]]
  + [[https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Authentication][HTTP 身份验证 - HTTP | MDN]]

* HTTP 缓存
  在 HTTP 缓存机制中服务器端可以通过 ~Cache-control~ 响应头来控制缓存，可以：
  + 禁止进行缓存，缓存中不得存储任何关于客户端请求和服务端响应的内容，每次由客户端发起的请求都会下载完整的响应内容：
    #+begin_example
      Cache-Control: no-store
    #+end_example
  + 强制确认缓存，每次有请求发出时，缓存会将该请求发到服务器，服务器端会验证请求中所描述的缓存是否过期，若未过期，则缓存才使用本地缓存副本：
    #+begin_example
      Cache-Control: no-cache
    #+end_example
  + 通过 ~max-age=<seconds>~ 指定资源能够被缓存的最大时间：
    #+begin_example
      Cache-Control: max-age=31536000
    #+end_example

  理论上来讲，当一个资源被缓存存储后，该资源应该可以被永久存储在缓存中。由于缓存只有有限的空间用于存储资源副本，所以缓存会定期地将一些副本删除，这个过程叫做缓存驱逐。

  另一方面，当服务器上面的资源进行了更新，那么缓存中的对应资源也应该被更新，由于 HTTP 是 C/S 模式的协议，服务器更新一个资源时，不可能直接通知客户端更新缓存，
  所以双方必须为该资源约定一个过期时间，在该过期时间之前，该资源（缓存副本）就是 *新鲜* 的，当 *过了过期时间* 后，该资源（缓存副本）则变为 *陈旧* 的。

  驱逐算法用于将陈旧的资源替换为新鲜的，注意，一个陈旧的资源是不会直接被清除或忽略的，当客户端发起一个请求时，缓存检索到已有一个对应的陈旧资源，则缓存会先将此请求附加一个 ~If-None-Match~ 头，
  然后发给目标服务器，以此来检查该资源副本是否是依然还是算新鲜的，若服务器返回了 304 (Not Modified)，则表示此资源副本是新鲜的，这样一来，可以节省一些带宽。
  若服务器通过 ~If-None-Match~ 或 ~If-Modified-Since~ 判断后发现已过期，那么会带有该资源的实体内容返回。

  参考
  + [[https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ][HTTP 缓存 - HTTP | MDN]]

* 断点续传
  断点续传利用的主要是 ~Range~ 这个请求头，通过一定的请求格式来获取想要的数据段：
  #+begin_example
    Range: <unit>=<range-start>-
    Range: <unit>=<range-start>-<range-end>
    Range: <unit>=<range-start>-<range-end>, <range-start>-<range-end>
    Range: <unit>=<range-start>-<range-end>, <range-start>-<range-end>, <range-start>-<range-end>
  #+end_example

  同时，根据响应头中的 ~Content-Length~ 获取数据的总长度，参考：
  + [[https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Range][Range - HTTP | MDN]]
  + [[https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Length][Content-Length - HTTP | MDN]]

* 相关问题
** HTTP Header 大小写敏感吗
   HTTP Header 大小写不敏感，参考：
   + [[https://stackoverflow.com/questions/5258977/are-http-headers-case-sensitive][Are HTTP headers case-sensitive? - Stack Overflow]]

** HTTP 协议中的无状态是什么意思
   HTTP 中每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况。

