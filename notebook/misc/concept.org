#+TITLE:      概念了解

* 目录                                                    :TOC_4_gh:noexport:
- [[#devops][DevOps]]
- [[#本福特定律][本福特定律]]
- [[#概率编程语言][概率编程语言]]
- [[#图像重采样算法][图像重采样算法]]
- [[#快速傅里叶变换][快速傅里叶变换]]
- [[#马儿科夫链][马儿科夫链]]
- [[#欧几里得-欧拉定理][欧几里得-欧拉定理]]
- [[#abi][ABI]]
- [[#虚函数][虚函数]]
- [[#内存泄漏和内存溢出][内存泄漏和内存溢出]]
- [[#serialization][Serialization]]
- [[#iaaspaassaas][IaaS，PaaS，SaaS]]
- [[#指针和句柄][指针和句柄]]
- [[#静态类型动态类型弱类型强类型][静态类型、动态类型、弱类型、强类型]]
- [[#编译运行解释运行][编译运行、解释运行]]

* DevOps
  DevOps 是一个完整的面向IT运维的工作流，以 IT 自动化以及持续集成（CI）、持续部署（CD）为基础，来优化程式开发、测试、系统运维等所有环节。

  可以参考的文章：
  + [[https://www.cnblogs.com/liufei1983/p/7152013.html][DevOps 简介 - 刘大飞 - 博客园]]

* 本福特定律
  本福特定律，也称为本福特法则，说明一堆从实际生活得出的数据中，以 1 为首位数字的数的出现概率约为总数的三成，接近直觉得出之期望值 1/9 的 3 倍。

  + [[https://zh.wikipedia.org/wiki/%E6%9C%AC%E7%A6%8F%E7%89%B9%E5%AE%9A%E5%BE%8B][本福特定律 - 维基百科，自由的百科全书]]

* 概率编程语言
  概率编程语言（PPL）是一种编程语言，用于描述概率模型，然后在这些模型中进行推理。
  
  + [[https://en.wikipedia.org/wiki/Probabilistic_programming_language][Probabilistic programming language - Wikipedia]]

* 图像重采样算法    
  图像的 size 修改其实就是一个图像重新采样的过程，放大图像称为上采样/插值，缩小图像称为小采样。

  + [[http://entropymine.com/imageworsener/resample/][Basics of Image Resampling]]
  + [[https://clouard.users.greyc.fr/Pantheon/experiments/rescaling/index-en.html][TUTORIAL: IMAGE RESCALING]]
  + [[https://www.cnblogs.com/wjgaas/p/3597095.html][关于图像重采样插值算法]]
     
* 快速傅里叶变换
  *快速傅里叶变换(Fast Fourier Transform, FFT)*, 是快速计算序列的离散傅里叶变换或其逆变换的方法。
  傅里叶分析将信号从原始域转换到频域的表示或者逆过来转换。

  + [[https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2][维基百科 - 快速傅里叶变换]]

* 马儿科夫链
  *马尔可夫链* 为状态空间中经过从一个状态到另一个状态的转换的 *随机过程*.

  + [[https://zh.wikipedia.org/wiki/%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E9%93%BE][维基百科 - 马尔可夫链]]

* 欧几里得-欧拉定理
  *欧几里得-欧拉定理(Euclid–Euler theorem)* 是一条联系 *偶完全数* 与 *梅森质数* 的定理。

  + [[https://zh.wikipedia.org/wiki/%E6%AD%90%E5%B9%BE%E9%87%8C%E5%BE%97-%E6%AD%90%E6%8B%89%E5%AE%9A%E7%90%86][维基百科 - 欧几里得-欧拉定理]]

* ABI
  ABI 是应用二进制接口的缩写，和 API 不同，ABI 是指两程序模块间的接口，通常其中一个程序模块会是库或操作系统所提供的服务，而另一边的模块则是用户所运行的程序。

  参考：
  + [[https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%8E%A5%E5%8F%A3][应用二进制接口 - 维基百科，自由的百科全书]]

* 虚函数
  在面向对象程序设计领域，C++、Object Pascal 等语言中有虚函数（英语：virtual function）或虚方法（英语：virtual method）的概念，这些在 Java 中和接口的概念相仿。

  在 C 语言中，大概就是函数指针，可以参考：
  + [[https://zh.wikipedia.org/wiki/%E8%99%9A%E5%87%BD%E6%95%B0][虚函数 - 维基百科，自由的百科全书]]

* 内存泄漏和内存溢出
  + 内存泄露：申请的内存空间没有被正确释放，导致后续程序里这块内存被永远占用（不可达）
  + 内存溢出：指存储的数据超出了指定空间的大小，这时数据就会越界
    
  + [[https://www.zhihu.com/question/40560123][内存泄漏和内存溢出有啥区别？ - 知乎]]
  
  需要注意的是，虽然 Java 通过根可达性算法解决了循环引用的问题，但是，不代表 Java 中就不存在内存泄漏的问题了，参考：
  + [[https://zhuanlan.zhihu.com/p/56214714][深入分析 ThreadLocal 内存泄漏问题 - 知乎]]

* Serialization
  Serialization 这个单词在计算机科学中存在两种含义：
  + 序列化 - 保存对象以便可以重新创建的过程，比如转换对象为二进制串、JSON、XML 等
  + 串行化 - 线程和进程之间的同步

  参考：
  + [[https://en.wikipedia.org/wiki/Synchronization_(computer_science)#Thread_or_process_synchronization][Synchronization (computer science) - Wikipedia]]
  + [[https://en.wikipedia.org/wiki/Serialization_(disambiguation)][Serialization (disambiguation) - Wikipedia]]
  + [[https://en.wikipedia.org/wiki/Serialization][Serialization - Wikipedia]]

* IaaS，PaaS，SaaS
  + IaaS：基础设施服务，Infrastructure-as-a-service，提供基础设施，但是具体服务由自己去实现
  + PaaS：平台服务，Platform-as-a-service，在基础设施上进一步提供了基础实现，自己去定义
  + SaaS：软件服务，Software-as-a-service，直接提供的就是成品

  参考：
  + [[http://www.ruanyifeng.com/blog/2017/07/iaas-paas-saas.html][IaaS，PaaS，SaaS 的区别 - 阮一峰的网络日志]]

* 指针和句柄
  #+begin_quote
  In computer programming, a handle is an abstract reference to a resource that is used when application software references blocks of memory or objects that are managed by another system like a database or an operating system.
  #+end_quote

  简单来说，句柄是被单独的系统管理的对象，我们可以通过句柄间接访问目标对象，系统可以通过句柄来对访问进行控制，而指针，就很自由。
  
  参考：
  + [[https://en.wikipedia.org/wiki/Handle_(computing)][Handle (computing) - Wikipedia]]
  + [[https://www.jianshu.com/p/ce6d7a5eea0a][指针与句柄的区别 - 简书]]

* 静态类型、动态类型、弱类型、强类型
  Program Errors:
  + trapped errors: 导致程序终止执行，如除 0，Java 中数组越界访问
  + untrapped errors: 出错后继续执行，但可能出现任意行为。如 C 里的缓冲区溢出、Jump 到错误地址

  Forbidden Behaviours: 语言设计时，可以定义一组 forbidden behaviors。它必须包括所有 untrapped errors，但可能包含 trapped errors。
  
  Well behaved、ill behaved:
  + well behaved: 如果程序执行不可能出现 forbidden behaviors，则为 well behaved
  + ill behaved: 否则为 ill behaved

  强、弱类型：
  + 强类型 strongly typed: 如果一种语言的所有程序都是 well behaved —— 即不可能出现 forbidden behaviors，那么该语言为 strongly typed
  + 弱类型 weakly typed: 否则为 weakly typed。比如 C 语言的缓冲区溢出，属于 untrapped errors，即属于 forbidden behaviors，故 C 是弱类型

  动态、静态类型：
  + 静态类型 statically: 如果在编译时拒绝 ill behaved 程序，则是 statically typed
  + 动态类型 dynamiclly: 如果在运行时拒绝 ill behaviors，则是 dynamiclly typed

  Python 是强类型、动态类型的语言。

* 编译运行、解释运行
  无论是编译执行还是解释执行往往都需要经过词法分析、语法分析的步骤生成抽象语法树，往往，在生成抽象语法树后，解释运行和编译运行就出现了区别：
  + 编译运行通常会将抽象语法树优化生成中间代码，然后将中间代码转译为目标平台机器码后执行，虽然还是 CPU 在解释执行机器码
  + 解释运行通常会将抽象语法树翻译为字节码，然后由解释器、虚拟机执行，虚拟机或解释器可以选择通过 JIT 将中间语言进一步编译为机器码，
    但也可以选择直接解释执行 AST

