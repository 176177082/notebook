<!DOCTYPE html>
<html lang="zh-CN">
<head>
<!-- 2021-01-09 周六 19:45 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>计算机图形学</title>
<meta name="generator" content="Org mode">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="https://rgb-24bit.github.io/blog/misc/style.css">
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-125860001-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-125860001-1');
</script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="https://rgb-24bit.github.io/notebook/"> UP </a>
 |
 <a accesskey="H" href="https://rgb-24bit.github.io"> HOME </a>
</div><div id="content">
<h1 class="title">计算机图形学</h1>
<div id="table-of-contents">
<h2>&#30446;&#24405;</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgc60b694">1. 基本概念</a></li>
<li><a href="#orgf60da9d">2. 图元绘制</a>
<ul>
<li><a href="#org798da0c">2.1. 简单的例子</a></li>
</ul>
</li>
<li><a href="#org8a89b46">3. 图元填充</a></li>
<li><a href="#org891a13c">4. 图元裁剪</a></li>
<li><a href="#org8731b48">5. 图元变换</a></li>
<li><a href="#org3882921">6. 消隐算法</a></li>
<li><a href="#orgc7291e4">7. 其他</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgc60b694" class="outline-2">
<h2 id="orgc60b694"><span class="section-number-2">1</span> 基本概念</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>显示器分辨率表示的是在屏幕上扫描一行共有多少个点，共有多少行扫描线。分辨率越高，屏幕显示一幅图像的质量就越清晰</li>
<li>帧缓冲器每一个存储单元的位长决定了一幅画面上能同时显示的不同灰度的数目或颜色的种类
<ul class="org-ul">
<li>如果是单色，则每个像素只需要 1Bit 表示</li>
<li>如果是 16 色，则每个像素需要 4Bit 表示</li>
<li>如果是 256 色，则每个像素需要 1 个字节表示</li>
<li>如果是 65536 色，则每个像素需要 2 个字节表示</li>
<li>显存 &gt;= 像素点的数量 * 表示每个像素所需比特数</li>
</ul></li>
<li>图形显示技术中的分辨率概念有三种：
<ol class="org-ol">
<li>屏幕分辨率：屏幕上显示的像素个数</li>
<li>显示分辨率：计算机显示控制器所能够提供的显示模式分辨率，简称显示模式</li>
<li>显卡分辨率：显卡输出给显示器，并能在显示器上描绘像素点的数量</li>
</ol></li>
<li>电脑的最高分辨率取决于显卡和显示器最低的一个</li>
<li>刷新是指为了获得稳定的画面，不断重复绘制图形的过程</li>
<li>持续发光时间是决定刷新频率的主要因素，它的值越大，所需的刷新频率也就越低</li>
<li>光屏显示的图形是由电子束打在荧光屏上产生的光点组成的，这些光点便是像素</li>
<li>CRT在水平和竖直方向单位长度能识别的最大光点数便是荧光屏的分辨率</li>
</ul>
</div>
</div>

<div id="outline-container-orgf60da9d" class="outline-2">
<h2 id="orgf60da9d"><span class="section-number-2">2</span> 图元绘制</h2>
<div class="outline-text-2" id="text-2">
<p>
计算机图形学中进行图元绘制时，用到的一个重要的思想是 <b>增量</b> 思想，依据是两个相邻像素点之间的横向和纵向的差值不是 1 就是 0。
</p>

<p>
绘制直线时，根据这一思想衍生出来的算法有：DDA 算法、中点 Bresenham 算法和改进的中点 Bresenham 算法。
</p>

<p>
其中，DDA 算法（数值微分法）是根据直线的斜截式推导得出，得到递推公式：
</p>
<ul class="org-ul">
<li>当斜率小于 1 大于 0 时，两个点之间的 x 增量为 1，y 增量为 k</li>
<li>当斜率大于 1 时，两个点之间的 y 增量为 1，x 增量为 1/k</li>
</ul>

<p>
也就是说，运用增量思想时，需要考虑最大增量方向。
</p>

<p>
而中点 Bresenham 算法利用了直线的正负划分性，并利用了一些数学运算技巧消除了浮点运算，其算法步骤为：
</p>
<ol class="org-ol">
<li>斜率小于 1 时，计算出 dx 和 dy，同时令 d = dx - 2dy</li>
<li>绘制点 (x, y)</li>
<li>如果 d &lt; 0, 就更新点为 (x + 1, y + 1)，更新 d 为 d + 2dx - 2dy。否则，更新点为 (x + 1, y)，更新 d 为 d - 2dy</li>
</ol>

<p>
而改进的中点 Bresenham 算法则利用了更巧妙的数学技巧，其算法步骤为：
</p>
<ol class="org-ol">
<li>斜率小于 1 是，计算出 dx 和 dy，同时令 d = -dx</li>
<li>绘制点 (x, y)，并更新 d 为 d + 2dy</li>
<li>如果 d &gt; 0，就更新点为 (x + 1, y + 1)，更新 d 为 d - 2dx，否则更新点为 (x + 1, y)。</li>
<li>如果直线没有画完，重复第 2 和第 3 步</li>
</ol>

<p>
改进的中点 Bresenham 算法相较于中点 Bresenham 来说，更新较小的增量方向的值的条件不同，一个要求 d &lt; 0，一个要求 d &gt; 0。
</p>

<p>
用在直线绘制上的思想也用在了圆、椭圆等图形的绘制，并考虑了这些图形的对称性特点减少计算量。
</p>
</div>

<div id="outline-container-org798da0c" class="outline-3">
<h3 id="org798da0c"><span class="section-number-3">2.1</span> 简单的例子</h3>
<div class="outline-text-3" id="text-2-1">
<p>
对于有点 (0, 0) 和 (8, 5) 组成的直线来说，可以计算出 dx = 8，dy = 5。
</p>

<p>
使用中点 Bresenham 算法时，d &lt; 0 时增量为 6，d &gt;=0 时为 -10：
</p>
<table>


<colgroup>
<col  class="org-right">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">X</th>
<th scope="col" class="org-right">Y</th>
<th scope="col" class="org-right">D</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">-2</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">4</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">1</td>
<td class="org-right">-6</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">2</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-right">2</td>
<td class="org-right">-10</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-right">3</td>
<td class="org-right">-4</td>
</tr>

<tr>
<td class="org-right">6</td>
<td class="org-right">4</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-right">7</td>
<td class="org-right">4</td>
<td class="org-right">-8</td>
</tr>

<tr>
<td class="org-right">8</td>
<td class="org-right">5</td>
<td class="org-right">-2</td>
</tr>
</tbody>
</table>

<p>
使用改进的中点 Bresenham 算法时：
</p>
<table>


<colgroup>
<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">X</th>
<th scope="col" class="org-right">Y</th>
<th scope="col" class="org-right">d</th>
<th scope="col" class="org-right">d + 2dy(10)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">-8</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">-14</td>
<td class="org-right">-4</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">1</td>
<td class="org-right">-4</td>
<td class="org-right">6</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">2</td>
<td class="org-right">-10</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-right">2</td>
<td class="org-right">0</td>
<td class="org-right">10</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-right">3</td>
<td class="org-right">-6</td>
<td class="org-right">4</td>
</tr>

<tr>
<td class="org-right">6</td>
<td class="org-right">4</td>
<td class="org-right">-12</td>
<td class="org-right">-2</td>
</tr>

<tr>
<td class="org-right">7</td>
<td class="org-right">4</td>
<td class="org-right">-2</td>
<td class="org-right">8</td>
</tr>

<tr>
<td class="org-right">8</td>
<td class="org-right">5</td>
<td class="org-right">-8</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-right">9</td>
<td class="org-right">6</td>
<td class="org-right">-14</td>
<td class="org-right">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-org8a89b46" class="outline-2">
<h2 id="org8a89b46"><span class="section-number-2">3</span> 图元填充</h2>
<div class="outline-text-2" id="text-3">
<p>
图元填充的主要问题在于多边形的填充，扫描线算法利用了边的连贯性，并通过巧妙的数据结构极大的减少了运算量。
</p>

<p>
该算法的步骤为：
</p>
<ol class="org-ol">
<li>建立边表和有效边表，需要注意的是，边表只包含非水平边</li>
<li>执行以下步骤直到边表和有效边表都为空：
<ol class="org-ol">
<li>如果边表中第 y 类非空，就将其中所有边取出放入有效边表</li>
<li>如果有新的的边加入有效边表就对有效边表进行排序</li>
<li>两两配对（求交）</li>
<li>扫描线纵坐标加 1</li>
<li>将有效边表中 y = ymax 边删除（左闭右开，下闭上开）</li>
<li>将有效边表中剩下的边的 x 值增加 dx</li>
</ol></li>
</ol>

<p>
其中，有效边表的排序依据为：x 值，x 增量大小。
</p>

<p>
整个算法中的计算步骤有：
</p>
<ol class="org-ol">
<li>求交：计算机扫描线与多边形各边的交点</li>
<li>排序：把所有交点按递增的顺序进行排序</li>
<li>交点配对：每对交点表示扫描线与多边形的一个相交区间</li>
<li>区间填色：相交区间内的像素置成多边形颜色，区间外的像素置成背景色</li>
</ol>

<p>
除了多边形的填充以外，常见的还有区域填充的需求，可以通过递归填充算法完成填充。
</p>

<p>
其中，8 连通边界算法不可以填充 4 连通的边界表示区域，但是可以填充 4 连通的内点表示区域。
</p>
</div>
</div>

<div id="outline-container-org891a13c" class="outline-2">
<h2 id="org891a13c"><span class="section-number-2">4</span> 图元裁剪</h2>
<div class="outline-text-2" id="text-4">
<p>
图元裁剪中的一个重要算法是 Cohen-Sutherland（编码）算法，该算法将窗口分为九个区域，每个区域赋予一个四位的编码：(t, b, r, l).
</p>

<p>
其中：
</p>
<ol class="org-ol">
<li>第一位：端点在 y=ymax 上方则取 1，否则取 0</li>
<li>第二位：端点在 y=ymin 下方则取 1，否则取 0</li>
<li>第三位：端点在 x=xmax 右方则取 1，否则取 0</li>
<li>第四位：端点在 x=xmin 左方则取 1，否则取 0</li>
</ol>

<p>
直线两端点的四位编码按位运算或等于 0 则简取之，与运算不等于 0 则简弃之。若均不成立则直线段与窗口的交点在交点处把线段一分为二，通过中点分割法寻找边界点。
</p>

<p>
除了编码算法以外，还有一个优秀的算法为 Liang-Barsk 算法，该算法算法的基本出发点是直线的参数方程：
</p>
<pre class="example">
x = x1 + u(x2 - x1)
y = y1 + u(y2 - y1)
0 &lt;= u &lt;= 1
</pre>

<p>
有效的直线范围便是：
</p>
<pre class="example">
xleft &lt;= u * dx &lt;= xright
ybottom &lt;= u *dy &lt;= ytop
</pre>

<p>
此时，通过一些数学上的转换可以得到：
</p>
<pre class="example">
u * -dx &lt;= x1 - xleft
u * dx &lt;= xright - x1
u * -dy &lt;= y1 - ybottom
u * dy &lt;= ytop - y1
</pre>

<p>
此时，通过如下转换可得 u * pk &lt;= qk：
</p>
<pre class="example">
p1 = -dx  q1 = x1 - xl
p2 = dx   q2 = xr - x1
p3 = -dy  q3 = y1 - yb
p4 = dy   q4 = yt - y1
</pre>

<p>
实际使用时：
</p>
<ol class="org-ol">
<li>当存在 pk = 0 的情况时，说明直线必然平行于某边界，如果此时还存在对应的 qk &lt; 0，说明直线在边界外，可以简弃</li>
<li>当 pk &lt; 0 时，线段从裁剪边界延长线的外部延伸到内部，是入边交点</li>
<li>当 pk &gt; 0 是，线段从裁剪边界延长线的内部延伸到外部，是出边交点</li>
<li>此时，pk 值为四个，加上 u = 0 和 u = 1 就是六个</li>
<li>把 pk &lt; 0 的 u 值和 0 比较去找最大的，把 pk &gt; 0 的 u 值和 1 比较去找最小的，就可以得到两个端点的参数值</li>
</ol>

<p>
其中，uk = qk / pk，计算得到的 umin 和 umax，若 umax &gt; umin，则直线段在窗口外，删除该直线。否则将 u 值代入参数方程求出交点。
</p>
</div>
</div>

<div id="outline-container-org8731b48" class="outline-2">
<h2 id="org8731b48"><span class="section-number-2">5</span> 图元变换</h2>
<div class="outline-text-2" id="text-5">
<p>
图元变换通过引入齐次方程的形式，将复杂的图元变换转换为了矩阵运算，可以很方便的实现复合变换。其中，基本变换为平移、比例、旋转、对称、错切。
</p>

<p>
图元变换的一个重要作用就是进行坐标系的变换：建模坐标系 -&gt; 世界坐标系 -&gt; 观察坐标系。
</p>

<p>
以下为错切和旋转的计算方程，旋转方程的得出过程中利用极坐标巧妙的消除了复杂的计算，只保留了角度和原始坐标：
</p>
<pre class="example">
x' = x + dy
y' = bx + y

x' = xcos - ysin
y' = xsin + ycos
</pre>

<p>
而变化矩阵的每一列分别和 (x, y, z, &#x2026;) 相对应。
</p>

<p>
这些变化中最为复杂的大概就是旋转了，在三维旋转中，需要注意旋转的方向，其中，可以通过右手定则确定旋转正方向，特别的，围绕那个轴旋转那个轴的值就不变。
</p>
</div>
</div>

<div id="outline-container-org3882921" class="outline-2">
<h2 id="org3882921"><span class="section-number-2">6</span> 消隐算法</h2>
<div class="outline-text-2" id="text-6">
<p>
消隐算法中的一个经典算法便是 z-buffer 算法了，这个算法的原始形式是通过一个帧缓存来保存颜色值，通过一个深度缓存来保存深度。
</p>

<p>
当然了，原始形式对空间占用比较多，一种改进方式便是使用单个深度缓存变量，遍历每个像素，得到该像素点处深度最大的多边形。缺点时耗时会有所增加。
</p>

<p>
使用改进的 z-buffer 算法是，需要进行点与多边形的包含性检测，一种简单的方式是通过射线法来进行判断：
</p>
<ul class="org-ul">
<li>由被测点 P 处向 -y 方向作射线，交点个数是奇数，则被测点在多边形内部，交点个数是偶数表示在多边形外部。</li>
</ul>

<p>
若射线正好经过多边形的顶点，则采用左开右闭的原则来实现。
</p>
</div>
</div>

<div id="outline-container-orgc7291e4" class="outline-2">
<h2 id="orgc7291e4"><span class="section-number-2">7</span> 其他</h2>
<div class="outline-text-2" id="text-7">
<ul class="org-ul">
<li>常用的反走样算法：提高分辨率、非加权区域采样、加权区域采样</li>
<li>根据投影中心和投影面之间的距离投影方式可以分为：
<ul class="org-ul">
<li>平行投影：投影中心和投影面之间的距离无限远，投影线之间是平行的。根据投影方向可以分为：正投影和斜投影。正投影分为：三视图、正轴测图。斜投影：常见的有斜等测和斜二测</li>
<li>透视投影：投影线相交于投影中心。投影中心也称为灭点。按照主灭点个数可以分为：一点透视、两点透视、三点透视</li>
</ul></li>
<li>字符裁剪的精度：串精度、字符精度和笔划/像素精度</li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
版权声明：本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
<div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_shortname = 'rgb-24bit';
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
</div>
</body>
</html>
