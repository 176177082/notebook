#+TITLE:      计算机图形学

* 目录                                                    :TOC_4_gh:noexport:
- [[#基本概念][基本概念]]
- [[#图元绘制][图元绘制]]
  - [[#简单的例子][简单的例子]]
- [[#图元填充][图元填充]]
- [[#图元裁剪][图元裁剪]]
- [[#图元变换][图元变换]]
- [[#消隐算法][消隐算法]]
- [[#其他][其他]]

* 基本概念
  + 显示器分辨率表示的是在屏幕上扫描一行共有多少个点，共有多少行扫描线。分辨率越高，屏幕显示一幅图像的质量就越清晰
  + 帧缓冲器每一个存储单元的位长决定了一幅画面上能同时显示的不同灰度的数目或颜色的种类
    - 如果是单色，则每个像素只需要 1Bit 表示
    - 如果是 16 色，则每个像素需要 4Bit 表示
    - 如果是 256 色，则每个像素需要 1 个字节表示
    - 如果是 65536 色，则每个像素需要 2 个字节表示
    - 显存 >= 像素点的数量 * 表示每个像素所需比特数
  + 图形显示技术中的分辨率概念有三种：
    1. 屏幕分辨率：屏幕上显示的像素个数
    2. 显示分辨率：计算机显示控制器所能够提供的显示模式分辨率，简称显示模式
    3. 显卡分辨率：显卡输出给显示器，并能在显示器上描绘像素点的数量
  + 电脑的最高分辨率取决于显卡和显示器最低的一个
  + 刷新是指为了获得稳定的画面，不断重复绘制图形的过程
  + 持续发光时间是决定刷新频率的主要因素，它的值越大，所需的刷新频率也就越低
  + 光屏显示的图形是由电子束打在荧光屏上产生的光点组成的，这些光点便是像素
  + CRT在水平和竖直方向单位长度能识别的最大光点数便是荧光屏的分辨率

* 图元绘制
  计算机图形学中进行图元绘制时，用到的一个重要的思想是 *增量* 思想，依据是两个相邻像素点之间的横向和纵向的差值不是 1 就是 0。

  绘制直线时，根据这一思想衍生出来的算法有：DDA 算法、中点 Bresenham 算法和改进的中点 Bresenham 算法。

  其中，DDA 算法（数值微分法）是根据直线的斜截式推导得出，得到递推公式：
  + 当斜率小于 1 大于 0 时，两个点之间的 x 增量为 1，y 增量为 k
  + 当斜率大于 1 时，两个点之间的 y 增量为 1，x 增量为 1/k

  也就是说，运用增量思想时，需要考虑最大增量方向。

  而中点 Bresenham 算法利用了直线的正负划分性，并利用了一些数学运算技巧消除了浮点运算，其算法步骤为：
  1. 斜率小于 1 时，计算出 dx 和 dy，同时令 d = dx - 2dy
  2. 绘制点 (x, y)
  3. 如果 d < 0, 就更新点为 (x + 1, y + 1)，更新 d 为 d + 2dx - 2dy。否则，更新点为 (x + 1, y)，更新 d 为 d - 2dy

  而改进的中点 Bresenham 算法则利用了更巧妙的数学技巧，其算法步骤为：
  1. 斜率小于 1 是，计算出 dx 和 dy，同时令 d = -dx
  2. 绘制点 (x, y)，并更新 d 为 d + 2dy
  3. 如果 d > 0，就更新点为 (x + 1, y + 1)，更新 d 为 d - 2dx，否则更新点为 (x + 1, y)。
  4. 如果直线没有画完，重复第 2 和第 3 步 

  改进的中点 Bresenham 算法相较于中点 Bresenham 来说，更新较小的增量方向的值的条件不同，一个要求 d < 0，一个要求 d > 0。

  用在直线绘制上的思想也用在了圆、椭圆等图形的绘制，并考虑了这些图形的对称性特点减少计算量。

** 简单的例子
   对于有点 (0, 0) 和 (8, 5) 组成的直线来说，可以计算出 dx = 8，dy = 5。

   使用中点 Bresenham 算法时，d < 0 时增量为 6，d >=0 时为 -10：
   |---+---+-----|
   | X | Y |   D |
   |---+---+-----|
   | 0 | 0 |  -2 |
   | 1 | 1 |   4 |
   | 2 | 1 |  -6 |
   | 3 | 2 |   0 |
   | 4 | 2 | -10 |
   | 5 | 3 |  -4 |
   | 6 | 4 |   2 |
   | 7 | 4 |  -8 |
   | 8 | 5 |  -2 |
   |---+---+-----|

   使用改进的中点 Bresenham 算法时：
   |---+---+-----+-------------|
   | X | Y |   d | d + 2dy(10) |
   |---+---+-----+-------------|
   | 0 | 0 |  -8 |           2 |
   | 1 | 1 | -14 |          -4 |
   | 2 | 1 |  -4 |           6 |
   | 3 | 2 | -10 |           0 |
   | 4 | 2 |   0 |          10 |
   | 5 | 3 |  -6 |           4 |
   | 6 | 4 | -12 |          -2 |
   | 7 | 4 |  -2 |           8 |
   | 8 | 5 |  -8 |           2 |
   | 9 | 6 | -14 |             |
   |---+---+-----+-------------|

* 图元填充
  图元填充的主要问题在于多边形的填充，扫描线算法利用了边的连贯性，并通过巧妙的数据结构极大的减少了运算量。

  该算法的步骤为：
  1. 建立边表和有效边表，需要注意的是，边表只包含非水平边
  2. 执行以下步骤直到边表和有效边表都为空：
     1. 如果边表中第 y 类非空，就将其中所有边取出放入有效边表
     2. 如果有新的的边加入有效边表就对有效边表进行排序
     3. 两两配对（求交）
     4. 扫描线纵坐标加 1
     5. 将有效边表中 y = ymax 边删除（左闭右开，下闭上开）
     6. 将有效边表中剩下的边的 x 值增加 dx

  其中，有效边表的排序依据为：x 值，x 增量大小。

  整个算法中的计算步骤有：
  1. 求交：计算机扫描线与多边形各边的交点
  2. 排序：把所有交点按递增的顺序进行排序
  3. 交点配对：每对交点表示扫描线与多边形的一个相交区间
  4. 区间填色：相交区间内的像素置成多边形颜色，区间外的像素置成背景色

  除了多边形的填充以外，常见的还有区域填充的需求，可以通过递归填充算法完成填充。
  
  其中，8 连通边界算法不可以填充 4 连通的边界表示区域，但是可以填充 4 连通的内点表示区域。

* 图元裁剪
  图元裁剪中的一个重要算法是 Cohen-Sutherland（编码）算法，该算法将窗口分为九个区域，每个区域赋予一个四位的编码：(t, b, r, l).

  其中：
  1. 第一位：端点在 y=ymax 上方则取 1，否则取 0
  2. 第二位：端点在 y=ymin 下方则取 1，否则取 0
  3. 第三位：端点在 x=xmax 右方则取 1，否则取 0
  4. 第四位：端点在 x=xmin 左方则取 1，否则取 0

  直线两端点的四位编码按位运算或等于 0 则简取之，与运算不等于 0 则简弃之。若均不成立则直线段与窗口的交点在交点处把线段一分为二，通过中点分割法寻找边界点。

  除了编码算法以外，还有一个优秀的算法为 Liang-Barsk 算法，该算法算法的基本出发点是直线的参数方程：
  #+BEGIN_EXAMPLE
    x = x1 + u(x2 - x1)
    y = y1 + u(y2 - y1)
    0 <= u <= 1
  #+END_EXAMPLE

  有效的直线范围便是：
  #+BEGIN_EXAMPLE
    xleft <= u * dx <= xright
    ybottom <= u *dy <= ytop
  #+END_EXAMPLE
  
  此时，通过一些数学上的转换可以得到：
  #+BEGIN_EXAMPLE
    u * -dx <= x1 - xleft
    u * dx <= xright - x1
    u * -dy <= y1 - ybottom
    u * dy <= ytop - y1
  #+END_EXAMPLE
  
  此时，通过如下转换可得 u * pk <= qk：
  #+BEGIN_EXAMPLE
    p1 = -dx  q1 = x1 - xl
    p2 = dx   q2 = xr - x1
    p3 = -dy  q3 = y1 - yb
    p4 = dy   q4 = yt - y1
  #+END_EXAMPLE

  实际使用时：
  1. 当存在 pk = 0 的情况时，说明直线必然平行于某边界，如果此时还存在对应的 qk < 0，说明直线在边界外，可以简弃
  2. 当 pk < 0 时，线段从裁剪边界延长线的外部延伸到内部，是入边交点
  3. 当 pk > 0 是，线段从裁剪边界延长线的内部延伸到外部，是出边交点
  4. 此时，pk 值为四个，加上 u = 0 和 u = 1 就是六个
  5. 把 pk < 0 的 u 值和 0 比较去找最大的，把 pk > 0 的 u 值和 1 比较去找最小的，就可以得到两个端点的参数值

  其中，uk = qk / pk，计算得到的 umin 和 umax，若 umax > umin，则直线段在窗口外，删除该直线。否则将 u 值代入参数方程求出交点。

* 图元变换
  图元变换通过引入齐次方程的形式，将复杂的图元变换转换为了矩阵运算，可以很方便的实现复合变换。其中，基本变换为平移、比例、旋转、对称、错切。

  图元变换的一个重要作用就是进行坐标系的变换：建模坐标系 -> 世界坐标系 -> 观察坐标系。

  以下为错切和旋转的计算方程，旋转方程的得出过程中利用极坐标巧妙的消除了复杂的计算，只保留了角度和原始坐标：
  #+BEGIN_EXAMPLE
    x' = x + dy
    y' = bx + y

    x' = xcos - ysin
    y' = xsin + ycos
  #+END_EXAMPLE

  而变化矩阵的每一列分别和 (x, y, z, ...) 相对应。

  这些变化中最为复杂的大概就是旋转了，在三维旋转中，需要注意旋转的方向，其中，可以通过右手定则确定旋转正方向，特别的，围绕那个轴旋转那个轴的值就不变。

* 消隐算法
  消隐算法中的一个经典算法便是 z-buffer 算法了，这个算法的原始形式是通过一个帧缓存来保存颜色值，通过一个深度缓存来保存深度。

  当然了，原始形式对空间占用比较多，一种改进方式便是使用单个深度缓存变量，遍历每个像素，得到该像素点处深度最大的多边形。缺点时耗时会有所增加。

  使用改进的 z-buffer 算法是，需要进行点与多边形的包含性检测，一种简单的方式是通过射线法来进行判断：
  + 由被测点 P 处向 -y 方向作射线，交点个数是奇数，则被测点在多边形内部，交点个数是偶数表示在多边形外部。
    
  若射线正好经过多边形的顶点，则采用左开右闭的原则来实现。

* 其他
  + 常用的反走样算法：提高分辨率、非加权区域采样、加权区域采样
  + 根据投影中心和投影面之间的距离投影方式可以分为：
    + 平行投影：投影中心和投影面之间的距离无限远，投影线之间是平行的。根据投影方向可以分为：正投影和斜投影。
      正投影分为：三视图、正轴测图。斜投影：常见的有斜等测和斜二测
    + 透视投影：投影线相交于投影中心。投影中心也称为灭点。按照主灭点个数可以分为：一点透视、两点透视、三点透视
  + 字符裁剪的精度：串精度、字符精度和笔划/像素精度

