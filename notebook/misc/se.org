#+TITLE:      Misc - 结构化编程

* 目录                                                    :TOC_4_gh:noexport:
- [[#第-1-章-软件工程概述][第 1 章 软件工程概述]]
- [[#第-2-章-软件过程][第 2 章 软件过程]]
- [[#第-3-章-软件过程模型][第 3 章 软件过程模型]]
- [[#第-4-章-敏捷软件开发方法][第 4 章 敏捷软件开发方法]]
- [[#第-5-章-软件需求分析][第 5 章 软件需求分析]]
- [[#第-6-章-结构化分析][第 6 章 结构化分析]]
- [[#第-7-章-结构化设计][第 7 章 结构化设计]]
- [[#第-8-章-结构化软件测试][第 8 章 结构化软件测试]]

* 第 1 章 软件工程概述
  + 软件是计算机系统中与硬件对应的另一部分， 是一系列程序， 数据及文档的集合。

  + 程序、 数据和文档为软件的三要素

  + 软件的特征包括： 复杂性、 一致性、 退化性、 易变性、 移植性、 高成本

  #+CAPTION: 软件特征
  |--------+--------------------------------------------------------------|
  | 特征   | 描述                                                         |
  |--------+--------------------------------------------------------------|
  | 复杂性 | 比硬件更加复杂。是一个庞大的逻辑系统。                       |
  | 一致性 | 软件必须和运行它的硬件保持一致，依赖于硬件。                 |
  | 退化性 | 不存在硬件的磨损和老化问题。                                 |
  | 易变性 | 软件在生产过程、投入运行后也可以在改变，硬件不行。           |
  | 移植性 | 受计算机系统运行，不易移植。                                 |
  | 高成本 | 软件开发需要耗费大量的开发成本和管理成本。硬件可以走流水线。 |
  |--------+--------------------------------------------------------------|

  + 软件危机的主要表现为：

    - 软件供给需差距大

    - 软件开发管理困难

    - 软件开发模式过时

  + 方法、 工具和过程为软件工程的三要素

  + 质量、 成本和工期为软件工程管理的三要素

  + 软件工程的基本原理包括： 推迟实现、 逐步求精、 分解与抽象、 信息隐蔽、 质量保证

  + 软件工程的基本原则包括： 分阶段软件开发、 坚持进行阶段评审、 采用先进的程序设计技术、 明确责任、 开发小组的人员应少而精、 不断改进开发过程

  + 软件工程开发的方法有： 结构化开发方法学、 面向对象开发方法学、 形式化开发方法学

* 第 2 章 软件过程
  + 软件过程的定义是： 软件的诞生及其生命周期

  + 软件过程框架： 沟通、 策划、 建模、 构建和部署

  + 软件生存周期可以划分为： 定义、 开发和运行三个阶段

  + 软件生存周期包括： 问题的定义与可行性分析、 项目计划、 需求分析、 软件设计、 编码与测试、 运行与维护等阶段

  #+CAPTION: 软件生存周期
  |------------------------+----------------------------------------------------------------------------------------------------------------|
  | 阶段                   | 描述                                                                                                           |
  |------------------------+----------------------------------------------------------------------------------------------------------------|
  | 问题的定义与可行性分析 | 软件开发人员与客户沟通，确定软件的开发目标、范围、规模及项目的可行性。                                         |
  | 项目计划               | 根据项目的问题、范围、规模制定初步的开发计划。                                                                 |
  | 需求分析               | 在确定软件开发可行的情况下，对软件需要实现的各个功能进行详细分析。                                             |
  | 软件设计               | 根据需求分析的结果，对整个软件系统进行设计。                                                                   |
  | 编码与测试             | 将软件设计的结果转化为计算机可运行的程序代码。并在设计完成后进行严密的测试，以发现整个设计工过程中存在的问题。 |
  | 运行与维护             | 软件开发完成投入使用，延续软件的使用寿命进行维护。                                                             |
  |------------------------+----------------------------------------------------------------------------------------------------------------|

  + 软件工程活动包括： 沟通活动、 计划活动、 建模活动、 实现活动、 部署活动、 维护活动、 管理活动、 过程改进活动

* 第 3 章 软件过程模型
  + 软件过程模型： 把软件生存周期中各项开发活动的流程用一个合理框架 - 开发模型来规范描述

  + 传统的软件过程模型包括： 瀑布模型、 原型模型、 增量模型、 螺旋模型

  + 面向对象模型包括： 构建集成模型、 统一过程模型

  + 瀑布模型将软件生存周期划分为： 软件计划、 需求分析、 软件设计、 软件实现、 软件测试、 运行与维护这 6 个阶段

  + 瀑布模型接受上一项活动的工作结果作为输入， 然后实施该项活动应该完成的工作， 并将该活动的工作结果作为输出传给下一项活动

  + 瀑布模型具有的特点： 顺序性和依赖性、 推迟实现、 质量保证

  + 瀑布模型局限性： 缺乏灵活性，如用户需求一开始很难确定， 到最后阶段才能得到可运行的软件版本

* 第 4 章 敏捷软件开发方法
  略

* 第 5 章 软件需求分析
  + 软件需求包括的四个层次：
    1. 业务需求： 反映了组织机构或客户对系统、产品高层次的目标要求。 从总体上描述了为什么要开发系统（why），组织希望达到什么目标。

    2. 用户需求： 描述了用户使用产品必须要完成的任务， 描述了用户能使用系统来做些什么（what）

    3. 功能需求：开发人员在产品中实现的软件功能，用户利用这些功能来完成任务，满足业务需求。 功能需求是需求的主体，
       它描述的是开发人员如何设计具体的解决方案来实现这些需求（how）

    4. 非功能需求： 功能需求的补充，描述了系统完成功能实现的补充和约束条件, 可分为： 产品需求、 机构需求、 外部需求

  + 软件需求应该满足的基本特征： 完整性、 一致性和准确性

  + 需求分析过程为： 沟通、 导出需求、 精化需求、可行性研究、 与客户和用户协商、 编写需求规格说明书、 验证需求、 管理需求

  + 可行性研究包括： 经济可行性、 技术可行性、 社会法律可行性

  + 需求获取的技术： 会谈技术、 调查技术、 场景分析技术

* 第 6 章 结构化分析
  + 结构化分析 ~SA~ 是 *面向数据流* 的需求分析方法

  + 结构化的需求分析模型有： 数据字典（DD）、 数据流图（DFD）、  状态状态转换图（STD）、 实体关系图（ERD）

  + 数据流图的符号包括：
    - 矩形或立方体： 数据源点或终点

    - 圆角矩形或椭圆： 变换数据的处理

    - 开口矩形： 数据存储

    - 箭头： 数据流

  #+CAPTION: 数据字典语法
  |-------------+-------------------|
  | 符号        | 作用              |
  |-------------+-------------------|
  | x=...       | x 由 ... 组成     |
  | a+b         | a 和 b            |
  | [a, b]      | a 或 b            |
  | [a \vert b] | a 或 b            |
  | {a}         | 重复 a 任意次数   |
  | m{a}n       | 重复 a m 到 n 次  |
  | (a)         | 重复 a 零到一次   |
  | "a"         | 表示 a 是基本数据 |
  |-------------+-------------------|

  + 数据流建模方法的步骤： 数据流图要素分析、 构建数据流图和建立数据字典

  + 实体关系图的基本对象为： 实体、联系和属性

  + 实体间的关系包括： 一对一关系、 一对多关系、 多对多关系

  + 状态建模方法步骤： 系统状态、行为与事件分析、 构建状态图

  + 状态图符号：
    + 初态用实心圆表示
    + 终态用一对同心圆(内圆为实心圆)表示
    + 中间状态用圆角矩形表示

* 第 7 章 结构化设计
  + 软件设计主要包含两个阶段： 概要设计和详细设计

  + 软件概要设计步骤： 设计供选择的方案、 选取合理的方案、 推荐最佳方案、 功能分解和软件结构设计、 数据库设计、 编制设计文档、 审查和复查

  + 软件详细设计内容包括： 模块或构建描述、 算法描述、 数据描述

  + 模块或构建的处理逻辑可采用流程图、 PDL 语言、 盒图、 判定表等工具

  + 模块是一个独立命名的，拥有明确定义的输入、输出和特性的程序实体

  + 软件模块化设计定义： 把一个大型软件系统的全部功能，按照一定的原则合理地划分为若干个模块，每个模块完成一个特定子功能，
    所有的这些模块以某种结构形式组成一个整体，这就是 *软件的模块化设计*

  + 软件模块化设计的好处： 可以简化软件的设计和实现，提高软件的可理解性和可测试性，并使软件更容易得到维护

  + 软件模块化设计的指导方法包括： 分解、 抽象、 信息隐蔽、 逐步求精和模块独立性

  + 模块独立性由 *模块内聚性* 和 *模块间的耦合性* 衡量

  + 模块内聚性由弱到强的 7 个等级： 偶然性内聚、 逻辑性内聚、 时间性内聚、 过程性内聚、 通信性内聚、 顺序性内聚、 功能性内聚

  #+CAPTION: 模块内聚性
  |----------+--------------------------------------------------------------------------|
  | 名称     | 含义                                                                     |
  |----------+--------------------------------------------------------------------------|
  | 偶然内聚 | 模块内各部分间无联系                                                     |
  | 逻辑内聚 | 把几种相关功能组合在一模块内，每次调用由传给模块的参数确定执行哪种功能。 |
  | 时间内聚 | 模块完成的功能必须在同一时间内执行，这些功能只因时间因素关联在一起       |
  | 过程内聚 | 指一个模块完成多个任务，这些任务必须按指定的过程执行                     |
  | 通信内聚 | 模块内各部分使用相同的输入数据，或产生相同的输出结果                     |
  | 顺序内聚 | 模块内的多个任务顺序执行，上一个任务的输出是下一个任务的输入             |
  | 功能内聚 | 模块仅包括为完成某个功能所必须的所有成分                                 |
  |----------+--------------------------------------------------------------------------|

  + 模块耦合性由弱到强的 7 个等级： 非直接耦合、 数据耦合、 特征耦合、 控制耦合、 外部耦合、 公共耦合、 内容耦合

  #+CAPTION: 模块耦合性
  |------------+--------------------------------------------------------------------------|
  | 名称       | 含义                                                                     |
  |------------+--------------------------------------------------------------------------|
  | 非直接耦合 | 模块之间没有直接关系                                                     |
  | 数据耦合   | 模块调用另一模块时，被调用模块的输入、输出都是简单的数据                 |
  | 特征耦合   | 模块通过传递数据结构加以联系，或都与一个数据结构有关系                   |
  | 控制耦合   | 一个模块通过传送开关、标志、名字等控制信息，明显地控制选择另一模块的功能 |
  | 外部耦合   | 模块间通过软件之外的环境联结                                             |
  | 公共耦合   | 一组模块引用同一个公用数据区                                             |
  | 内容耦合   | 一模块直接访问另一模块的内部信息                                         |
  |------------+--------------------------------------------------------------------------|

  + 模块内聚性越高， 耦合性越低， 模块独立性越好

  + 软件结构图的基本成分有： 模块、 调用和数据

  + 软件结构图的形态特征：
    + 深度： 结构图控制的层次， 也是模块的层数

    + 宽度： 一层中最大的模块个数

    + 扇出： 一个模块的直接下属模块个数

    + 扇入： 一个模块直接上属模块的格式

  + 如果程序结构图的深度和宽度较大，则说明程序的规模和复杂程度都较大

  + 一个模块的扇出过大通常意味着该模块比较复杂，然而扇出太少，可能导致深度的增加

  + 启发式设计策略：
    + 降低耦合度，提高内聚度

    + 避免高扇出，并随着深度的增加，力求高扇入

    + 模块的影响范围应限制在该模块的控制范围内

    + 降低模块接口的复杂程度和冗余程度，提高一致性

    + 模块的功能应是可预测的

    + 尽可能设计单入口和单出口的模块

  + 结构化概要设计中， 根据信息流的特点可将信息流分为： 交换流和事务流。 两者同时出现为 混合流

  + 详细设计的基本任务： 每个模块的详细算法设计、 模块内数据结构的设计、 数据结构的物理设计即确定数据库的物理结构、 
    根据软件系统类型可能进行的设计（代码设计、 输入/输出 格式设计、 人机对话设计）、 详细设计说明书、 评审

  + 结构化详细设计： 程序的代码块仅仅通过顺序、选择和循环这三种基本控制结构进行连结，并且每个代码块只有一个入口和一个出口

  + 结构化详细设计的工具： 图表工具、 列表工具、 语言工具

  + *判定表与判定树* - 列表工具

* 第 8 章 结构化软件测试
  + 软件测试的目的： 为了发现软件缺陷的执行过程

  + 软件测试技术的核心： 尽早测试、 连续测试、 自动化测试

  + 验证和确认： 验证是指实现的软件产品是按照需求做的， 是符合需求说明书的； 确认是指实现的软件产品在 *用户环境* 下实现了
    用户的需要。

  + 软件测试的基本过程： 单元测试、 集成测试、 确认测试和系统测试

  + 测试用例是按一定的顺序执行的与测试目标相关的测试活动的描述

  + 测试技术可以分为：
    + *白盒测试：* 测试人员根据程序内部的逻辑结构及有关信息设计测试用例

    + *黑盒测试：* 测试人员完全不考虑程序内部的逻辑结构和内部特性，只依据程序的需求规格说明书

  + 黑盒测试技术： 等价类划分、 边界值分析、 错误推测、 因果图

  + 白盒测试技术： 逻辑覆盖、 路径覆盖、 循环路径测试

  + 逻辑覆盖法测试：
    + 语句覆盖： 选择足够的测试用例，使得程序中 *每个语句* 至少都能执行一次

    + 判定覆盖： 执行足够的测试用例， 使得程序中 *每个判定语句* 至少获得一次 *真值* 与 *假值*

    + 条件符号： 执行足够的测试用例， 使得程序中 *每个判定条件* 取得各种可能的结果， *判定语句* 可包含多个 *判定条件*

    + 判定／条件覆盖： 执行足够的测试用例，同时满足判定覆盖和条件覆盖的要求

    + 条件组合覆盖： 执行足够的测试用例，使得每个判定中条件的各种可能组合都至少执行一次

  + 路径测试 - 程序控制流图 映射要点：
    + 一个或多个顺序语句可映射为程序图的一个节点，用带标识的圆表示

    + 一个处理框序列和一个判别框可映射为程序图的一个节点

    + 程序控制流图用方向箭头表示

    + 右边和节点的限定范围称为 *区域*, 区域应包括图外部的范围

  + 独立路径： 从第一个节点到最后一个节点的路径， 独立路径中每个条件判断只执行一次

  + 确定程序图的环形复杂度：
    + V(G) = 程序图 G 的区域数

    + V(G) = E - N + 2, E 是程序图 G 的边数， N 是节点数

    + V(G) = P + 1, P 是程序图 G 中判定节点的个数

  + 循环路径测试策略： 简单循环测试、 嵌套循环测试、 串接循环测试

  + 简单循环测试：
    + 零次循环：从循环入口直接跳到循环出口
    + 一次循环：查找循环初始值方面的错误
    + 二次循环：检查在多次循环时才能暴露的错误
    + m 次循环：此时的 m ＜ n，也是检查在多次循环时才能暴露的错误
    + n(最大)次数循环、n+1 (比最大次数多一)次的循环、n-1(比最大次数少一)次的循环

  + 嵌套循环测试：
    + 从最内层循环开始，设置所有其他层的循环为最小值
    + 对最内层循环做简单循环的全部测试。测试时保持所有外层循环的循环变量为最小值。另外，对越界值和非法值做类似的测试
    + 逐步外推，对其外面一层循环进行测试。测试时保持所有外层循环的循环变量取最小值，所有其它嵌套内层循环的循环变量取“典型”值
    + 反复进行，直到所有各层循环测试完毕
    + 对全部各层循环同时取最小循环次数，或者同时取最大循环次数

  + 串接循环测试：
    + 如果各个循环互相独立，则串接循环可以用与简单循环相同的方法进行测试。
    + 如果有两个循环处于串接状态，而前一个循环的循环变量的值是后一个循环的初值。则这几个循环不是互相独立的，则需要使用测试嵌套循环的办法来处理

