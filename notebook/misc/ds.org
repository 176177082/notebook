#+TITLE:      设计模式

* 目录                                                    :TOC_4_gh:noexport:
- [[#面向对象设计原则][面向对象设计原则]]
- [[#类之间的关系][类之间的关系]]
- [[#模式概览][模式概览]]
- [[#模式应用][模式应用]]
- [[#相关问题][相关问题]]
  - [[#桥接模式和策略模式的区别][桥接模式和策略模式的区别]]
  - [[#代理模式和装饰模式之间的区别][代理模式和装饰模式之间的区别]]

* 面向对象设计原则
  |--------------+------------------------------------------------|
  | 设计原则     | 解释                                           |
  |--------------+------------------------------------------------|
  | 单一职责原则 | 类的职责要单一，不能将太多的职责放在一个类中   |
  | 开闭原则     | 对扩展开放，对修改关闭                         |
  | 里氏代换原则 | 所有引用基类的地方必须能透明地使用其子类的对象 |
  | 依赖倒转原则 | 针对抽象编程，而不是针对具体编程               |
  | 接口隔离原则 | 使用多个专门的接口来取代一个统一的接口         |
  | 合成复用原则 | 尽量多使用组合和聚合关系，少用或不用继承关系   |
  | 迪米特法则   | 一个软件实体对其他实体的引用越少越好           |
  |--------------+------------------------------------------------|

* 类之间的关系
  关联关系是指一个类包含另一个类的引用：
  + 聚合关系：一个类包含另一个类的引用，两者生命周期相互独立，通过空心菱形表示
  + 组合关系：一个类包含另一个类的引用，两者生命周期相一致，通过实心菱形表示

  依赖关系通常是指一个类的方法的参数或返回值包含另一个类型，通常用虚线箭头表示。

  泛化关系通常指继承关系，通常用实线空心三角形表示，对于接口来说通常用虚线空心三角形表示。

* 模式概览
  |--------------+------------------------------------------------------+------------------------------|
  | 模式名称     | 模式角色                                             | 模式扩展                     |
  |--------------+------------------------------------------------------+------------------------------|
  | 工厂方法模式 | 抽象工厂、具体工厂、抽象产品、具体产品               |                              |
  | 抽象工厂模式 | 抽象工厂、具体工厂、抽象产品、具体产品               |                              |
  | 建造者模式   | 抽象建造者、具体建造者、产品、指挥者                 |                              |
  | 原型模式     | 抽象原型类、具体原型类、客户类                       | 带原型管理器的原型模式       |
  | 单例模式     | 单例角色                                             | 饿汉式单例类、懒汉式单例类   |
  | 适配器模式   | 目标抽象类、适配器类、适配者类、客户类               | 缺省适配器模式               |
  | 桥接模式     | 抽象类、扩充抽象类、实现类接口、具体实现类           |                              |
  | 组合模式     | 抽象构件、叶子构件、容器构件、客户类                 | 透明组合模式、安全组合模式   |
  | 装饰模式     | 抽象构件、具体构件、抽象装饰类、具体装饰类           | 透明装饰模式、半透明装饰模式 |
  | 外观模式     | 外观角色、子系统角色                                 |                              |
  | 享元模式     | 抽象享元类、具体享元类、非共享具体享元类、享元工厂类 | 单次享元模式、复合享元模式   |
  | 代理模式     | 抽象主题角色、代理主题角色、真实主题角色             | 远程代理、虚拟代理           |
  | 责任链模式   | 抽象处理者、具体处理者、客户类                       | 纯/不纯责任链模式            |
  | 命令模式     | 抽象命令类、具体命令类、调用者、接受者、客户类       | 撤销操作、宏命令             |
  | 解释器模式   | 略                                                   | 略                           |
  | 迭代器模式   | 抽象迭代器、具体迭代器、抽象聚合类、具体聚合类       |                              |
  | 中介者模式   | 抽象中介者、具体中介者、抽象同事类、具体同事类       |                              |
  | 备忘录模式   | 原发器、备忘录、负责人                               |                              |
  | 观察者模式   | 目标、具体目标、观察者、具体观察者                   |                              |
  | 状态模式     | 环境类、抽象状态类、具体状态类                       | 简单状态模式、可切换状态     |
  | 策略模式     | 环境类、抽象策略了、具体策略类                       |                              |
  | 模板方法模式 | 抽象类、具体子类                                     |                              |
  | 访问者模式   | 抽象访问者、具体访问者、抽象元素、具体元素、对象结构 |                              |
  |--------------+------------------------------------------------------+------------------------------|
  
* 模式应用
  + 适配器模式的一种常见应用方式：定义接口 -> 提供默认抽象实现类 -> 自定义具体实现类

* 相关问题
** 桥接模式和策略模式的区别
   这是两个非常相似的模式，但好在下面这篇文章很好的解释了两个模式之间的区别：
   + [[http://www.blogjava.net/wangle/archive/2007/04/25/113545.html][从桥接模式与策略模式谈起 - 一半是火焰，一半是海水 - BlogJava]]

** 代理模式和装饰模式之间的区别
   #+begin_quote
   Decorator Pattern focuses on dynamically adding functions to an object, while Proxy Pattern focuses on controlling access to an object.
   #+end_quote
   
   然而在实际的使用中，比如在 AOP 框架中，使用代理来添加行为的并不少，只能说，代理太好用了。

   参考：[[https://stackoverflow.com/questions/18618779/differences-between-proxy-and-decorator-pattern][oop - Differences between Proxy and Decorator Pattern - Stack Overflow]]

