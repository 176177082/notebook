#+TITLE:      LeetCode - 109. 有序链表转换二叉搜索树

* 目录                                                    :TOC_4_gh:noexport:
- [[#问题描述][问题描述]]
- [[#解决方案---1][解决方案 - 1]]
- [[#解决方案---2][解决方案 - 2]]

* 问题描述
  给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。

  本题中，一个高度平衡二叉树是指一个二叉树每个节点的左右两个子树的高度差的绝对值不超过 1。

  *示例：*
  #+BEGIN_EXAMPLE
    给定的有序链表： [-10, -3, 0, 5, 9],

    一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：

          0
         / \
       -3   9
       /   /
     -10  5
  #+END_EXAMPLE

* 解决方案 - 1
  将链表转换为数组，然后用数组来生成二叉搜索树，这是一个可以接受的解决方案，但是多出了将链表转换为数组的开销。

  #+BEGIN_SRC python
     # Definition for singly-linked list.
     # class ListNode:
     #     def __init__(self, x):
     #         self.val = x
     #         self.next = None

     # Definition for a binary tree node.
     # class TreeNode:
     #     def __init__(self, x):
     #         self.val = x
     #         self.left = None
     #         self.right = None

     class Solution:
         def sortedListToBST(self, head):
             """
             :type head: ListNode
             :rtype: TreeNode
             """
             lst = []
             while head:
                 lst.append(head.val)
                 head = head.next
             left, right = 0, len(lst) - 1
             return self.toBST(lst, left, right)
        
         def toBST(self, head, left, right):
             if left <= right:
                 mid = (left + right) // 2
                 node = TreeNode(head[mid])
                 node.left = self.toBST(head, left, mid - 1)
                 node.right = self.toBST(head, mid + 1, right)
                 return node
             return None
  #+END_SRC

* 解决方案 - 2
  简单的常识问题，fast 的移动速度是 slow 的两倍，因此，当 fast 到达尾部时， slow 所在的位置就在中间。

  #+BEGIN_SRC java
    /**
     ,* Definition for singly-linked list.
     ,* public class ListNode {
     ,*     int val;
     ,*     ListNode next;
     ,*     ListNode(int x) { val = x; }
     ,* }
     ,*/
    /**
     ,* Definition for a binary tree node.
     ,* public class TreeNode {
     ,*     int val;
     ,*     TreeNode left;
     ,*     TreeNode right;
     ,*     TreeNode(int x) { val = x; }
     ,* }
     ,*/
    class Solution {
      public TreeNode sortedListToBST(ListNode head) {
        return buildTree(head, null);
      }

      public TreeNode buildTree(ListNode head, ListNode tail) {
        if (head == tail) return null;

        ListNode fast = head;
        ListNode slow = head;
        while (fast != tail && fast.next != tail) {
          fast = fast.next.next;
          slow = slow.next;
        }

        TreeNode root = new TreeNode(slow.val);
        root.left = buildTree(head, slow);
        root.right = buildTree(slow.next, tail);

        return root;
      }
    }
  #+END_SRC

