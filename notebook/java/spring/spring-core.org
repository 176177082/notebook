#+TITLE:      Spring Core

* 目录                                                    :TOC_2_gh:noexport:
- [[#spring-bean][Spring Bean]]
  - [[#bean-属性][Bean 属性]]
  - [[#自动注入][自动注入]]
  - [[#注意事项][注意事项]]
- [[#spring-aop][Spring AOP]]
  - [[#注意事项-1][注意事项]]
- [[#相关技巧][相关技巧]]
- [[#相关问题][相关问题]]
  - [[#怎样在-xml-配置文件中指定-qualifier][怎样在 XML 配置文件中指定 Qualifier]]
  - [[#怎样在获取-bean-的时候指定-qualifier][怎样在获取 Bean 的时候指定 Qualifier]]
  - [[#spring-低版本下自我装配失败的问题][Spring 低版本下自我装配失败的问题]]
  - [[#bean-name-和-id-的区别][Bean Name 和 ID 的区别]]

* Spring Bean
** Bean 属性
   Bean 的定义包括如下属性：
   #+BEGIN_QUOTE
   Class、Name、Scope、Constructor arguments、Properties、Autowiring mode、Lazy initialization mode、Initialization method、Destruction method
   #+END_QUOTE

   其中，初始化方法和销毁方法可以通过注解配置。
   
   参考：
   + [[https://www.cnblogs.com/zrtqsk/p/3735273.html][Spring Bean 的生命周期 - Chandler Qian - 博客园]]
   + [[https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-definition][Core Technologies - Bean Overview]]

** 自动注入
   使用 @ComponentScan 定义扫描范围的时候，可以通过 ~includeFilters~ 和 ~excludeFilters~ 更详细的设置扫描范围。

   Filter 的类型可以是：annotation、assignable、aspectj、regex 和 custom。

   参考：
   + [[https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-scanning-filters][Core Technologies - Using Filters to Customize Scanning]]

** 注意事项
   + 通过 @Condition 创建 Bean 时，如果创建失败就无法获取实例了（单例作用域是这样的）
   + 没有使用 AOP 的 Bean 获取是返回的就是它的实例，而使用了 AOP 的 Bean 返回的就是它的动态代理
   + 当自动装配和 JavaConfig 同时存在时，会优先使用自动装配
   + 配置的处理顺序：AutoWired、JavaConfig、XMLConfig，其中，如果自动装配已创建 Bean，那么 JavaConfig 中的便无效
   + XML 中的配置是必然会执行的，那怕是单例作用域
   + 原型作用域会在需要 bean 的时候创建，单例会在启动时创建
   + 自动装配、JavaConfig 和 XML 配置都可以使用大多数装配技术，如 @Condition

* Spring AOP 
** 注意事项
   + 环绕 Advice 的返回值需要和被环绕的方法相同，传递给 Advice 的参数名称和 args 定义的相同

* 相关技巧
  + 自动注入可以获得应用上下文对象：
    #+BEGIN_SRC java
      public class Example {
        @AutoWired
        ApplicationContext context;
      }
    #+END_SRC

* 相关问题
** 怎样在 XML 配置文件中指定 Qualifier
   在 XML 中指定 Bean 的 Qualifier 是很简单的：
   #+BEGIN_SRC xml
     <bean class="xxx">
       <qualifier value = "xxx" />
     </bean>
   #+END_SRC

** 怎样在获取 Bean 的时候指定 Qualifier
   可以使用 ~BeanFactoryAnnotationUtils~ 完成这一操作：
   #+BEGIN_SRC java
     BeanFactoryAnnotationUtils.qualifiedBeanOfType(ctx.getBeanFactory(), Service.class, "Wanted")
   #+END_SRC
** Spring 低版本下自我装配失败的问题
   Spring 低版本下自我装配会出现错误，官方对此的支持从 4.3 版本开始：
   #+BEGIN_SRC java
     public class Test {
       @AutoWired
       private Test test;
     }
   #+END_SRC

   参考： [[https://stackoverflow.com/questions/5152686/self-injection-with-spring][java - Self injection with Spring - Stack Overflow]]

** Bean Name 和 ID 的区别
   ID 和 Name 的本质区别：Id 只能定义 1 个 Identifier，而 Name 可以定义多个 Aliases。

   1. 配置一个 bean 的时候，我们可以不设置 id，也可以不设置 name，spring 默认会使用类的全限定名作为 bean 的标识符
   2. 如果使用 id 属性来设置 bean 的标识符，那么 id 在 spring 容器中必需唯一
   3. 如果使用 name 属性来设置，那么设置的其实就是 bean 的标识符，必需在容器中唯一
   4. 如果同时设置 id 和 name，那么 id 设置的是标识符，name 设置的是别名
   5. 如果 id 和 name 的值相同，那么 spring 容器会自动检测并消除冲突：让这个 bean 只有标识符，而没有别名
   6. name 属性设置多个值。不设置 id，那么第一个被用作标识符，其他的被视为别名。如果设置了 id，那么 name 的所有值都是别名
   7. 使用 <alias> 标签指定别名，别名也必须在 IoC 容器中唯一

   #+BEGIN_SRC java
     context.getAliases()
     context.getBean()
   #+END_SRC

