#+TITLE:      Java 虚拟机结构

* 目录                                                    :TOC_4_gh:noexport:
- [[#运行时数据区域][运行时数据区域]]
- [[#对象的创建和内存布局][对象的创建和内存布局]]
- [[#垃圾回收][垃圾回收]]
- [[#类文件结构][类文件结构]]
- [[#字节码指令][字节码指令]]
- [[#类加载机制][类加载机制]]
  - [[#类加载器][类加载器]]
  - [[#相关问题][相关问题]]
- [[#字节码执行引擎][字节码执行引擎]]
  - [[#解析][解析]]
  - [[#分派][分派]]
- [[#程序编译与代码优化][程序编译与代码优化]]
- [[#footnotes][Footnotes]]

* 运行时数据区域
  Java 虚拟机的运行时数据区分为：
  1. 程序计数器 PC，是一块较小的内存空间，可以看做是当前线程所指向的字节码的行号指示器，各线程的程序计数器互不影响
  2. Java 虚拟机栈，线程私有，保存方法执行时需要的数据，可能抛出 StackOverflowError 和 OutOfMemoryError 异常
  3. 本地方法栈，和虚拟机栈类似，为 native 方法服务，可能抛出 StackOverflowError 和 OutOfMemoryError 异常
  4. Java 堆，被所有线程共享的内存区域，用于存放所有的对象实例，可能抛出 OutOfMemoryError 异常
  5. 方法区，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态常量等数据，可能抛出 OutOfMemoryError 异常
  6. 运行时常量池，是方法区的一部分，用于存放编译器生成的各种字面量和符号引用，也可以在运行期间将新的常量放入

  其中，程序计数器、虚拟机栈和本地方法栈都是线程独立的，而方法区和堆被所有线程共享。

  另外，需要注意区分 Class 文件常量池和运行时常量池，Class 文件常量池中的内容会在加载时自动放入运行时常量池，但同时也可以在运行期间将常量放入运行时常量池。

* 对象的创建和内存布局
  通过 =new= 指令创建对象的流程为：
  1. 检查这个指令的参数能否在常量池中定位到一个类的符号引用
  2. 检查这个符号引用代表的类是否已被加载、解析和初始化过
  3. 如果没有，就必须先执行类加载过程
  4. 在类加载检查通过后，虚拟机便可以为新对象分配内存
  5. 内存分配完后，需要将分配到的内存空间都初始化为零值（不包括对象头），这一步保证了实例字段即使不赋值也可以直接使用
  6. 对对象进行必要的设置，例如这个对象是哪个类的实例、如何找到类的元数据信息、对象的哈希码等信息，这些信息存放在对象头（Object Header）中
  7. 一般来说，在前面的步骤完成后还会执行 =<init>= 方法，由字节码中是否跟随 =invokespecail= 指令决定
  
  其中，在分配内存时可以选择的策略有：
  1. 指针碰撞，内存空间规整，直接一段指针分配内存就可以了
  2. 空闲列表，内存空间不规整，虚拟机需要维护一个列表，记录哪些内存块时可用的，在分配的时候在列表中找到足够大的空间划分给对象实例，并更新列表记录

  另外，由于对象创建十分频繁的行为，为了避免出现正在给对象 A 分配内存，指针还没来得及修改，对象 B 有同时使用了原来的指针分配内存的情况，虚拟机有两种解决方案：
  1. 对分配内存空间的动作进行同步处理，保证原子性
  2. 把内存分配的动作按照线程划分到不同的空间进行，即每个线程在 Java 堆中预分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）。
     现在 TLAB 上分配内存，不够时才同步分配新的 TLAB。

     对象创建的第 5 步其实就可以提前到 TLAB 阶段完成。

  对象在内存中主要包含两个部分：
  1. 对象头，包含两个部分，一部分用于存储对象自身的运行时数据，如哈希码、锁状态标志、线程持有的锁等。另一部分是类型指针，用于执行对象类元数据的指针，但不是所有虚拟机实现都有。

     因为对象的访问定位可以由两种形式：
     1. 使用句柄，在堆中划分一块内存作为句柄池，引用中保存的就是对象的句柄地址，而句柄中包含 *对象实例数据* 和 *类型数据* 各自的地址信息
     2. 使用直接指针访问，这时对象头中就需要类型指针了
        
     同时，假如对象是数组，那么对象头还需要保证数组的大小信息。
     
  2. 实例数据，主要就是各个实例字段数据，通常相同宽度的字段会被放在一起
  
  除了对象头和实例数据以外，可能还要对齐填充，保证对象的大小是 8 的整数倍。

* 垃圾回收
  Java 中通过（根）可达性分析算法来判定对象是否存活，在 Java 语言中，可作为 GC Roots 的对象有：
  1. 虚拟机栈中引用的对象
  2. 方法区中类静态属性引用的对象
  3. 方法区中常量引用的对象
  4. 本地方法栈中引用的对象

  堆中对象的死活判定比较方便，而方法区中的常量也很容易判断死活，相对麻烦的是类，满足以下条件的类才是无用的类：
  1. 该类的所有实例都已被回收
  2. 加载该类的 ClassLoader 已经被回收
  3. 该类对应的 Class 对象没有在任何地方被引用

  在知道怎么判断一个对象的死活后，剩下的就是如何回收内存了，主要有三种算法：
  1. 标记清除算法，首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，主要问题是效率低，同时会产生大量不连续的内存碎片
  2. 复制算法，将内存分配为多个区域，每次只使用其中一部分内存，回收时将存活对象复制到空闲内存，主要问题是会造成内存空间的浪费，内存不足时还需要依赖其他内存进行分配担保
  3. 标记整理算法，算法过程和标记清除算法类似，区别在于清理时是将存活对象往内存的一端移动

  根据对象存活的周期不同，虚拟机往往采用分代收集算法来同时使用多个算法，比如将内存分为新生代和老年代，在新生代采用复制算法，在老年代采用标记清除或标记整理算法

  实现这些回收策略的垃圾收集器：
  |-------------------+--------------------------------------------+------------+--------------|
  | 垃圾收集器        | 特点                                       | 新生代算法 | 老年代算法   |
  |-------------------+--------------------------------------------+------------+--------------|
  | Serial            | 单线程，GC 时阻塞所有工作现场              | 复制算法   |              |
  | ParNew            | 多线程，GC 时阻塞所有工作现场              | 复制算法   |              |
  | Parallel Scavenge | 可以通过控制收集评率达到一个可控制的吞吐量 |            |              |
  | Serial Old        | Serial 的老年代版本                        |            | 标记整理算法 |
  | ParNew Old        | ParNew 的老年代版本                        |            | 标记整理算法 |
  | ……                |                                            |            |              |
  |-------------------+--------------------------------------------+------------+--------------|

  因为对内存区域进行了划分，因此 GC 方法也可以分为 Minor GC（新生代 GC）和 Full GC，通常，现在一些优秀的垃圾回收器可以在不阻塞工作线程的情况下进行 GC，
  但是 Full GC 的时候，往往就避免不了要停顿工作线程了。

* 类文件结构
  Java 虚拟机类文件中采用类似 C 语言结构体的伪结构来存储数据，这种结构只有两种数据类型：无符号数和表，其中，无符号数采用大端形式存储：
  |----------------+---------------------+-------------------------+--------------------|
  | 类型           | 名称                |                    数量 | 含义               |
  |----------------+---------------------+-------------------------+--------------------|
  | u4             | magic               |                       1 | Magic Number       |
  |----------------+---------------------+-------------------------+--------------------|
  | u2             | minor_version       |                       1 | 次版本号           |
  | u2             | major_version       |                       1 | 主版本号           |
  |----------------+---------------------+-------------------------+--------------------|
  | u2             | constant_pool_count |                       1 | 常量池大小         |
  | cp_info        | constant_pool       | constant_pool_count - 1 | 常量信息表         |
  |----------------+---------------------+-------------------------+--------------------|
  | u2             | acess_flags         |                       1 | 访问标志           |
  | u2             | this_class          |                       1 | 当前类全限定名索引 |
  | u2             | super_class         |                       1 | 父类全限定名索引   |
  | u2             | interfaces_count    |                       1 | 实现接口数量       |
  | u2             | interfaces          |        interfaces_count | 接口全限定名索引   |
  |----------------+---------------------+-------------------------+--------------------|
  | u2             | fields_count        |                       1 | 字段信息表数量     |
  | field_info     | fields              |            fields_count | 字段信息表         |
  |----------------+---------------------+-------------------------+--------------------|
  | u2             | methods_count       |                       1 | 方法信息表数量     |
  | method_info    | methods             |           methods_count | 方法信息表         |
  |----------------+---------------------+-------------------------+--------------------|
  | u2             | attributes_count    |                       1 | 类额外属性数量     |
  | attribute_info | attributes          |        attributes_count | 类额外属性表       |
  |----------------+---------------------+-------------------------+--------------------|

  除了类文件以外，字段信息表和方法信息表都可以有自己的属性表，各表主体信息只保存一些相对固定的数据，比如访问表示、限定名称索引等，
  而其他属性，如方法字节码、行号等就保存在对应的属性表中。

  整体来看，类文件的格式和网络协议相似，类似于 TLV 格式，可以通过 ~javap -v~ 选项来查看对应信息。

  方法和字段描述符格式：
  1. 类型的表示方式通过标识字符和限定名组成：
     |----------+--------+----------+--------------------------------|
     | 标识字符 | 含义   | 标识字符 | 含义                           |
     |----------+--------+----------+--------------------------------|
     | B        | byte   | J        | long                           |
     | C        | char   | S        | short                          |
     | D        | double | Z        | boolean                        |
     | F        | float  | V        | void                           |
     | I        | int    | L        | 对象类型，如 Ljava/lang/Object |
     |----------+--------+----------+--------------------------------|
  2. 对于数组类型，每一维度使用一个前置的 ~[~ 字符描述，因此 ~String[][]~ 的描述符就为 ~[[Ljava/lang/String~
  3. 方法描述符的格式为 ~(参数描述符...)返回值描述符~, 比如 ~void method(int a, String b)~ 的描述符就为 ~(ILjava/lang/String)V~
  4. 描述符结尾往往还会有一个分号，比如 ~(II)I;~

  需要注意的是，方法描述符包括返回值，但是方法签名是不包括的。

  Tips:
  1. 类文件中保存的只是符号引用，而符号引用对其他类的引用只是一个描述符，因此，在加载类的时候，可以通过修改描述符达到引用其他类的目的，毕竟，
     字节码中指令参数也是常量池中的符号引用，不需要去修改字节码

* 字节码指令
  Java 虚拟机采用面向操作数栈的架构，指令由单字节的操作码和跟随之后的零个或多个操作数构成。

  针对不同的类型，虚拟机可能提供了相同操作码的不同特化，这些操作码可以通过操作码助记符区分：
  + i - int、l - long、s - short、b - byte、c - char、f - float、d - double、a - reference

  这里可以看出来，能够存储在栈中的数据除了基本数据类型以外就是引用了。

  编译器会在编译期货运行期将 byte 和 short 类型数据符号扩展为相应的 int 类型数据，将 boolean 和 char 类型无符号扩展为相应的 int 类型数据，
  从而复用 int 类型的操作码，避免重复定义太多指令。

  相对特殊的是同步指令，分为两种情况：
  1. 方法级别的同步，无需字节码指令实现，当虚拟机发现 ACC_SYNCHRONIZED 标志为 true 时便会自动加锁
  2. 代码块的同步，通过 ~monitorenter~ 和 ~monitorexit~ 指令完成，编译器会保证只要调用过 ~monitorenter~ 就一定会调用 ~monitorexit~

     比如生成一个异常处理器，即使同步代码块中抛出了异常也会执行 ~monitorexit~ 指令

* 类加载机制
  Java 虚拟机中，类型的加载、连接和初始化都是在程序运行期间完成的，整个生命周期大致可以分为：加载、验证、准备、解析、初始化、使用和卸载七个阶段，
  其中，验证、准备和解析三个阶段被称为连接。

  各阶段的操作：
  1. 加载，通过类的全限定名来获取定义此类的二进制字节流，将这个字节流代表的静态文件存储结构转化保存到方法区，并在内存中生成相应的 =Class= 对象
  2. 验证，对文件格式、元数据（类型语义，如继承、实现接口、抽象方法的实现等）、字节码和符号引用（引用的符号是否存在、能否访问）进行验证
  3. 准备，为类变量（不是实例变量）分配内存并设置初始值，通常为零值，但假如字段属性表中存在 =ConstantValue= 属性，那么准备阶段就可以完成赋值，通常为基本类型或字符串
  4. 解析，将符号引用转换为直接引用的过程，主要包括类、接口、字段、类方法、接口方法、方法类型、方法句柄、调用限定符的解析

     注意：字段解析会先根据类名称寻找字段，找不到的时候回到父接口和父类中去找，这就使得：
     + 当子类和父类存在同名字段时，用哪个类名获取就是哪个类的
     + 父类和父接口存在同名字段时，父接口优先级更高，但是编译器往往会在存在同名字段时报错

     解析成功后，还会对符号进行 *符号引用验证*
  5. 初始化，执行类或接口的 =<clinit>= 方法，会先执行父类的 =<clinit>= 方法，但是不会执行父接口的，另外，该方法的执行是同步的，这意味执行时阻塞可能导致其他线程阻塞

     问：为什么接口也有 =<clinit>= 方法？
     答：应该是为了初始化接口字段的值，当字段类型为除了 =String= 以为的对象时，就只能在 =<clinit>= 方法中初始化了

     另外，方法 =<init>= 和方法 =<clinit>= 分别为实例和类的初始化服务。

  对于类的初始化来说，只有满足以下五个情况之一时才会对类进行初始化：
  1. 遇到 new、getstatic、putstatic 或 invokestatic 四个指令时，即：使用 new 关键字实例化对象时、获取或设置一个类的静态字段（被 final 修饰、已在编译器把结果放入常量池的静态字段除外）、
     调用类的静态方法时。这里需要注意字段被 final 修饰或已在编译器把结果放入常量池的情况，这时，它们的值在准备阶段就已经准备好了，不需要对类进行初始化。
  2. 对类进行反射调用的时候
  3. 初始化一个类的时候，其父类还没有初始化，那么就会先进行父类的初始化，注意，没有父接口
  4. 加载执行主类的时候回初始化主类
  5. 使用动态语言支持对应的方法句柄没有初始化时

** 类加载器
   Java 虚拟机中每个类由 *类* 本身和它的 *类加载器* 唯一确定，类一样但是类加载器不一样，那么也不是同一个类。

   对于 Java 虚拟机来说，只存在两种类加载器，分别为：
   + 启动类加载器 - BootstrapClassLoader，是虚拟机的一部分，无法被用户获取
   + 其他类加载器，由 Java 语言实现，独立于虚拟机，都继承自抽象类 =ClassLoader=

   对于开发人员来说，系统提供的类加载器又可以分为三类：
   1. 启动类加载器 - BootstrapClassLoader，用于加载 =<JAVA_HOME>/lib= 目录下的类，通过名称进行识别，不符合的名称不会进行加载
   2. 扩展类加载器 - ExtensionClassLoader，用于加载 =<JAVA_HOME>/lib/ext= 目录下的类，同样通过名称进行识别，父类加载器为 null(BootstrapClassLoader)，可以被用户获取
   3. 应用程序类加载器 - ApplicationClassLoader，用于加载用户类路径上的类，也被成为系统类加载器，父类加载器为 ExtensionClassLoader

   详情可以查看 ~sun.misc.Launcher~ 这个类的源码。

   类加载器之间的关系通常满足双亲委派模型，每个类加载器都通过组合关系持有它的父类加载器，加载类时，先用父类加载器尝试加载，加载不了才使用子类加载器。
   这保证了 JDK 中类的优先级。

   基本逻辑为：
   #+begin_src java
     protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
       synchronized (getClassLoadingLock(name)) {
         // 首先检查是否已经加载了
         Class<?> c = findLoadedClass(name);
         if (c == null) {
           try {
             if (parent != null) {
               c = parent.loadClass(name, false);
             } else {
               // 父类加载器不存在时就使用 BootstrapClassLoader
               c = findBootstrapClassOrNull(name);
             }
           } catch (ClassNotFoundException e) {
             // ClassNotFoundException thrown if class not found
             // from the non-null parent class loader
           }

           if (c == null) {
             // 父类加载器加载失败，调用自己的加载方法
             c = findClass(name);
           }
         }
         if (resolve) {
           // 执行连接操作
           resolveClass(c);
         }
         return c;
       }
     }
   #+end_src
   
   在这种结构性，定义自己的类加载往往只需要定义 ~findClass~ 方法就足够了。

** 相关问题
   + 为什么说 SPI 打破双亲委派机制？

     SPI 机制中，在为指定类加载时会使用 =Thread.currentThread().getContextClassLoader()= 中的类加载器，如果不用的话就可能会出现如下情况：
     1. 从 META-INF/services/java.sql.Driver 文件得到实现类名字 DriverA
     2. Class.forName("xx.xx.DriverA") 来加载实现类
     3. Class.forName() 方法默认使用当前类的 ClassLoader，JDBC是 在 DriverManager 类里调用 Driver 的，当前类也就是 DriverManager，
        它的加载器是 BootstrapClassLoader
     4. 用 BootstrapClassLoader 去加载非 rt.jar 包里的类 xx.xx.DriverA，就会找不到
     5. 要加载 xx.xx.DriverA 就需要用到 AppClassLoader 或其他自定义 ClassLoader
     6. 最终矛盾出现在，要在 BootstrapClassLoader 加载的类里，调用 AppClassLoader 去加载实现类

     虽然实现细节上存在区别，但大致逻辑就是这么个逻辑，用那个类加载器加载一个类，那么那个类的类加载器就是加载它的类加载器。也就是说，
     我们的程序运行时，存在拥有不同类加载器的类。

* 字节码执行引擎
  栈帧时用于支持虚拟机进行方法调用和方法执行的虚拟结构，每个栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。

  位于栈顶的栈帧称为当前栈帧，对应的方法称为当前方法，通过 =Throwable.printStackTrace= 打印出的内容在一定程度上反应了栈帧结构。
  
  #+begin_quote
  这里应该注意区分栈帧和栈的概念，栈不用多说，但是栈帧通常指代的是函数调用过程中，在栈上维护的一个独立的区域，保存函数调用需要的信息[fn:1]。
  #+end_quote

  栈帧位于虚拟机栈中，各部分的数据结构和作用为：
  1. 局部变量表，用于存放方法参数和方法内部定义的局部变量，容量以变量槽为最小单位，对于实例方法来说，局部变量表中的第一个变量往往为 =this= 引用。

     另外，因为局部变量表 Slot 复用的原因，可能导致局部变量即使离开了其作用域，但是 Slot 中依然存在相应的引用使得其无法被回收。

  2. 操作数栈，栈容量的单位是 32 位，对于基于栈的指令架构来说，优势是可移植，缺陷是由于频繁的出入栈而额外的操作，执行速度会变慢

  3. 动态连接，每个栈帧都包含一个执行运行时常量池中该栈帧所属方法的引用，用于支持方法调用过程中的动态连接（每次运行期间将符号引用转化为直接引用）

  4. 方法返回地址

  字节码执行引擎这一部分中一项重要的内容就是方法调用的过程，主要可以分为解析和分派两类。

** 解析
   对于能够在编译器就能够确定下来的方法调用类型被称为解析，符合这一要求的方法类型有：静态方法、私有方法、实例构造器、父类方法和被 =final= 修饰的方法，
   这些方法被叫做非虚方法，主要通过 =invokestatic= 和 =invokespecail= 指令调用。

   而 =final= 方法虽然需要通过 =invokevirtual= 指令调用，但是它还是可以通过解析的方式调用。

** 分派
   分派中的两种主要分派方式为静态分派和动态分派，其中，静态分派时重载机制实现的基础，而动态分派则是重写机制实现的基础。

   对于如下语句来说，我们将 =Human= 称为 =man= 的静态类型，而将 =Man= 称为 =man= 的实际类型：
   #+begin_src java
     Human man = new Man();
   #+end_src
   
   静态类型仅在使用时发生变化，而实际类型却需要在运行期间确定：
   #+begin_src java
     // 实际类型变化
     Human man = new Man();
     man = new Woman();

     // 静态类型变化
     sr.sayHello((Man) man);
     sr.sayHello((Woman) man);
   #+end_src

   使用方法的那个重载版本有传入参数的数量和 *静态类型* 确定，整个过程在编译期完成，需要注意的是字面量的类型推导过程，当不存在和字面量直接匹配的重载时会历经如下步骤：
   #+begin_example
     自动类型转换(char -> int -> long -> float -> double) -> 自动装箱 -> 尝试匹配实现的接口 -> 父类 -> 变长参数
   #+end_example

   而动态分派对于的便是重写了，通常由 =invokevirtual= 指令调用，运行时解析过程大致为：
   1. 找到调用 *对象* 的 *实际类型* 并判断是否存在相应的方法
   2. 不存在就到 *实际类型* 的 *父类* 上找

   这就是为什么，子类重写父类方法后，通过父类引用能够正确调用子类方法的原因。

* 程序编译与代码优化
  Java 中的编译期可能指：
  1. 前端编译器，把 =*.java= 文件转变成 =*.class= 文件
  2. 后端运行期编译器 JIT，把字节码转变为本地机器代码
  3. 静态提前编译器 AOT，直接把 =*.java= 文件编译为本地机器代码

  javac 就是一个通过 Java 语言编写的前端编译器，在源码编译的过程中，它会做的一些事：
  1. 常量折叠，将诸如 =int a = 1 + 1= 形式的代码中的常量运算结果算出，简化为 =int a = 2=
  2. 数据流分析，比如说 =final= 局部变量的检查便在编译期完成，因为局部变量在常量池中是不存在 =CONSTANT_Fieldref_info= 引用的，自然就没有访问标志
  3. 字节码生成，包括 =<init>= 和 =<clinit>= 方法的生成，对于 =<clinit>= 来说，会根据类变量和静态代码块的顺序生成，而 =<init>= 则会按照调用父类 =<init>= 方法，
     初始化字段、初始化代码块、构造方法代码的方式组织

     类初始化过程：
     1. 加载类并在准备阶段将静态字段的值设为零值或常量
     2. 在初始化阶段调用类的 =<clinit>= 方法，执行相关逻辑并初始化其他类变量

     对象初始化过程：
     1. 创建对象实例，并将对象内存区域置为 0 值
     2. 调用 =<init>= 方法，内部顺序为：调用父类 =<init>= 方法 -> 初始化实例字段 -> 执行初始化代码块 -> 执行对于构造方法内部逻辑
  
* Footnotes

[fn:1] [[https://juejin.im/post/5b1560afe51d4506a74d2aeb][栈帧(Stack Frame) - 掘金]] 

