#+TITLE:      Java 虚拟机结构

* 目录                                                    :TOC_4_gh:noexport:
- [[#运行时数据区域][运行时数据区域]]
- [[#对象的创建和内存布局][对象的创建和内存布局]]
- [[#垃圾回收][垃圾回收]]
- [[#类文件结构][类文件结构]]
- [[#字节码指令][字节码指令]]
- [[#类加载机制][类加载机制]]
  - [[#类加载器][类加载器]]
  - [[#相关问题][相关问题]]
- [[#字节码执行引擎][字节码执行引擎]]
  - [[#解析][解析]]
  - [[#分派][分派]]
- [[#程序编译与代码优化][程序编译与代码优化]]
- [[#内存模型和线程][内存模型和线程]]
  - [[#内存模型][内存模型]]
  - [[#线程][线程]]
- [[#锁优化][锁优化]]
  - [[#偏向锁轻量级锁和重量级锁][偏向锁、轻量级锁和重量级锁]]
- [[#footnotes][Footnotes]]

* 运行时数据区域
  Java 虚拟机的运行时数据区分为：
  1. 程序计数器 PC，是一块较小的内存空间，可以看做是当前线程所指向的字节码的行号指示器，各线程的程序计数器互不影响
  2. Java 虚拟机栈，线程私有，保存方法执行时需要的数据，可能抛出 StackOverflowError 和 OutOfMemoryError 异常
  3. 本地方法栈，和虚拟机栈类似，为 native 方法服务，可能抛出 StackOverflowError 和 OutOfMemoryError 异常
  4. Java 堆，被所有线程共享的内存区域，用于存放所有的对象实例，可能抛出 OutOfMemoryError 异常
  5. 方法区，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态常量等数据，可能抛出 OutOfMemoryError 异常
  6. 运行时常量池，是方法区的一部分，用于存放编译器生成的各种字面量和符号引用，也可以在运行期间将新的常量放入

  其中，程序计数器、虚拟机栈和本地方法栈都是线程独立的，而方法区和堆被所有线程共享。

  另外，需要注意区分 Class 文件常量池和运行时常量池，Class 文件常量池中的内容会在加载时自动放入运行时常量池，但同时也可以在运行期间将常量放入运行时常量池。

* 对象的创建和内存布局
  通过 =new= 指令创建对象的流程为：
  1. 检查这个指令的参数能否在常量池中定位到一个类的符号引用
  2. 检查这个符号引用代表的类是否已被加载、解析和初始化过
  3. 如果没有，就必须先执行类加载过程
  4. 在类加载检查通过后，虚拟机便可以为新对象分配内存
  5. 内存分配完后，需要将分配到的内存空间都初始化为零值（不包括对象头），这一步保证了实例字段即使不赋值也可以直接使用
  6. 对对象进行必要的设置，例如这个对象是哪个类的实例、如何找到类的元数据信息、对象的哈希码等信息，这些信息存放在对象头（Object Header）中
  7. 一般来说，在前面的步骤完成后还会执行 =<init>= 方法，由字节码中是否跟随 =invokespecail= 指令决定
  
  其中，在分配内存时可以选择的策略有：
  1. 指针碰撞，内存空间规整，直接一段指针分配内存就可以了
  2. 空闲列表，内存空间不规整，虚拟机需要维护一个列表，记录哪些内存块时可用的，在分配的时候在列表中找到足够大的空间划分给对象实例，并更新列表记录

  另外，由于对象创建十分频繁的行为，为了避免出现正在给对象 A 分配内存，指针还没来得及修改，对象 B 有同时使用了原来的指针分配内存的情况，虚拟机有两种解决方案：
  1. 对分配内存空间的动作进行同步处理，保证原子性
  2. 把内存分配的动作按照线程划分到不同的空间进行，即每个线程在 Java 堆中预分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）。
     现在 TLAB 上分配内存，不够时才同步分配新的 TLAB。

     对象创建的第 5 步其实就可以提前到 TLAB 阶段完成。

  对象在内存中主要包含两个部分：
  1. 对象头，包含两个部分，一部分用于存储对象自身的运行时数据，如哈希码、锁状态标志、线程持有的锁等。另一部分是类型指针，用于执行对象类元数据的指针，但不是所有虚拟机实现都有。

     因为对象的访问定位可以由两种形式：
     1. 使用句柄，在堆中划分一块内存作为句柄池，引用中保存的就是对象的句柄地址，而句柄中包含 *对象实例数据* 和 *类型数据* 各自的地址信息
     2. 使用直接指针访问，这时对象头中就需要类型指针了
        
     同时，假如对象是数组，那么对象头还需要保证数组的大小信息。
     
  2. 实例数据，主要就是各个实例字段数据，通常相同宽度的字段会被放在一起
  
  除了对象头和实例数据以外，可能还要对齐填充，保证对象的大小是 8 的整数倍。

* 垃圾回收
  Java 中通过（根）可达性分析算法来判定对象是否存活，在 Java 语言中，可作为 GC Roots 的对象有：
  1. 虚拟机栈中引用的对象
  2. 方法区中类静态属性引用的对象
  3. 方法区中常量引用的对象
  4. 本地方法栈中引用的对象

  堆中对象的死活判定比较方便，而方法区中的常量也很容易判断死活，相对麻烦的是类，满足以下条件的类才是无用的类：
  1. 该类的所有实例都已被回收
  2. 加载该类的 ClassLoader 已经被回收
  3. 该类对应的 Class 对象没有在任何地方被引用

  在知道怎么判断一个对象的死活后，剩下的就是如何回收内存了，主要有三种算法：
  1. 标记清除算法，首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，主要问题是效率低，同时会产生大量不连续的内存碎片
  2. 复制算法，将内存分配为多个区域，每次只使用其中一部分内存，回收时将存活对象复制到空闲内存，主要问题是会造成内存空间的浪费，内存不足时还需要依赖其他内存进行分配担保
  3. 标记整理算法，算法过程和标记清除算法类似，区别在于清理时是将存活对象往内存的一端移动

  根据对象存活的周期不同，虚拟机往往采用分代收集算法来同时使用多个算法，比如将内存分为新生代和老年代，在新生代采用复制算法，在老年代采用标记清除或标记整理算法

  实现这些回收策略的垃圾收集器：
  |-------------------+--------------------------------------------+------------+--------------|
  | 垃圾收集器        | 特点                                       | 新生代算法 | 老年代算法   |
  |-------------------+--------------------------------------------+------------+--------------|
  | Serial            | 单线程，GC 时阻塞所有工作现场              | 复制算法   |              |
  | ParNew            | 多线程，GC 时阻塞所有工作现场              | 复制算法   |              |
  | Parallel Scavenge | 可以通过控制收集评率达到一个可控制的吞吐量 |            |              |
  | Serial Old        | Serial 的老年代版本                        |            | 标记整理算法 |
  | ParNew Old        | ParNew 的老年代版本                        |            | 标记整理算法 |
  | ……                |                                            |            |              |
  |-------------------+--------------------------------------------+------------+--------------|

  因为对内存区域进行了划分，因此 GC 方法也可以分为 Minor GC（新生代 GC）和 Full GC，通常，现在一些优秀的垃圾回收器可以在不阻塞工作线程的情况下进行 GC，
  但是 Full GC 的时候，往往就避免不了要停顿工作线程了。

  参考：
  + [[https://zhuanlan.zhihu.com/p/58896728][7 种 JVM 垃圾收集器特点，优劣势、及使用场景 - 知乎]]
  + [[https://crowhawk.github.io/2017/08/15/jvm_3/][深入理解 JVM(3)——7 种垃圾收集器 - 王泽远的博客 | Crow's Blog]]

* 类文件结构
  Java 虚拟机类文件中采用类似 C 语言结构体的伪结构来存储数据，这种结构只有两种数据类型：无符号数和表，其中，无符号数采用大端形式存储：
  |----------------+---------------------+-------------------------+--------------------|
  | 类型           | 名称                |                    数量 | 含义               |
  |----------------+---------------------+-------------------------+--------------------|
  | u4             | magic               |                       1 | Magic Number       |
  |----------------+---------------------+-------------------------+--------------------|
  | u2             | minor_version       |                       1 | 次版本号           |
  | u2             | major_version       |                       1 | 主版本号           |
  |----------------+---------------------+-------------------------+--------------------|
  | u2             | constant_pool_count |                       1 | 常量池大小         |
  | cp_info        | constant_pool       | constant_pool_count - 1 | 常量信息表         |
  |----------------+---------------------+-------------------------+--------------------|
  | u2             | acess_flags         |                       1 | 访问标志           |
  | u2             | this_class          |                       1 | 当前类全限定名索引 |
  | u2             | super_class         |                       1 | 父类全限定名索引   |
  | u2             | interfaces_count    |                       1 | 实现接口数量       |
  | u2             | interfaces          |        interfaces_count | 接口全限定名索引   |
  |----------------+---------------------+-------------------------+--------------------|
  | u2             | fields_count        |                       1 | 字段信息表数量     |
  | field_info     | fields              |            fields_count | 字段信息表         |
  |----------------+---------------------+-------------------------+--------------------|
  | u2             | methods_count       |                       1 | 方法信息表数量     |
  | method_info    | methods             |           methods_count | 方法信息表         |
  |----------------+---------------------+-------------------------+--------------------|
  | u2             | attributes_count    |                       1 | 类额外属性数量     |
  | attribute_info | attributes          |        attributes_count | 类额外属性表       |
  |----------------+---------------------+-------------------------+--------------------|

  除了类文件以外，字段信息表和方法信息表都可以有自己的属性表，各表主体信息只保存一些相对固定的数据，比如访问表示、限定名称索引等，
  而其他属性，如方法字节码、行号等就保存在对应的属性表中。

  整体来看，类文件的格式和网络协议相似，类似于 TLV 格式，可以通过 ~javap -v~ 选项来查看对应信息。

  方法和字段描述符格式：
  1. 类型的表示方式通过标识字符和限定名组成：
     |----------+--------+----------+--------------------------------|
     | 标识字符 | 含义   | 标识字符 | 含义                           |
     |----------+--------+----------+--------------------------------|
     | B        | byte   | J        | long                           |
     | C        | char   | S        | short                          |
     | D        | double | Z        | boolean                        |
     | F        | float  | V        | void                           |
     | I        | int    | L        | 对象类型，如 Ljava/lang/Object |
     |----------+--------+----------+--------------------------------|
  2. 对于数组类型，每一维度使用一个前置的 ~[~ 字符描述，因此 ~String[][]~ 的描述符就为 ~[[Ljava/lang/String~
  3. 方法描述符的格式为 ~(参数描述符...)返回值描述符~, 比如 ~void method(int a, String b)~ 的描述符就为 ~(ILjava/lang/String)V~
  4. 描述符结尾往往还会有一个分号，比如 ~(II)I;~

  需要注意的是，方法描述符包括返回值，但是方法签名是不包括的。

  Tips:
  1. 类文件中保存的只是符号引用，而符号引用对其他类的引用只是一个描述符，因此，在加载类的时候，可以通过修改描述符达到引用其他类的目的，毕竟，
     字节码中指令参数也是常量池中的符号引用，不需要去修改字节码

* 字节码指令
  Java 虚拟机采用面向操作数栈的架构，指令由单字节的操作码和跟随之后的零个或多个操作数构成。

  针对不同的类型，虚拟机可能提供了相同操作码的不同特化，这些操作码可以通过操作码助记符区分：
  + i - int、l - long、s - short、b - byte、c - char、f - float、d - double、a - reference

  这里可以看出来，能够存储在栈中的数据除了基本数据类型以外就是引用了。

  编译器会在编译期货运行期将 byte 和 short 类型数据符号扩展为相应的 int 类型数据，将 boolean 和 char 类型无符号扩展为相应的 int 类型数据，
  从而复用 int 类型的操作码，避免重复定义太多指令。

  相对特殊的是同步指令，分为两种情况：
  1. 方法级别的同步，无需字节码指令实现，当虚拟机发现 ACC_SYNCHRONIZED 标志为 true 时便会自动加锁
  2. 代码块的同步，通过 ~monitorenter~ 和 ~monitorexit~ 指令完成，编译器会保证只要调用过 ~monitorenter~ 就一定会调用 ~monitorexit~

     比如生成一个异常处理器，即使同步代码块中抛出了异常也会执行 ~monitorexit~ 指令

* 类加载机制
  Java 虚拟机中，类型的加载、连接和初始化都是在程序运行期间完成的，整个生命周期大致可以分为：加载、验证、准备、解析、初始化、使用和卸载七个阶段，
  其中，验证、准备和解析三个阶段被称为连接。

  各阶段的操作：
  1. 加载，通过类的全限定名来获取定义此类的二进制字节流，将这个字节流代表的静态文件存储结构转化保存到方法区，并在内存中生成相应的 =Class= 对象
  2. 验证，对文件格式、元数据（类型语义，如继承、实现接口、抽象方法的实现等）、字节码和符号引用（引用的符号是否存在、能否访问）进行验证
  3. 准备，为类变量（不是实例变量）分配内存并设置初始值，通常为零值，但假如字段属性表中存在 =ConstantValue= 属性，那么准备阶段就可以完成赋值，通常为基本类型或字符串
  4. 解析，将符号引用转换为直接引用的过程，主要包括类、接口、字段、类方法、接口方法、方法类型、方法句柄、调用限定符的解析

     注意：字段解析会先根据类名称寻找字段，找不到的时候回到父接口和父类中去找，这就使得：
     + 当子类和父类存在同名字段时，用哪个类名获取就是哪个类的
     + 父类和父接口存在同名字段时，父接口优先级更高，但是编译器往往会在存在同名字段时报错

     解析成功后，还会对符号进行 *符号引用验证*
  5. 初始化，执行类或接口的 =<clinit>= 方法，会先执行父类的 =<clinit>= 方法，但是不会执行父接口的，另外，该方法的执行是同步的，这意味执行时阻塞可能导致其他线程阻塞

     问：为什么接口也有 =<clinit>= 方法？
     答：应该是为了初始化接口字段的值，当字段类型为除了 =String= 以为的对象时，就只能在 =<clinit>= 方法中初始化了

     问：为什么不需要先执行接口的 ~<clinit>~ 方法？
     答：接口中的属性都是 ~static final~ 类型的常量，因此在 *准备阶段* 就已经初始化

     另外，方法 =<init>= 和方法 =<clinit>= 分别为实例和类的初始化服务。

  对于类的初始化来说，只有满足以下五个情况之一时才会对类进行初始化：
  1. 遇到 new、getstatic、putstatic 或 invokestatic 四个指令时，即：使用 new 关键字实例化对象时、获取或设置一个类的静态字段（被 final 修饰、已在编译器把结果放入常量池的静态字段除外）、
     调用类的静态方法时。这里需要注意字段被 final 修饰或已在编译器把结果放入常量池的情况（基本类型和字符串），这时，它们的值在准备阶段就已经准备好了，不需要对类进行初始化。
  2. 对类进行反射调用的时候
  3. 初始化一个类的时候，其父类还没有初始化，那么就会先进行父类的初始化，注意，没有父接口
  4. 加载执行主类的时候回初始化主类
  5. 使用动态语言支持对应的方法句柄没有初始化时

** 类加载器
   Java 虚拟机中每个类由 *类* 本身和它的 *类加载器* 唯一确定，类一样但是类加载器不一样，那么也不是同一个类。

   对于 Java 虚拟机来说，只存在两种类加载器，分别为：
   + 启动类加载器 - BootstrapClassLoader，是虚拟机的一部分，无法被用户获取
   + 其他类加载器，由 Java 语言实现，独立于虚拟机，都继承自抽象类 =ClassLoader=

   对于开发人员来说，系统提供的类加载器又可以分为三类：
   1. 启动类加载器 - BootstrapClassLoader，用于加载 =<JAVA_HOME>/lib= 目录下的类，通过名称进行识别，不符合的名称不会进行加载
   2. 扩展类加载器 - ExtensionClassLoader，用于加载 =<JAVA_HOME>/lib/ext= 目录下的类，同样通过名称进行识别，父类加载器为 null(BootstrapClassLoader)，可以被用户获取
   3. 应用程序类加载器 - ApplicationClassLoader，用于加载用户类路径上的类，也被成为系统类加载器，父类加载器为 ExtensionClassLoader

   详情可以查看 ~sun.misc.Launcher~ 这个类的源码。

   类加载器之间的关系通常满足双亲委派模型，每个类加载器都通过组合关系持有它的父类加载器，加载类时，先用父类加载器尝试加载，加载不了才使用子类加载器。
   这保证了 JDK 中类的优先级。

   基本逻辑为：
   #+begin_src java
     protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
       synchronized (getClassLoadingLock(name)) {
         // 首先检查是否已经加载了
         Class<?> c = findLoadedClass(name);
         if (c == null) {
           try {
             if (parent != null) {
               c = parent.loadClass(name, false);
             } else {
               // 父类加载器不存在时就使用 BootstrapClassLoader
               c = findBootstrapClassOrNull(name);
             }
           } catch (ClassNotFoundException e) {
             // ClassNotFoundException thrown if class not found
             // from the non-null parent class loader
           }

           if (c == null) {
             // 父类加载器加载失败，调用自己的加载方法
             c = findClass(name);
           }
         }
         if (resolve) {
           // 执行连接操作
           resolveClass(c);
         }
         return c;
       }
     }
   #+end_src
   
   在这种结构性，定义自己的类加载往往只需要定义 ~findClass~ 方法就足够了。

** 相关问题
   + 为什么说 SPI 打破双亲委派机制？

     SPI 机制中，在为指定类加载时会使用 =Thread.currentThread().getContextClassLoader()= 中的类加载器，如果不用的话就可能会出现如下情况：
     1. 从 META-INF/services/java.sql.Driver 文件得到实现类名字 DriverA
     2. Class.forName("xx.xx.DriverA") 来加载实现类
     3. Class.forName() 方法默认使用当前类的 ClassLoader，JDBC是 在 DriverManager 类里调用 Driver 的，当前类也就是 DriverManager，
        它的加载器是 BootstrapClassLoader
     4. 用 BootstrapClassLoader 去加载非 rt.jar 包里的类 xx.xx.DriverA，就会找不到
     5. 要加载 xx.xx.DriverA 就需要用到 AppClassLoader 或其他自定义 ClassLoader
     6. 最终矛盾出现在，要在 BootstrapClassLoader 加载的类里，调用 AppClassLoader 去加载实现类

     虽然实现细节上存在区别，但大致逻辑就是这么个逻辑，用那个类加载器加载一个类，那么那个类的类加载器就是加载它的类加载器。也就是说，
     我们的程序运行时，存在拥有不同类加载器的类。

* 字节码执行引擎
  栈帧时用于支持虚拟机进行方法调用和方法执行的虚拟结构，每个栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。

  位于栈顶的栈帧称为当前栈帧，对应的方法称为当前方法，通过 =Throwable.printStackTrace= 打印出的内容在一定程度上反应了栈帧结构。
  
  #+begin_quote
  这里应该注意区分栈帧和栈的概念，栈不用多说，但是栈帧通常指代的是函数调用过程中，在栈上维护的一个独立的区域，保存函数调用需要的信息[fn:1]。
  #+end_quote

  栈帧位于虚拟机栈中，各部分的数据结构和作用为：
  1. 局部变量表，用于存放方法参数和方法内部定义的局部变量，容量以变量槽为最小单位，对于实例方法来说，局部变量表中的第一个变量往往为 =this= 引用。

     另外，因为局部变量表 Slot 复用的原因，可能导致局部变量即使离开了其作用域，但是 Slot 中依然存在相应的引用使得其无法被回收。

  2. 操作数栈，栈容量的单位是 32 位，对于基于栈的指令架构来说，优势是可移植，缺陷是由于频繁的出入栈而额外的操作，执行速度会变慢

  3. 动态连接，每个栈帧都包含一个执行运行时常量池中该栈帧所属方法的引用，用于支持方法调用过程中的动态连接（每次运行期间将符号引用转化为直接引用）

  4. 方法返回地址

  字节码执行引擎这一部分中一项重要的内容就是方法调用的过程，主要可以分为解析和分派两类。

** 解析
   对于能够在编译器就能够确定下来的方法调用类型被称为解析，符合这一要求的方法类型有：静态方法、私有方法、实例构造器、父类方法和被 =final= 修饰的方法，
   这些方法被叫做非虚方法，主要通过 =invokestatic= 和 =invokespecail= 指令调用。

   而 =final= 方法虽然需要通过 =invokevirtual= 指令调用，但是它还是可以通过解析的方式调用。

** 分派
   分派中的两种主要分派方式为静态分派和动态分派，其中，静态分派时重载机制实现的基础，而动态分派则是重写机制实现的基础。

   对于如下语句来说，我们将 =Human= 称为 =man= 的静态类型，而将 =Man= 称为 =man= 的实际类型：
   #+begin_src java
     Human man = new Man();
   #+end_src
   
   静态类型仅在使用时发生变化，而实际类型却需要在运行期间确定：
   #+begin_src java
     // 实际类型变化
     Human man = new Man();
     man = new Woman();

     // 静态类型变化
     sr.sayHello((Man) man);
     sr.sayHello((Woman) man);
   #+end_src

   使用方法的那个重载版本有传入参数的数量和 *静态类型* 确定，整个过程在编译期完成，需要注意的是字面量的类型推导过程，当不存在和字面量直接匹配的重载时会历经如下步骤：
   #+begin_example
     自动类型转换(char -> int -> long -> float -> double) -> 自动装箱 -> 尝试匹配实现的接口 -> 父类 -> 变长参数
   #+end_example

   而动态分派对于的便是重写了，通常由 =invokevirtual= 指令调用，运行时解析过程大致为：
   1. 找到调用 *对象* 的 *实际类型* 并判断是否存在相应的方法
   2. 不存在就到 *实际类型* 的 *父类* 上找

   这就是为什么，子类重写父类方法后，通过父类引用能够正确调用子类方法的原因。

* 程序编译与代码优化
  Java 中的编译期可能指：
  1. 前端编译器，把 =*.java= 文件转变成 =*.class= 文件
  2. 后端运行期编译器 JIT，把字节码转变为本地机器代码
  3. 静态提前编译器 AOT，直接把 =*.java= 文件编译为本地机器代码

  javac 就是一个通过 Java 语言编写的前端编译器，在源码编译的过程中，它会做的一些事：
  1. 常量折叠，将诸如 =int a = 1 + 1= 形式的代码中的常量运算结果算出，简化为 =int a = 2=
  2. 数据流分析，比如说 =final= 局部变量的检查便在编译期完成，因为局部变量在常量池中是不存在 =CONSTANT_Fieldref_info= 引用的，自然就没有访问标志
  3. 字节码生成，包括 =<init>= 和 =<clinit>= 方法的生成，对于 =<clinit>= 来说，会根据类变量和静态代码块的顺序生成，而 =<init>= 则会按照调用父类 =<init>= 方法，
     初始化字段、初始化代码块、构造方法代码的方式组织

     类初始化过程：
     1. 加载类并在准备阶段将静态字段的值设为零值或常量
     2. 在初始化阶段调用类的 =<clinit>= 方法，执行相关逻辑并初始化其他类变量

     对象初始化过程：
     1. 创建对象实例，并将对象内存区域置为 0 值
     2. 调用 =<init>= 方法，内部顺序为：调用父类 =<init>= 方法 -> 初始化实例字段 -> 执行初始化代码块 -> 执行对于构造方法内部逻辑

* 内存模型和线程
** 内存模型
   Java 内存模型 JMM 中每个线程都拥有自己的工作内存，每个线程对变量（不包括局部变量）的操作都必须在工作内存中进行，同时和主内存保持同步。

   #+HTML: <img src="https://img-blog.csdn.net/20170608221857890?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==">

   工作内存和主内存之间的原子操作有：
   |-------------+--------------------------------------------|
   | 操作        | 作用                                       |
   |-------------+--------------------------------------------|
   | 锁定 lock   | 将主内存中的一个变量标识为线程独占的状态   |
   | 解锁 unlock | 将处于锁定状态的变量解锁                   |
   | 读取 read   | 读取主内存中的变量到工作内存中             |
   | 载入 load   | 将读取得到的变量值放入工作内存的变量副本中 |
   | 使用 use    | 将工作内存中的变量值传递给执行引擎         |
   | 赋值 assign | 将执行引擎接受到的值赋给工作内存中的变量   |
   | 存储 store  | 将工作内存中的变量传送主内存               |
   | 写入 write  | 将存储的变量值写入主内存的变量中           |
   |-------------+--------------------------------------------|

   PS：工作内存和主内存之间的值传递居然需要两个不一定连续的操作完成。

   这些操作会满足的一些规则：
   + 新的变量只会在主内存中诞生
   + 执行 lock 操作时会情况工作内存中该变量的值
   + 执行 unlock 操作前需要先把变量的值同步回主内存

   而通过 =volatile= 关键字修饰的变量还可以保证：
   1. 每次使用一个变量的值时，都必须先从主内存刷新最新的值
   2. 每次修改一个变量的值后，都必须立刻同步回主内存中
   3. 被 =volatile= 修饰的变量不会被指令重排序优化（JDK 1.5+）

** 线程
   抛开 Java 来看，线程的实现方式大致有三种：
   1. 内核线程 KLT，直接由操作系统实现，程序通常不会直接使用内核线程，而是使用内核线程的高级接口轻量级进程 LWP，轻量级进程和内核线程之间是 1:1 的关系
      + 优势：有内核调度器的支持，每个轻量级进程都可以时单独的调度单元，单个轻量级进程阻塞不会影响整个进程
      + 缺陷：各种线程操作都需要进行系统调用，代价相对较高，同时需要消耗内核资源，使得系统支持的轻量级进程数量有限
   2. 用户线程 UT，用户线程的建立、同步、消耗和调度操作完全在用户态中完成，不需要内核的帮助，进程和线程之间是 1:N 的关系
      + 优势：不需要内核的帮助，消耗的资源少
      + 缺陷：没有内核的帮助，什么都要自己搞定，实现太复杂
   3. 用户线程加轻量级进程混合实现，进程和线程之间是 N:M 的关系
  
  目前 Java 中线程的实现方式是基于操作系统原生线程模型类实现的，在 Windows 和 Linux 中一般就是内核线程了。
  
  Java 中为线程定义了五种状态：
  + 新建 New，创建后尚未启动的线程
  + 运行 Runable，包括了操作系统线程状态中的 Running 和 Ready
  + 等待 Waiting，分为无限期等待和限期等待两种
  + 阻塞 Blocked，和等待的区别在于阻塞状态是在等待着获取到一个排它锁
  + 结束 Terminated，线程已结束执行

  线程调度的方式为抢占式线程调度，每个线程由系统来分配执行时间，可以通过设置线程的优先级来影响调度，但不一定有效。

* 锁优化
  简单的锁优化方式：
  + 自旋锁与自适应循环：互斥同步对性能最大的影响时阻塞的实现，挂起和恢复线程都需要切换到内核态完成，而代码块实际的阻塞时间往往又很短，
    因此可以通过让线程执行一个忙循环的方式代理阻塞等待。超过一定循环次数再去获取锁。
  + 锁消除：一些代码不可能会发生共享数据的竞争，因此可以将锁去除，例如只存在于函数内部的 =StringBuffer=
  + 锁粗化：如果在局部频繁对同一个对象加锁解锁也会带来额外的消耗，因此可以通过锁粗化扩大锁定范围

** 偏向锁、轻量级锁和重量级锁
   偏向锁、轻量级锁和重量级锁分别适用于只有一个线程进入临界区、多个线程交替进入临界区和多个线程同时进入临界区的场景，其中偏向锁和轻量级锁为乐观锁，而重量级锁为悲观锁。
   
   一个对象刚开始实例化的时候，没有任何线程来访问它的时候。它是可偏向的，意味着，它现在认为只可能有一个线程来访问它，所以当第一个线程来访问它的时候，它会偏向这个线程，此时，对象持有偏向锁。
   偏向第一个线程，这个线程在修改对象头成为偏向锁的时候使用 CAS 操作，并将对象头中的 ThreadID 改成自己的 ID，之后再次访问这个对象时，只需要对比 ID，不需要在使用 CAS 进行操作。

   一旦有第二个线程访问这个对象，因为偏向锁不会主动释放，所以第二个线程可以看到对象时偏向状态，这时表明在这个对象上已经存在竞争了，检查原来持有该对象锁的线程是否依然存活，如果挂了，则可以将对象变为无锁状态，
   然后重新偏向新的线程，如果原来的线程依然存活，则马上执行那个线程的操作栈，检查该对象的使用情况，如果仍然需要持有偏向锁，则偏向锁升级为轻量级锁，（偏向锁就是这个时候升级为轻量级锁的）。
   如果不存在使用了，则可以将对象回复成无锁状态，然后重新偏向。

   轻量级锁认为竞争存在，但是竞争的程度很轻，一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。 但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，
   轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止 CPU 空转。

   #+HTML: <img src="https://pic1.zhimg.com/80/v2-bddd3f3f9f0b74866badc777e3e4dea5_hd.jpg">

   1. 对于偏向锁来说，当前线程只有第一次 *加锁* 的时候需要 =CAS= 操作设置对象头，同时不需要撤销
   2. 对于轻量级锁来说，当前线程在 *加锁* 和 *解锁* 的时候都需要通过 =CAS= 操作设置还原对象头，操作量相较于偏向锁多了一下，但依然比重量级锁少
   3. 对于重量级锁来说，就很直接了，直接阻塞其他线程

   从偏向锁升级到轻量级锁，在从轻量级锁升级到重量级锁，中间的关键操作时 =CAS= 操作是否可以成功。

   参考：
   + [[https://www.zhihu.com/question/53826114][java 偏向锁，轻量级锁与重量级锁为什么会相互膨胀? - 知乎]]
   + [[https://rgb-24bit.github.io/blog/2020/java-synchronized.html][Java 偏向锁、轻量级锁和重量级锁]]

* Footnotes

[fn:1] [[https://juejin.im/post/5b1560afe51d4506a74d2aeb][栈帧(Stack Frame) - 掘金]] 

