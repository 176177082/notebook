#+TITLE:      Java Annotations

* 目录                                                    :TOC_4_gh:noexport:
- [[#基本的使用][基本的使用]]
- [[#retentionpolicy][RetentionPolicy]]
- [[#通过反射获取][通过反射获取]]

* 基本的使用
  定义注解类的方式：
  #+BEGIN_SRC java
    @interface ClassPreamble {
      String author();
      String date();
      int currentRevision() default 1;
      String lastModified() default "N/A";
      String lastModifiedBy() default "N/A";
      // Note use of array
      String[] reviewers();
    }
  #+END_SRC

  使用注解类的方式：
  #+BEGIN_SRC java
    @ClassPreamble (
        author = "John Doe",
        date = "3/17/2002",
        currentRevision = 6,
        lastModified = "4/12/2004",
        lastModifiedBy = "Jane Doe",
        // Note array notation
        reviewers = {"Alice", "Bob", "Cindy"}
    )
    public class Generation3List extends Generation2List {
      // class code goes here
    }
  #+END_SRC

  对定义自己的注解类很有帮助的包： [[https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/package-summary.html][java.lang.annotation]]

  + [[https://docs.oracle.com/javase/tutorial/java/annotations/index.html][Lesson: Annotations (The Java™ Tutorials > Learning the Java Language)]]

* RetentionPolicy
  RetentionPolicy 共定义了三种反射策略：
  + CLASS - 注解由编译器记录在类文件中，但 VM 在运行时无需保留
  + RUNTIME - 注解由编译器记录在类文件中，并在运行时由 VM 保留，因此可以通过反射方式读取它们
  + SOURCE - 注解被编译器丢弃

  因此，只有反射策略为 RUNTIME 的才能通过反射的方式读取。

* 通过反射获取
  Spring 用多了给了我一种 Java 默认支持组合注解的错觉，看了源码后才发现，Spring 解析注解时会不断解析注解上的注解。

  而在实际的使用中，通过 ~Class.getAnnotation~ 方法只能获取到指定类型的注解，如果该注解被定义为 ~@Inherited~ 的，那么，还会寻找该类的父类。

  但是，不会自动的寻找注解上的注解。

