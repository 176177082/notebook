#+TITLE:      Java 基础笔记

* 目录                                                    :TOC_4_gh:noexport:
- [[#primitive-types][Primitive Types]]
  - [[#取值范围][取值范围]]
  - [[#自动装箱][自动装箱]]
  - [[#boolean][boolean]]
- [[#类型转换][类型转换]]
- [[#数组][数组]]
  - [[#数组的类型判断][数组的类型判断]]
- [[#异常][异常]]
- [[#java-import][Java Import]]
  - [[#导入名称][导入名称]]
  - [[#static-import][static import]]
- [[#块作用域][块作用域]]
- [[#注意事项][注意事项]]

* Primitive Types
** 取值范围
   |---------+-----------------+--------------------------|
   | 类型    |            位数 | 值域                     |
   |---------+-----------------+--------------------------|
   | boolean | Java 虚拟机决定 | true or false            |
   | char    |              16 | 0 ~ 65535                |
   | byte    |               8 | -128 ~ 127               |
   | short   |              16 | -32768 ~ 32767           |
   | int     |              32 | -2147483648 ~ 2147483647 |
   | long    |              64 | -很大 ~ +很大            |
   | float   |              32 | 范围规模可变             |
   | double  |              64 | 范围规模可变             |
   |---------+-----------------+--------------------------|

** 自动装箱
   ~primitive~ 主数据类型都有对应的 *包装类*.

   |----------------------+--------------|
   | primitive 主数据类型 | 对应的包装类 |
   |----------------------+--------------|
   | boolean              | Boolean      |
   | char                 | Character    |
   | byte                 | Byte         |
   | short                | Short        |
   | int                  | Integer      |
   | long                 | Long         |
   | float                | Float        |
   | double               | Double       |
   |----------------------+--------------|

   在 ~java 5.0~ 之后的 ~java~ 中， 添加了 ~autoboxing~ 的功能， 允许在一些
   地方自动的完成 primitive 主数据类型和包装的对象的转换。

   这也叫做装箱和拆箱：
   + 装箱 -> primitive 主数据类型转换为对应的包装对象
   + 拆箱 -> 将包装对象转换为对应的 primitive 主数据类型

   可以使用 autoboxing 的地方包括：
   1. 方法的参数
   2. 返回值
   3. boolean 表达式， 任何预期 boolean 值的地方都可以用求 boolean 的表达式代替
   4. 数值运算
   5. 赋值

   #+BEGIN_SRC java
     public class Autoboxing {
       public Integer auto(Integer num) {  // 参数可以为 int 或 Integer
         int n = num;  // int 和 Integer 间可以直接赋值
         num += n;  // int 和 Integer 间可以直接加减
         return n;  // 返回值类型可以为 int 或 Integer
       }
     }
   #+END_SRC

   通过包装类可以调用有用的静态方法。

** boolean
   Java 作为强类型语言，需要布尔值的地方就只能使用 boolean 类型的值，
   布尔表达式可以自动转换为布尔值。

   在判断两个对象时：
   #+BEGIN_SRC java
     a == b;       // 判断 a 和 b 是否为同一个对象
     a.equals(b);  // 判断 a 和 b 的值是否相等
   #+END_SRC

* 类型转换
  由与所有的非 ~Object~ 对象都继承了 ~Object~, 因此这些对象在 *堆* 上的实例上， 内部
  也包括了一个 ~Object~ 实例。

  即： 后代的实例内部包含父类的实例。

  因此父类类型的引用相当于只能操作子类实例内部的父类实例。

  通过强制类型转换可以将父类引用转换为子类引用， 转换前可以使用关键字 ~instanceof~ 来判断该对象是否是对应类型的实例。

  #+BEGIN_SRC java
    if (obj instanceof Dog) {
      Dog d = (Dog)obj;
    }
  #+END_SRC

  如果类型转换失败会抛出 ~ClassCastException~ 异常。
  
  *向上向下转型：*

  #+BEGIN_SRC java
    // 向上转型
    SuperClass ref = new SubClass();

    // 向下转型
    SubClass ref = (SubClass) SuperClassRef;
  #+END_SRC

* 数组
  数组的声明和初始化方式：
  #+BEGIN_SRC java
    // 声明数组
    dataType[] arrayRefVar;   // 首选的方法

    dataType arrayRefVar[];  // 效果相同，但不是首选方法

    // 创建数组
    dataType[] arrayRefVar = new dataType[arraySize];

    dataType[] arrayRefVar = {value0, value1, ..., valuek};  // 只能在声明的同时使用

    dataType[] arrayRefVar = new dataType[]{value0, value1, ..., valuek};
  #+END_SRC

  数组的 *成员* 包括：
  1. ~public final length~
  2. ~public T[] clone()~
  3. ~Object method~

** 数组的类型判断
   #+BEGIN_QUOTE
   Primitive arrays are instance of Object and self type. e.g. int[] is type of Object and int[]. Both comparison returns true.

   Object arrays are types of Object, Object array, classtype array, parent class type array.
   e.g. Integer[] is type of Object, Object[], Integer[] and Number[] (Integer extends Number).
   #+END_QUOTE

   + [[https://howtodoinjava.com/oops/java-instanceof/][Java instanceof - Java type comparison operator - HowToDoInJava]]

   特别的， int[][] 是 Object[] 的实例。

   这也就是为什么 ~asList~ 不要使用 ~int[]~ 参数的原因。

* 异常
  + 捕获异常：
    #+BEGIN_SRC java
      try {
        // 可能会抛出异常的代码块
      } catch(Exception ex) {
        // 捕获异常后执行的代码块
      }
    #+END_SRC
  + 抛出异常：
    #+BEGIN_SRC java
      public int function() throws Exception {  // 声明可能抛出的异常
        throw new Exception();  // 抛出异常
      }
    #+END_SRC

  Java 中的所有异常是 ~Exception~ 类型的 *对象*.

  异常分为： 检查型异常和非检查型（运行时）异常。

  其中， 如果抛出的异常类型为 *检查型异常*, 那么就必需在方法声明时通过 ~throws~ 声明可能抛出的异常， 同时
  在调用该方法时， 使用 ~try/catch~ 或 ~ducking~ 处理异常。

  如果抛出的异常类型为 *非检查型异常*, 那么可以不声明或包含在 ~try/catch~ 代码块中。 当然， 做了也没影响。

  其中， 非检查型异常是 ~RuntimeException~ 类型或其子类类型的异常， 而检查型异常是除了 ~RuntimeException~ 以外
  的所有异常。

  其中， ~RuntimeException~ 也是 ~Exception~ 的子类， 不过比较特殊。

  使用 ~finally~ 代码块来存放无论如何都要执行的部分。 既是在 ~try/catch~ 代码块中存在 ~return~ 语句， ~finally~ 代码块也
  依然会执行 ！ 流程会跳到 ~finally~ 然后在回到 ~return~ 语句。

  通过如下方式声明多个异常：
  #+BEGIN_SRC java
    public int function() throws IOException, InterruptedException {
      // ...
    }
  #+END_SRC

  通过多个 ~catch~ 块捕获多个异常， 也可以通过多个异常的父类同时捕获多个异常（声明异常也一样， 通过异常父类同时声明多个异常）

  异常也是对象， 因此也支持多态， 所以应该：
  + 以异常的父型来声明会抛出的远程
  + 以所抛出的异常父型来捕获异常
  + 可以用 ~Exception~ 捕获所有异常， 但不代表应该这么做
  + 为每个需要单独处理的异常编写不同的 catch 块
  + 有多个 catch 块时， 要从小排到大（子类到父类）， 否则会无法通过编译

  如果不想处理异常， 那么只需要在方法声明时 *再次 throws* 可能的异常即可：
  #+BEGIN_SRC java
    public int functionA() throws Exception {
      // ...
    }

    public int functionB() throws Exception {  // 再次 throws
      functionA();
    }
  #+END_SRC

  如果连 ~main~ 函数也 duck 调异常， 那么当遇到异常时， Java 虚拟机会当场去世。

  因此， 对于 *检查型异常*, 有两种处理方式：
  1. 使用 ~try/catch~ 处理异常
  2. 使用 ~duck~ 逃避异常

  异常处理规则：
  1. catch 与 finally 不能没有 try
  2. try 与 catch 之间不能有程序
  3. try 一定要有 catch 或 finally
  4. 只带有 finally 的 try 必须声明异常 - duck

* Java Import
** 导入名称
   使用外部类的两种方式：
   + import 导入命名空间， 然后直接使用类名
   + 全名 - 包名.类名

   *NOTE:* java.lang 会自动导入， 因此可以直接使用类名

   *PS:* javax 开头的函数库曾经是扩展， 后来虽然并入标准库， 但是为了兼容程序没有修改名称。
  
** static import
   使用 static import 的作用是 *少打一些字*.

   如：
   #+BEGIN_SRC java
     import static java.lang.System.out;
     import static java.lang.Math.*;

     class WithStatic {
       public static void main(String[] args) {
         out.println("sqrt" + sqrt(2.0));
       }
     }
   #+END_SRC

   可以看到， 省略了前面的 *名称空间.类*, 直接使用导入的 *静态成员*.
 

* 块作用域
  块作用域是由大括号确定的作用域：
  #+BEGIN_SRC java
    public class Test {
      public static void main(String[] args) {
        {
          int num = 10;
          System.out.println(num);
        }
        int num = 10;
      }
    }
  #+END_SRC


* 注意事项
  + Java 没有无符号数
   
  + 定义 ~float~ 的数值需要加 ~f~ 后缀， 如： ~float f = 32.45f~, 否则小数会
    默认当做 ~double~ 处理

  + 和 ~C~ 不同， 类似下面的行为在 ~Java~ 中不被允许， 编译器会报错：
    #+BEGIN_SRC java
      int x = 24;
      byte b = x;
    #+END_SRC
    
    隐式类型转换只允许在不会有数据丢失的情况下进行， 即: ~int~ 不能和
    ~float~ 直接转换。
   
    也不能使用类似 ~byte x = 128~ 的语句
   
  + 除此之外的类型的变量都是对一个对象的 *引用*, *对象* 实例保存在可回收垃圾的堆上

  + 所有引用变量的大小都一样， 不一样的是内存中的实例大小

  + 引用变量的空值为 ~null~
   
  + 和 ~Python~ 一样， 当一个实例对象的引用数为 0 时， 这个对象就可以被回收。

  + 实例对象通常通过 ~new~ 创建， 这会在内存中创建唯一的对象实例

  + 数组也是对象， 数组名是引用类型变量
   
  + 注意引用类型数组的初始化：
    #+BEGIN_SRC java
      Dog[] dog;  // 声明数组 dog
      dog = new Dog[7];  // 为 dog 分配内存

      for (int i = 0; i < 7; ++i) {
        dog[i] = new Dog();  // 为数组元素分配内存
      }
    #+END_SRC
   
  + String 不是 Java 关键字
   
  + 没有初始化的数值类型（包括 char） 默认为 0, 布尔类型默认为 false, 引用默认为 null.
   
  + 局部变量没有默认值， 使用前必须初始化

  + 可以使用 == 来判断两个主数据类型是否相对， 会判断两个引用是否引用同一个对象

  + ~switch~ 语句支持的类型为： 原始数据类型 byte, short, char, int 及对应的包装类；字符串 ~String~ 和 枚举 ~Enum~.

