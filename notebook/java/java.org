#+TITLE:      Java - 基础笔记

* 目录                                                    :TOC_4_gh:noexport:
- [[#原始数据类型取值范围][原始数据类型取值范围]]
- [[#字符与字符串][字符与字符串]]
- [[#布尔判断][布尔判断]]
- [[#类型转换][类型转换]]
- [[#数组][数组]]
- [[#异常相关][异常相关]]
- [[#标识符和关键字][标识符和关键字]]
- [[#autoboxing][autoboxing]]
- [[#枚举类型][枚举类型]]
- [[#注意事项][注意事项]]

* 原始数据类型取值范围
  |---------+-----------------+--------------------------|
  | 类型    |            位数 | 值域                     |
  |---------+-----------------+--------------------------|
  | boolean | Java 虚拟机决定 | true or false            |
  | char    |              16 | 0 ~ 65535                |
  | byte    |               8 | -128 ~ 127               |
  | short   |              16 | -32768 ~ 32767           |
  | int     |              32 | -2147483648 ~ 2147483647 |
  | long    |              64 | -很大 ~ +很大            |
  | float   |              32 | 范围规模可变             |
  | double  |              64 | 范围规模可变             |
  |---------+-----------------+--------------------------|
 
* 字符与字符串
  Java 中 字符串可以直接与 *整数* 和 *字符* 拼接。

  另外， 原始数据类型的变量没有方法， 需要通过对应的 *对象类型* 来调用方法， 如：
  + ~int~ 对应 ~Integer~
  + ~char~ 对应 ~Character~

* 布尔判断
  Java 中 integer 和 boolean 是两种类型， 因此不能像这样：
  #+BEGIN_SRC java
      int x = 1;

      while (x) {}
  #+END_SRC

  使用 ~==~ 判断两个引用是否为同一个对象。

  使用 ~equals~ 判断两个对象的值是否相同。  

* 类型转换
  由与所有的非 ~Object~ 对象都继承了 ~Object~, 因此这些对象在 *堆* 上的实例上， 内部
  也包括了一个 ~Object~ 实例。

  即： 后代的实例内部包含父类的实例。

  因此父类类型的引用相当于只能操作子类实例内部的父类实例。

  通过强制类型转换可以将父类引用转换为子类引用， 转换前可以使用关键字 ~instanceof~ 来判断该对象是否是对应类型的实例。

  #+BEGIN_SRC java
    if (obj instanceof Dog) {
      Dog d = (Dog)obj;
    }
  #+END_SRC

  如果类型转换失败会抛出 ~ClassCastException~ 异常。
  
  *向上向下转型：*

  #+BEGIN_SRC java
    // 向上转型
    SuperClass ref = new SubClass();

    // 向下转型
    SubClass ref = (SubClass) SuperClassRef;
  #+END_SRC

* 数组
  数组的声明和初始化方式：
  #+BEGIN_SRC java
    // 声明数组
    dataType[] arrayRefVar;   // 首选的方法

    dataType arrayRefVar[];  // 效果相同，但不是首选方法

    // 创建数组
    dataType[] arrayRefVar = new dataType[arraySize];

    dataType[] arrayRefVar = {value0, value1, ..., valuek};  // 只能在声明的同时使用

    dataType[] arrayRefVar = new dataType[]{value0, value1, ..., valuek};
  #+END_SRC

  数组的 *成员* 包括：
  1. ~public final length~
  2. ~public T[] clone()~
  3. ~Object method~

  相关链接：
  + [[http://www.importnew.com/7127.html][Java 数组]]
  + [[http://wiki.jikexueyuan.com/project/java-enhancement/java-thirtysix.html][asList 的缺陷]]

* 异常相关
  + 捕获异常：
    #+BEGIN_SRC java
      try {
        // 可能会抛出异常的代码块
      } catch(Exception ex) {
        // 捕获异常后执行的代码块
      }
    #+END_SRC
  + 抛出异常：
    #+BEGIN_SRC java
      public int function() throws Exception {  // 声明可能抛出的异常
        throw new Exception();  // 抛出异常
      }
    #+END_SRC

  Java 中的所有异常是 ~Exception~ 类型的 *对象*.

  异常分为： 检查型异常和非检查型（运行时）异常。

  其中， 如果抛出的异常类型为 *检查型异常*, 那么就必需在方法声明时通过 ~throws~ 声明可能抛出的异常， 同时
  在调用该方法时， 使用 ~try/catch~ 或 ~ducking~ 处理异常。

  如果抛出的异常类型为 *非检查型异常*, 那么可以不声明或包含在 ~try/catch~ 代码块中。 当然， 做了也没影响。

  其中， 非检查型异常是 ~RuntimeException~ 类型或其子类类型的异常， 而检查型异常是除了 ~RuntimeException~ 以外
  的所有异常。

  其中， ~RuntimeException~ 也是 ~Exception~ 的子类， 不过比较特殊。

  使用 ~finally~ 代码块来存放无论如何都要执行的部分。 既是在 ~try/catch~ 代码块中存在 ~return~ 语句， ~finally~ 代码块也
  依然会执行 ！ 流程会跳到 ~finally~ 然后在回到 ~return~ 语句。

  通过如下方式声明多个异常：
  #+BEGIN_SRC java
    public int function() throws IOException, InterruptedException {
      // ...
    }
  #+END_SRC

  通过多个 ~catch~ 块捕获多个异常， 也可以通过多个异常的父类同时捕获多个异常（声明异常也一样， 通过异常父类同时声明多个异常）

  异常也是对象， 因此也支持多态， 所以应该：
  + 以异常的父型来声明会抛出的远程
  + 以所抛出的异常父型来捕获异常
  + 可以用 ~Exception~ 捕获所有异常， 但不代表应该这么做
  + 为每个需要单独处理的异常编写不同的 catch 块
  + 有多个 catch 块时， 要从小排到大（子类到父类）， 否则会无法通过编译

  如果不想处理异常， 那么只需要在方法声明时 *再次 throws* 可能的异常即可：
  #+BEGIN_SRC java
    public int functionA() throws Exception {
      // ...
    }

    public int functionB() throws Exception {  // 再次 throws
      functionA();
    }
  #+END_SRC

  如果连 ~main~ 函数也 duck 调异常， 那么当遇到异常时， Java 虚拟机会当场去世。

  因此， 对于 *检查型异常*, 有两种处理方式：
  1. 使用 ~try/catch~ 处理异常
  2. 使用 ~duck~ 逃避异常

  异常处理规则：
  1. catch 与 finally 不能没有 try
  2. try 与 catch 之间不能有程序
  3. try 一定要有 catch 或 finally
  4. 只带有 finally 的 try 必须声明异常 - duck
  
* 标识符和关键字
  和 ~C~ 与 ~Python~ 不同， ~Java~ 的标识符包含 ~$~, 即可以用 ~$~ 开头。

  ~C~ 和 ~Python~ 只能是字母或下划线。

  这一点和 ~JavaScript~ 是相同的。

  关键字表格：
  | boolean   | byte     | char       | double | float      | int       | long         | short     | public   | private |
  | protected | abstract | final      | native | static     | strictfp  | synchronized | transient | volatile | if      |
  | else      | do       | while      | switch | case       | default   | for          | break     | continue | assert  |
  | class     | extends  | implements | import | instanceof | interface | new          | package   | super    | this    |
  | catch     | finally  | try        | throw  | throws     | return    | void         | const     | goto     | enum    |

  + [[http://www.hollischuang.com/archives/1191][Java中的this关键字]]
  + 使用同一个包内的类， 可以省略包名， 及可以不用 ~import~.
  + 包的定义中， 需要目录结构和 ~package xxx.xxx~ 的结构相同

* autoboxing
  ~primitive~ 主数据类型都有对应的 *包装类*.

  |----------------------+--------------|
  | primitive 主数据类型 | 对应的包装类 |
  |----------------------+--------------|
  | boolean              | Boolean      |
  | char                 | Character    |
  | byte                 | Byte         |
  | short                | Short        |
  | int                  | Integer      |
  | long                 | Long         |
  | float                | Float        |
  | double               | Double       |
  |----------------------+--------------|

  在 ~java 5.0~ 之后的 ~java~ 中， 添加了 ~autoboxing~ 的功能， 允许在一些
  地方自动的完成 primitive 主数据类型和包装的对象的转换。

  这也叫做装箱和拆箱：
  + 装箱 -> primitive 主数据类型转换为对应的包装对象
  + 拆箱 -> 将包装对象转换为对应的 primitive 主数据类型

  可以使用 autoboxing 的地方包括：
  1. 方法的参数
  2. 返回值
  3. boolean 表达式， 任何预期 boolean 值的地方都可以用求 boolean 的表达式代替
  4. 数值运算
  5. 赋值

  #+BEGIN_SRC java
    public class Autoboxing {
      public Integer auto(Integer num) {  // 参数可以为 int 或 Integer
        int n = num;  // int 和 Integer 间可以直接赋值
        num += n;  // int 和 Integer 间可以直接加减
        return n;  // 返回值类型可以为 int 或 Integer
      }
    }
  #+END_SRC

  通过包装类可以调用有用的静态方法。

* 枚举类型
  枚举类型的声明可以在 *类外部* 或 *类内部*, 但是不能再 *方法内部*.

  枚举类型的简单声明和使用：
  #+BEGIN_SRC java
    public enum Members {JOB, ALICE, PHIL}

    Members member = Members.ALICE;  // default is null
  #+END_SRC

  枚举类型自动继承 ~java.lang.Enum~, 即： 所有枚举类型都是 ~Enum~ 的子类。

  不同枚举变量之间的比较可以用 ~==~ 或 ~equals~, 但 ~==~ 是一个更好的方式。

  枚举类型中定义的的每个值都是该枚举类型的 *实例*, 可以为这些实例定义属性和方法。

  #+BEGIN_SRC java
    public enum Names {
      JERRY("lead guitar") {
        public String sings() {
          return "JERRY";
        }
      },

      BOBBY("bass");

      private String instrument;

      Names(String instrument) {
        this.instrument = instrument;
      }

      public String getInstrument() {
        return this.instrument;
      }

      public String sings() {
        return "Default";
      }
    }
  #+END_SRC
    
  ~BOBBY("bass")~ 调用构造函数 ~Names~.

  如下代码定义之自己的 ~sings~ 方法。
  #+BEGIN_SRC java
    JERRY("lead guitar") {
      public String sings() {
        return "JERRY";
      }
    }
  #+END_SRC

  #+BEGIN_SRC java
    for (Names name : Names.value()) {  // Enum.value()
      System.out.println(name.sing());
    }
  #+END_SRC

* 注意事项
  + Java 没有无符号数
   
  + 定义 ~float~ 的数值需要加 ~f~ 后缀， 如： ~float f = 32.45f~, 否则小数会
    默认当做 ~double~ 处理

  + 和 ~C~ 不同， 类似下面的行为在 ~Java~ 中不被允许， 编译器会报错：
    #+BEGIN_SRC java
      int x = 24;
      byte b = x;
    #+END_SRC
    
    隐式类型转换只允许在不会有数据丢失的情况下进行， 即: ~int~ 不能和
    ~float~ 直接转换。
   
    也不能使用类似 ~byte x = 128~ 的语句
   
  + 除此之外的类型的变量都是对一个对象的 *引用*, *对象* 实例保存在可回收垃圾的堆上

  + 所有引用变量的大小都一样， 不一样的是内存中的实例大小

  + 引用变量的空值为 ~null~
   
  + 和 ~Python~ 一样， 当一个实例对象的引用数为 0 时， 这个对象就可以被回收。

  + 实例对象通常通过 ~new~ 创建， 这会在内存中创建唯一的对象实例

  + 数组也是对象， 数组名是引用类型变量
   
  + 注意引用类型数组的初始化：
    #+BEGIN_SRC java
      Dog[] dog;  // 声明数组 dog
      dog = new Dog[7];  // 为 dog 分配内存

      for (int i = 0; i < 7; ++i) {
        dog[i] = new Dog();  // 为数组元素分配内存
      }
    #+END_SRC
   
  + String 不是 Java 关键字
   
  + 没有初始化的数值类型（包括 char） 默认为 0, 布尔类型默认为 false, 引用默认为 null.
   
  + 局部变量没有默认值， 使用前必须初始化

  + 可以使用 == 来判断两个主数据类型是否相对， 会判断两个引用是否引用同一个对象

  + ~switch~ 语句支持的类型为： 原始数据类型 byte, short, char, int 及对应的包装类；字符串 ~String~ 和 枚举 ~Enum~.

