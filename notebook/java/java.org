#+TITLE:      Java 基础知识

* 目录                                                    :TOC_4_gh:noexport:
- [[#基本程序设计结构][基本程序设计结构]]
  - [[#primitive-types][Primitive Types]]
  - [[#类型转换][类型转换]]
  - [[#数组][数组]]
    - [[#数组的类型判断][数组的类型判断]]
    - [[#数组的克隆][数组的克隆]]
  - [[#数组成员的类型判断][数组成员的类型判断]]
- [[#抽象系统][抽象系统]]
  - [[#java-class][Java Class]]
    - [[#object][Object]]
    - [[#方法的覆盖][方法的覆盖]]
    - [[#方法的重载][方法的重载]]
    - [[#内部类][内部类]]
    - [[#static--final][static & final]]
    - [[#抽象类与抽象方法][抽象类与抽象方法]]
    - [[#继承][继承]]
    - [[#多态][多态]]
    - [[#私有字段][私有字段]]
  - [[#java-object][Java Object]]
    - [[#对象的创建][对象的创建]]
    - [[#对象的生命周期][对象的生命周期]]
    - [[#栈与堆中保存的对象][栈与堆中保存的对象]]
  - [[#java-interface][Java Interface]]
    - [[#抽象方法的声明][抽象方法的声明]]
    - [[#接口的定义][接口的定义]]
  - [[#java-enum][Java Enum]]
- [[#异常处理][异常处理]]
  - [[#throwable][Throwable]]
  - [[#带资源的-try-语句][带资源的 try 语句]]
- [[#泛型][泛型]]
  - [[#泛型类型][泛型类型]]
  - [[#泛型方法][泛型方法]]
  - [[#有界类型参数][有界类型参数]]
  - [[#泛型类的子类][泛型类的子类]]
  - [[#类型推断][类型推断]]
  - [[#通配符][通配符]]
  - [[#类型擦除][类型擦除]]
  - [[#泛型的限制][泛型的限制]]
- [[#lambda-表达式][Lambda 表达式]]
  - [[#lambda-表达式语法][Lambda 表达式语法]]
  - [[#lambda-表达式的使用场景][Lambda 表达式的使用场景]]
  - [[#lambda-表达式使用局部变量][Lambda 表达式使用局部变量]]
  - [[#方法引用][方法引用]]
  - [[#复合-lambda-表达式][复合 Lambda 表达式]]
- [[#java-import][Java Import]]
  - [[#导入名称][导入名称]]
  - [[#static-import][static import]]
- [[#块作用域][块作用域]]
- [[#注意事项][注意事项]]

* 基本程序设计结构
** Primitive Types
   + Primitive 类型的取值范围：
     |---------+-----------------+--------------------------|
     | 类型    |            位数 | 值域                     |
     |---------+-----------------+--------------------------|
     | boolean | Java 虚拟机决定 | true or false            |
     | char    |              16 | 0 ~ 65535                |
     | byte    |               8 | -128 ~ 127               |
     | short   |              16 | -32768 ~ 32767           |
     | int     |              32 | -2147483648 ~ 2147483647 |
     | long    |              64 | -很大 ~ +很大            |
     | float   |              32 | 范围规模可变             |
     | double  |              64 | 范围规模可变             |
     |---------+-----------------+--------------------------|

   + Java 作为强类型语言，需要布尔值的地方就只能使用 boolean 类型的值，布尔表达式可以自动转换为布尔值（自动装箱）。

** 类型转换
   由与所有的非 ~Object~ 对象都继承了 ~Object~, 因此这些对象在 *堆* 上的实例上， 内部也包括了一个 ~Object~ 实例。

   即：后代的实例内部包含父类的实例。

   因此父类类型的引用相当于只能操作子类实例内部的父类实例。

   通过强制类型转换可以将父类引用转换为子类引用，转换前应该使用关键字 ~instanceof~ 来判断该对象是否是对应类型的实例。

   #+BEGIN_SRC java
     if (obj instanceof Dog) {
       Dog d = (Dog)obj;
     }
   #+END_SRC

   如果类型转换失败会抛出 ~ClassCastException~ 异常。
  
   *向上向下转型：*
   #+BEGIN_SRC java
     // 向上转型
     SuperClass ref = new SubClass();

     // 向下转型
     SubClass ref = (SubClass) SuperClassRef;
   #+END_SRC

   注意：null isinstanceof xxx 会返回 false

** 数组
   数组的声明和初始化方式：
   #+BEGIN_SRC java
     // 声明数组
     dataType[] arrayRefVar;   // 首选的方法

     dataType arrayRefVar[];  // 效果相同，但不是首选方法

     // 创建数组
     dataType[] arrayRefVar = new dataType[arraySize];

     dataType[] arrayRefVar = {value0, value1, ..., valuek};  // 只能在声明的同时使用

     dataType[] arrayRefVar = new dataType[]{value0, value1, ..., valuek};
   #+END_SRC

   数组的 *成员* 包括：
   1. ~public final length~
   2. ~public T[] clone()~
   3. ~Object method~

   注意：Java 数组会保存存储的元素的类型信息，虽然父类型的数组引用可以引用子类型的数组的实例，
   而且往该引用中存入父类型实例的操作可以通过编译器的检查，但是会在运行期间抛出异常。

*** 数组的类型判断
    #+BEGIN_QUOTE
    Primitive arrays are instance of Object and self type. e.g. int[] is type of Object and int[]. Both comparison returns true.

    Object arrays are types of Object, Object array, classtype array, parent class type array.
    e.g. Integer[] is type of Object, Object[], Integer[] and Number[] (Integer extends Number).
    #+END_QUOTE

    + [[https://howtodoinjava.com/oops/java-instanceof/][Java instanceof - Java type comparison operator - HowToDoInJava]]

    特别的， int[][] 是 Object[] 的实例。

    这也就是为什么 ~asList~ 不要使用 ~int[]~ 参数的原因。

*** 数组的克隆
    数组对象的 ~clone()~ 方法会返回一个新的数组对象，这个数组对象包含和原数组中相同的元素。

    对于 Primitive 数据类型的数组来说，由于数组元素是值，因此，克隆出来的数组和原数组互不干扰。

    对于其他类型的数组，克隆出来的数组和原数组中的对象是一样的，修改一个就会影响另一个。

    #+BEGIN_SRC java
      int[] a = {1, 2, 3};
      int[] b = a.clone();

      System.out.println(a == b ? "Same Instance":"Different Instance");
      //Outputs different instance

      System.out.println(myDogs[0] == myDogsClone[0] ? "Same":"Different");
      System.out.println(myDogs[1] == myDogsClone[1] ? "Same":"Different");
      System.out.println(myDogs[2] == myDogsClone[2] ? "Same":"Different");
      System.out.println(myDogs[3] == myDogsClone[3] ? "Same":"Different");
      //Outputs Same (4 Times)
    #+END_SRC

** 数组成员的类型判断
   数组要求其成员元素的类型是一样的，下面这样的写法会出错：
   #+BEGIN_SRC java
     Child[] arr = new Child[10];
     Parent[] parr = arr;
     parr[0] = new Parent();
   #+END_SRC

* 抽象系统
** Java Class
*** Object
    Object 是所有类的基类，没有继承其他类的类会隐式继承这个类，可以被实例化。

    该类的一些方法（所有类都可以使用）：
    |------------------+----------------------------------------|
    | 方法             | 作用                                   |
    |------------------+----------------------------------------|
    | ~equals(Object o)~ | 判断两个对象的值是否相等               |
    | ~getClass()~       | 获取对象的类型                         |
    | ~hashCode()~       | 列出对象的哈希代码， 这是对象的唯一 id |
    | ~toString()~       | 列出类的名字和一个我们不关心的数字     |
    | ~finalize()~       | 析构函数                               |
    | ~getClass()~       | 获取类                                 |
    |------------------+----------------------------------------|

*** 方法的覆盖
    覆盖方法是需要注意：
    1. 方法在覆盖时的可见性不能低于父类
    2. 子类方法抛出的异常不能比父类的更通用，如果父类方法没有抛出异常那么子类的也不能抛出

*** 方法的重载
    重载的意义是两个方法的 *名称相同*, 但参数不同，因此 *重载与多态毫无关系*.

    重载的基本原则：
    1. 返回类型可以不同
    2. 不能只改变返回类型
    3. 可以更改存取权限

    *NOTE:* 重载和覆盖不一样

    重载需要改变参数的类型或顺序， 而不是参数的名字。

    编译器只关注类型与顺序， 而不是参数的名字。

*** 内部类
    嵌套在类内部的类为内部类，内部类可以访问所有外部类的成员，包括私有的。

    内部类的其他行为和一般类相同，可以继承类，也可以实现接口。
  
    内部类内部的 ~this~ 代表该内部类的实例，而不是外部类。

    + [[https://www.cnblogs.com/nerxious/archive/2013/01/25/2876489.html][java 中的匿名内部类总结]]

    #+BEGIN_SRC java
      abstract class Person {
        public abstract void eat();
      }

      public class Demo {
        public static void main(String[] args) {
          Person p = new Person() {
              public void eat() {
                System.out.println("eat something");
              }
            };
          p.eat();
        }
      }
    #+END_SRC

    这种特殊语法同时还可以用在 ~Interface~ 上。

*** static & final
    可以使用 ~static~ 修饰 实例变量 和 方法， 修饰的实例变量作为静态变量， 所有实例共享。修饰的方法为静态方法。

    不能使用 ~static~ 修饰类和局部变量。

    静态方法不能访问非静态成员， 包括实例变量与非静态方法。

    静态成员可以使用实例的引用来访问， 但是不推荐使用这种方式。

    静态变量的初始化是指类被加载时完成的， 会在任何类的对象创建之前完成初始化。也会在任何类的
    静态方法执行之前完成初始化。

    如果没有为静态变量赋初值， 那么静态变量会被设定为对应类型的默认值。

    ~static final~ 修饰的变量作为 *常量*. 常量的初始化只能在 *声明时* 或 *静态初始化程序* 中：
    #+BEGIN_SRC java
      public class ClassName {
        public static final int num;

        // 静态初始化程序
        static {
          num = 10;
        }
      }
    #+END_SRC

    不能同时在声明与静态初始化程序中赋值。

    常量必须初始化， 否则会出错。

    静态初始化程序可以为静态变量赋值， 不能访问非静态成员。

    单独使用 ~final~ 修饰的变量是常量， 不能被改动。 可以在声明或构造函数中初始化。不能同时进行。

    ~final~ 修饰的方法不能被覆盖。

    ~final~ 修饰的类不能被继承。
  
*** 抽象类与抽象方法
    1. 抽象类与抽象方法使用关键字 abstract 修饰
    2. 抽象类不能被实例化
    3. 抽象方法在具体类中必须被实现， 但可以在抽象类中传递
    4. 抽象方法只能在抽象类中定义
     
    *AbstractClass.java*:
    #+BEGIN_SRC java
      public abstract class AbstractClass {
        public abstract void method();
      }
    #+END_SRC

    *AbstractSubClass.java*:
    #+BEGIN_SRC java
      public abstract class AbstractSubClass extends AbstractClass {}
    #+END_SRC

    *NotAbstractClass.java*:
    #+BEGIN_SRC java
      public class NotAbstractClass extends AbstractSubClass{
        public void method() {}
      }
    #+END_SRC

*** 继承
    子类会自动继承父类的 *实例变量* 与 *方法*, 可以在子类中覆盖父类的方法， 但不能覆盖 *实例变量*,
    因为不需要，实例变量并没有什么特殊的行为。

    方法调用会调用与该对象最接近的方法， 即在继承层次最下方。

    执行时 java 虚拟机不关心方法来自那个类。

    父类不能调用子类的方法。

    使用关键字 ~super~ 调用父类的方法。

    覆盖父类方法： 重写那个方法即可。 ~@Override~ 的作用： [[https://blog.csdn.net/zht666/article/details/7869383][Java中@Override的作用]]

    继承使用关键字 ~extends~: ~class son extends father~.

    继承会继承 ~public~ 类型的方法和实例变量， 但不会继承 ~private~ 的。

    *引用类型可以是实际对象类型的父类*. 定义变量， 函数传参， 返回值时都可以如此。 即： *多态*.

    除了 *内部类* 以外， 没有 *私有类* 的说法。

    防止类被继承：
    1. 非公有类只能被同一个包的类继承
    2. 使用 final 修饰符修饰的类无法被继承
    3. 让类拥有 private 的构造函数

    使用 final 修饰的方法不会被覆盖。

    同时， 类的 private 方法会隐式地被指定为 final 方法。
  
    覆盖的基本原则：
    1. 参数和返回值类型必须要一样
    2. 不能降低方法的存取权限， 只能保持一样或更加开放

    + [[https://www.polarxiong.com/archives/JAVA-%E5%AD%90%E7%B1%BB-%E8%A6%86%E7%9B%96-%E7%88%B6%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F.html][JAVA: 子类覆盖父类的成员变量]]

*** 多态
    1. 使用父类类型的引用指向子类的对象
    2. 该引用只能调用父类中定义的方法和变量

    编译器根据 *引用类型* 来判断有哪些 ~method~ 可以调用， 而不是 ~Object~ 确实的类型。

*** 私有字段
    类的私有字段可以在类内部直接方问，不管是不是当前的实例：
    #+BEGIN_SRC java
      public class TestP {
        private int val = 10;

        public static void main(String[] args) {
          TestP t = new TestP();
          t.val = 100;
          System.out.println(t.val);
        }
      }
    #+END_SRC

** Java Object
*** 对象的创建
    创建对象的过程： 声明引用变量、 创建对象、 连接对象与引用

    创建对象是会调用对象的 *构造函数*.

    默认构造函数为(编译器创建)：
    #+BEGIN_SRC java
      public className {
 
      }
    #+END_SRC

    *注*: 构造函数没有返回值， 且与类名同名。 如果存在与类名相同但是存在返回值类型的方法， 那么不是构造函数。

    构造函数不会被继承 ！

    定义构造函数时， 可以的话就编写一个 *没有参数* 的构造函数

    如果自己定义了构造函数， 那么编译器不会在创建默认的无参的构造函数。

    如果不存在无参的构造函数， 那么 new 操作时就必须有参数。

    构造函数可以为公有， 私有或不指定的。

    如果构造函数是私有的， 那么这个类不能创建实例

    在创建新对象时， 所有继承下来的构造函数都会执行。

    抽象类也有构造函数， 会在创建子类实例时执行。

    先执行父类的构造函数， 在执行自身的构造函数。

    在构造函数中使用 ~super()~ 调用父类构造函数（唯一方法）。

    如果没有手动调用 ~super()~, 编译器会默认进行调用（包括每一个构造函数）：
    #+BEGIN_SRC java
      // 默认构造函数
      public ClassName() {
        super();
      }


      // 自定义构造函数
      public ClassName() {
        super();
        // your code
      }
    #+END_SRC

    默认调用的是父类的无参构造函数。

    ~super()~ 的调用必须是在构造函数的 *第一个语句*.

    如果不能向父类的带参构造函数传参， 那么就不能继承没有无参构造函数的类。

    传参：
    #+BEGIN_SRC java
      super(args...)
    #+END_SRC

    使用 ~this()~ 来从某个构造函数调用同一个类的另外一个构造函数。

    ~this()~ 只能用在 *构造函数*, 且必须是 *第一个语句*.

    ~super()~ 和 ~this()~ 不能兼得。

    #+BEGIN_SRC java
      public ClassName() {
        this(num);
      }
    #+END_SRC

*** 对象的生命周期
    + 局部变量存活在声明该变量的方法中
    + 实例变量与对象的生命周期相同
    + Life 与 Scope 的区别： P259, 很形象
    + 对象的声明周期受引用计数的影响， 当引用计数为 0 时该对象就可以被回收
    + 释放对象引用的三种方式：
      1. 引用变量永久性离开它的返回（死了）
      2. 引用被赋值到其他对象身上（NTR）
      3. 直接将引用设定为 null (byebye)
  
*** 栈与堆中保存的对象
    + 栈空间中保存： 方法调用与局部变量

    + 堆空间中保存： 对象与实例变量

    + 实例变量是被声明在类而不是方法里面的变量

    + 实例变量可以在声明时赋初值， 否则会被设置为默认值（局部变量没有默认值）

    + 实例变量的默认值为： 0/0.0/false/null

** Java Interface
*** 抽象方法的声明
    声明抽象方法必须省略方法主体：
    #+BEGIN_SRC java
      public abstract void method();
    #+END_SRC

    声明类和其他方法不能省略主体， 即使主体为空：
    #+BEGIN_SRC java
      public abstract class AbstractClass {
        public void method() {}
      }
    #+END_SRC

*** 接口的定义
    1. Java 不允许多重继承
    2. 替代方案是使用接口 ~Interface~

    接口的特点：
    1. 接口不能被实例化， 但是可以被实现
    2. 接口没有构造方法
    3. 接口中所有的方法默认(必须)为 ~public abstract~
    4. 允许一个类同时实现多个接口， 因为所有的接口方法都是抽象的

    #+BEGIN_SRC java
      interface Actor {
        void methodA();
        void methodB();
      }
    #+END_SRC

    接口的继承使用关键字： ~implements~.

    #+BEGIN_SRC java
      public class Dog implements ...
    #+END_SRC

    如果继承接口的类是抽象类， 那么可以不实现接口的方法， 留待子类实现。
  
    需要某些类的特殊化版本时继承它们。

    需要某些类扮演一个角色时， 定义一个接口

** Java Enum
   枚举类型的声明可以在 *类外部* 或 *类内部*, 但是不能再 *方法内部*.

   枚举类型的简单声明和使用：
   #+BEGIN_SRC java
     public enum Members {JOB, ALICE, PHIL}

     Members member = Members.ALICE;  // default is null
   #+END_SRC

   枚举类型自动继承 ~java.lang.Enum~, 即： 所有枚举类型都是 ~Enum~ 的子类。

   不同枚举变量之间的比较可以用 ~==~ 或 ~equals~, 但 ~==~ 是一个更好的方式。

   枚举类型中定义的的每个值都是该枚举类型的 *实例*, 可以为这些实例定义属性和方法。

   #+BEGIN_SRC java
     public enum Names {
       JERRY("lead guitar") {
         public String sings() {
           return "JERRY";
         }
       },

       BOBBY("bass");

       private String instrument;

       Names(String instrument) {
         this.instrument = instrument;
       }

       public String getInstrument() {
         return this.instrument;
       }

       public String sings() {
         return "Default";
       }
     }
   #+END_SRC
    
   ~BOBBY("bass")~ 调用构造函数 ~Names~.

   如下代码定义之自己的 ~sings~ 方法。
   #+BEGIN_SRC java
     JERRY("lead guitar") {
       public String sings() {
         return "JERRY";
       }
     }
   #+END_SRC

   #+BEGIN_SRC java
     for (Names name : Names.value()) {  // Enum.value()
       System.out.println(name.sing());
     }
   #+END_SRC

* 异常处理
  + 捕获异常：
    #+BEGIN_SRC java
      try {
        // 可能会抛出异常的代码块
      } catch(Exception ex) {
        // 捕获异常后执行的代码块
      }
    #+END_SRC
    
  + 抛出异常：
    #+BEGIN_SRC java
      public int function() throws Exception {  // 声明可能抛出的异常
        throw new Exception();  // 抛出异常
      }
    #+END_SRC

  Java 中的所有异常是 ~Exception~ 类型的 *对象*.

  异常分为： 检查型异常和非检查型（运行时）异常。

  其中， 如果抛出的异常类型为 *检查型异常*, 那么就必需在方法声明时通过 ~throws~ 声明可能抛出的异常， 同时
  在调用该方法时， 使用 ~try/catch~ 或 ~ducking~ 处理异常。

  如果抛出的异常类型为 *非检查型异常*, 那么可以不声明或包含在 ~try/catch~ 代码块中。 当然， 做了也没影响。

  其中， 非检查型异常是 ~RuntimeException~ 类型或其子类类型的异常， 而检查型异常是除了 ~RuntimeException~ 以外
  的所有异常。

  其中， ~RuntimeException~ 也是 ~Exception~ 的子类， 不过比较特殊。

  使用 ~finally~ 代码块来存放无论如何都要执行的部分。 既是在 ~try/catch~ 代码块中存在 ~return~ 语句， ~finally~ 代码块也
  依然会执行 ！ 流程会跳到 ~finally~ 然后在回到 ~return~ 语句。

  通过如下方式声明多个异常：
  #+BEGIN_SRC java
    public int function() throws IOException, InterruptedException {
      // ...
    }
  #+END_SRC

  通过多个 ~catch~ 块捕获多个异常， 也可以通过多个异常的父类同时捕获多个异常（声明异常也一样， 通过异常父类同时声明多个异常）

  异常也是对象， 因此也支持多态， 所以应该：
  + 以异常的父型来声明会抛出的远程
  + 以所抛出的异常父型来捕获异常
  + 可以用 ~Exception~ 捕获所有异常， 但不代表应该这么做
  + 为每个需要单独处理的异常编写不同的 catch 块
  + 有多个 catch 块时， 要从小排到大（子类到父类）， 否则会无法通过编译

  如果不想处理异常， 那么只需要在方法声明时 *再次 throws* 可能的异常即可：
  #+BEGIN_SRC java
    public int functionA() throws Exception {
      // ...
    }

    public int functionB() throws Exception {  // 再次 throws
      functionA();
    }
  #+END_SRC

  如果连 ~main~ 函数也 duck 调异常， 那么当遇到异常时， Java 虚拟机会当场去世。

  因此， 对于 *检查型异常*, 有两种处理方式：
  1. 使用 ~try/catch~ 处理异常
  2. 使用 ~duck~ 逃避异常

  异常处理规则：
  1. catch 与 finally 不能没有 try
  2. try 与 catch 之间不能有程序
  3. try 一定要有 catch 或 finally
  4. 只带有 finally 的 try 必须声明异常 - duck

** Throwable
   所有异常的父类，它的拥有构造函数和方法：
   #+BEGIN_SRC java
     Throwable()
     Throwable(String message);
     String getMessage();
   #+END_SRC

   + 创建自己的异常：
     #+BEGIN_SRC java
       public class MyException extends Exception {
         public MyException() {}
         public MyException(String message) {
           super(message);
         }
       }
     #+END_SRC

   + 捕获多个异常是异常变量隐含为 final 变量：
     #+BEGIN_SRC java
       catch (E1 | E2 e)
     #+END_SRC

   + 异常链
     #+BEGIN_SRC java
       catch (Exception e) {
         Throwable se = new ...;  // new ...(e);
         se.initCause(e);
         throws se;
       }
     #+END_SRC

   + finally 子句的返回值会覆盖原本的返回值

   + 解耦 finally 和 catch：
     #+BEGIN_SRC java
       try {
         try {} finally {}
       } catch (Throwable e) {
         e.printStackTrace();
       }
     #+END_SRC
   + 早抛出晚捕获

   + Thread.dumpStack

   + java -verbose 观察类的加载过程

   + -Xlint 选项对常见问题进行检查

** 带资源的 try 语句
   #+BEGIN_SRC java
     try (AutoCloseable a = new xxx();
          AutoCloseable b = new xxx()) {
       ...
     }
   #+END_SRC

   + [[https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html][The try-with-resources Statement]]

   这一特性从 JDK 7 开始支持，实现 ~AutoCloseable~ 和 ~CloseAble~ 接口的对象都可以使用。

   其中 ~io.CloseAble~ 是 ~lang.AutoCloseable~ 的子接口。

* 泛型
** 泛型类型
   + *类型参数命名约定*

     #+BEGIN_EXAMPLE
       E - Element (used extensively by the Java Collections Framework)
       K - Key
       N - Number
       T - Type
       V - Value
       S,U,V etc. - 2nd, 3rd, 4th types
     #+END_EXAMPLE

   + *原始类型*

     原始类型是没有任何类型参数的泛型类或接口的名称，如果将原始类型分配给参数化类型，
     或者使用原始类型调用相应泛型类型中定义的泛型方法，会得到警告。

     #+BEGIN_SRC java
       public class Box<T> {
         public void set(T t) { /* ... */ }
         // ...
       }

       Box<String> stringBox = new Box<>();
       Box rawBox = stringBox;               // OK

       Box rawBox = new Box();           // rawBox is a raw type of Box<T>
       Box<Integer> intBox = rawBox;     // warning: unchecked conversion

       Box<String> stringBox = new Box<>();
       Box rawBox = stringBox;
       rawBox.set(8);  // warning: unchecked invocation to set(T)
     #+END_SRC

** 泛型方法
   单独的泛型方法声明需要声明 *类型参数列表*, 这个列表位于返回值之前。

   #+BEGIN_SRC java
     public class Util {
       public static <K, V> boolean compare(Pair<K, V> p1, Pair<K, V> p2) {
         return p1.getKey().equals(p2.getKey()) &&
             p1.getValue().equals(p2.getValue());
       }
     }
   #+END_SRC

   当类型推断无法完成的时候，调用泛型方法需要指定类型：
   #+BEGIN_SRC java
     Util.<String, Integer>compare();
   #+END_SRC

** 有界类型参数
   声明类型参数可以使用关键字 ~extends~ 指定上限。

   #+BEGIN_SRC java
     public <T extends Number> void inspect(T t){
       System.out.println("T: " + t.getClass().getName());
     }
   #+END_SRC

   有界类型参数还允许调用边界中定义的方法：
   #+BEGIN_SRC java
     public class NaturalNumber<T extends Integer> {

       private T n;

       public NaturalNumber(T n)  { this.n = n; }

       public boolean isEven() {
         return n.intValue() % 2 == 0;
       }

       // ...
     }
   #+END_SRC
  
   可以同时指定多个边界：
   #+BEGIN_SRC java
     <T extends B1 & B2 & B3>
   #+END_SRC

   类似的，可以通过关键字 ~super~ 指定下限。

** 泛型类的子类
   ~Box<Integer>~ 不是 ~Box<Number>~ 的子类型，即使 ~Integer~ 是 ~Number~ 的子类型
  
   #+HTML: <img src="https://docs.oracle.com/javase/tutorial/figures/java/generics-subtypeRelationship.gif">

   继承泛型类的杀死后可以添加类型参数：
   #+BEGIN_SRC java
     interface PayloadList<E,P> extends List<E> {
       void setPayload(int index, P val);
       ...
     }
   #+END_SRC

   #+HTML: <img src="https://docs.oracle.com/javase/tutorial/figures/java/generics-payloadListHierarchy.gif">

   但是：Pair<Child> 是 Pair<? extends Super> 的子类

** 类型推断
   Java 编译器利用 *目标类型* 来推断泛型方法调用的类型参数，比如：

   #+BEGIN_SRC java
     // static <T> List<T> emptyList();
     List<String> listOne = Collections.emptyList();
   #+END_SRC

   目标类型为 ~List<String>~, 因此可以推断出类型 ~T~ 为 ~String~.

   *NOTE:* JDK 8 开始支持这一特性

** 通配符
   通配符 ~?~ 的使用场景：
   #+BEGIN_SRC java
     // 声明泛型类
     public class Box<T> {}  // OK
     public class Box<?> {}  // ERROR

     // 声明泛型方法
     public class Box {
       public <T> void method(T val);  // OK
       public <?> void method(? val);  // ERROR
     }

     // 泛型类的类型参数
     public List<?> list;  // 作为泛型类引用的类型参数 - OK
     public List<?> list = new ArrayList<?>();  // 实例化泛型类 - ERROR
   #+END_SRC

   + *指定上下限*

     指定上下限的方式依然是使用关键字 ~extends~ 和 ~super~:
     #+BEGIN_SRC java
       public static double sumOfList(List<? extends Number> list) {
         double s = 0.0;
         for (Number n : list)
           s += n.doubleValue();
         return s;
       }

       public static void addNumbers(List<? super Integer> list) {
         for (int i = 1; i <= 10; i++) {
           list.add(i);
         }
       }
     #+END_SRC

   + *无边界通配符*

     无边界通配符的适用场景：
     1. 编写通过 Object 类提供的方法就可以完成所有工作的方法
     2. 只使用泛型类中不依赖于类型参数的方法时。比如，经常使用的 ~Class<?>~, 
        因为 ~Class<T>~ 中的大多数方法都不依赖于类型参数 ~T~.

   + *通配符和子类型*

     ~Class<?>~ 是其他 ~Class<T>~ 的公共父类，即：
     #+BEGIN_SRC java
       List<?> list = new ArrayList<Integer>();  // OK
       List<Number> list = new ArrayList<Integer>();  // ERROR
     #+END_SRC

     #+HTML: <img src="https://docs.oracle.com/javase/tutorial/figures/java/generics-wildcardSubtyping.gif">

   + *通配符捕获*

     在某些情况下，编译器会推断出通配符的类型：
     #+BEGIN_SRC java
       public class WildcardError {
         void foo(List<?> i) {
           i.set(0, i.get(0));  // ERROR
         }
       }

       // 运用通配符捕获
       public class WildcardFixed {
         void foo(List<?> i) {
           fooHelper(i);
         }

         // Helper method created so that the wildcard can be captured
         // through type inference.
         private <T> void fooHelper(List<T> l) {
           l.set(0, l.get(0));
         }
       }
     #+END_SRC

   + *使用指南*
    
     1. 使用 ~extends~ 关键字定义带有上限通配符的 ~in~ 变量
     2. 使用 ~super~ 关键字定义带有下限通配符的 ~out~ 变量
     3. 在可以使用 ~Object~ 类中定义的方法访问 ~in~ 变量的情况下，使用无界通配符
     4. 在变量即作为 ~in~ 变量也作为 ~out~ 变量的情况下，不使用通配符
** 类型擦除
  + [[https://www.cnblogs.com/wuqinglong/p/9456193.html][Java 泛型类型擦除以及类型擦除带来的问题 - 蜗牛大师 - 博客园]]

  问：既然存在类型擦除，那么泛型的类型检查是怎样完成的呢？
  答：泛型的类型检查在 *编译前* 完成

** 泛型的限制
   1. 原始数据类型不能作为泛型的类型参数
      #+BEGIN_SRC java
        List<int> list;  // ERROR
      #+END_SRC

   2. 无法创建类型参数的实例
      #+BEGIN_SRC java
        public static <E> void append(List<E> list) {
          E elem = new E();  // compile-time error
          list.add(elem);
        }
      #+END_SRC

      但是可以利用反射创建实例：
      #+BEGIN_SRC java
        public static <E> void append(List<E> list, Class<E> cls) throws Exception {
          E elem = cls.newInstance();   // OK
          list.add(elem);
        }
      #+END_SRC
      
   3. 无法声明类型为类型参数的静态字段
      #+BEGIN_SRC java
        public class MobileDevice<T> {
          private static T os;  // ERROR
        }
      #+END_SRC

   4. 无法使用类型参数进行强制类型转换或用于关键字 ~instanceof~
      #+BEGIN_SRC java
        public static <E> void rtti(List<E> list) {
          if (list instanceof ArrayList<Integer>) {  // compile-time error
            // ...
          }
        }
      #+END_SRC

      无界通配符可以用在这里判断是否为 List：
      #+BEGIN_SRC java
        public static void rtti(List<?> list) {
          if (list instanceof ArrayList<?>) {  // OK; instanceof requires a reifiable type
            // ...
          }
        }
      #+END_SRC

   5. 无法创建、捕获或抛出类型参数的对象
     
      泛型类不能直接或间接扩展 Throwable 类：
      #+BEGIN_SRC java
        // Extends Throwable indirectly
        class MathException<T> extends Exception { /* ... */ }    // compile-time error

        // Extends Throwable directly
        class QueueFullException<T> extends Throwable { /* ... */ // compile-time error
      #+END_SRC

      无法捕获类型参数的实例：
      #+BEGIN_SRC java
        public static <T extends Exception, J> void execute(List<J> jobs) {
          try {
            for (J job : jobs)
              // ...
              } catch (T e) {   // compile-time error
            // ...
          }
        }
      #+END_SRC

      但是，可以在 throws 子句中使用类型参数：
      #+BEGIN_SRC java
        class Parser<T extends Exception> {
          public void parse(File file) throws T {     // OK
            // ...
          }
        }
      #+END_SRC

   6. 无法重载每个重载的形式参数类型擦除到相同原始类型的方法
      #+BEGIN_SRC java
        public class Example {
          public void print(Set<String> strSet) { }
          public void print(Set<Integer> intSet) { }
        }
      #+END_SRC

      上面两个方法在类型擦除后具有相同的签名，因此会造成编译出错。

   7. 无法创建类型参数的数组
      #+BEGIN_SRC java
        List<Integer>[] arrayOfLists = new List<Integer>[2];  // compile-time error
      #+END_SRC

      可以参考 [[https://github.com/exsourcode/jdk8u-jdk/blob/master/src/share/classes/java/util/ArrayList.java][jdk8u-jdk/ArrayList.java at master · exsourcode/jdk8u-jdk]]

   8. 不能实例化参数化类型的数组：
      #+BEGIN_SRC java
        Pair<String>[] table = new Pair<>[10]; // error
      #+END_SRC

   9. 运行时类型查询（反射）只能获取原始类型（类型擦除之后）

* Lambda 表达式
** Lambda 表达式语法
   #+BEGIN_SRC java
     (parameters) -> expression  // expression 的结果即为返回值
     (parameters) -> { satements; }  // return 语句返回值，没有返回 void
   #+END_SRC

   使用时需要注意分清 *表达式* 和 *语句*.

** Lambda 表达式的使用场景
   Lambda 表达式可以用于 *函数式接口*, 函数式接口的定义如下：

   + *函数式接口* 就是只定义了一个 *抽象方法* 的接口

   哪怕接口内部定义了很多的 *默认方法*, 但只要只定义了一个 *抽象方法*, 那么那个接口就是 *函数式接口*.

   某种程度上，Lambda 表达式就是该 *函数式接口* 的一个具体实现的实例。

   *函数式接口* 中的抽象方法的签名基本上就是 Lambda 表达式的签名，因此把这种抽象方法叫做 *函数描述符*.

   对于 *函数式接口*, 可以用 ~@FunctionalInterface~ 注解类标识，当该接口存在多个抽象方法时，编译时编译器将返回一个错误信息。

   一些预提供的函数式接口： [[https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html][Package java.util.function]].

   类似 ~DoubleConsumer~ 的函数式接口，通过提供确定类型的参数，避免装箱拆箱的消耗。

   同时，借助 *类型推断*, 部分情况下你可以省略显示的类型声明：
   #+BEGIN_SRC java
     Comparator<Apple> c = (Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight());
     Comparator<Apple> c = (a1, a2) -> a1.getWeight().compareTo(a2.getWeight());
   #+END_SRC

   只有一个参数的时候还可以去掉参数括号：
   #+BEGIN_SRC java
     Predicate<String> p = s -> list.add(s);
   #+END_SRC

** Lambda 表达式使用局部变量
   Lambda 表达式内部可以自由的使用 *实例变量* 和 *静态变量*, 但只能使用显示声明为 ~final~ 的局部变量
   或事实上为的 ~final~ 的局部变量（声明后不再修改）。

   同时，表达式内部也不能直接修改引用的变量，但可以通过包装的方式修改变量：
   #+BEGIN_SRC java
     x -> x = x + 1;  // error
     x -> x.add(1);   // ok
   #+END_SRC

** 方法引用
   |------------------------------+--------------------------------------|
   | 方法类型                     | 方法引用例子                         |
   |------------------------------+--------------------------------------|
   | 静态方法                     | ContainingClass::staticMethodName    |
   | 特定对象的实例方法           | containingObject::instanceMethodName |
   | 特定类型的任意对象的实例方法 | ContainingType::methodName           |
   | 构造方法                     | ClassName::new                       |
   |------------------------------+--------------------------------------|

   方法引用就是让你根据已有的方法来创建 Lambda 表达式，可以看做仅仅调用特定方法的 Lambda 的一种快捷写法。

** 复合 Lambda 表达式
   + *比较器复合 - java.util.Comparator<T>*

     接口文档： [[https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html][Interface Comparator<T>]]

     通过静态方法 ~Comparator.comparing~ 提取用于比较的键值的 ~Function~ 来返回一个 ~Comparator~:
     #+BEGIN_SRC java
       Comparator<Apple> c = Comparator.comparing(Apple::getWeight);
     #+END_SRC

     *逆序：*
     #+BEGIN_SRC java
       list.sort(Comparator.comparing(Apple::getWeight).reversed())
     #+END_SRC

     *比较器链：*
     #+BEGIN_SRC java
       list.sort(Comparator.comparing(Apple::getWeight)
                 .reversed()
                 .thenComparing(Apple::getCountry));

     #+END_SRC

     如果两个对象用第一个 ~Comparator~ 比较之后是一样的，就提供第二个 ~Comparator~.

   + *谓词复合 - java.util.function.Predicate<T>*

     接口文档： [[https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html][Interface Predicate<T>]]
    
     可以通过谓词接口的 negate、and 和 or 方法构建复杂的谓词，比如说：
     #+BEGIN_SRC java
       a.negate().or(b).and(c);
     #+END_SRC

     等价于：
     #+BEGIN_SRC java
       (!a || b) && c
     #+END_SRC

   + *函数复合 - java.util.function.Function<T, R>*

     接口文档： [[https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html][Interface Function<T,R>]]

     ~Function~ 接口提供的默认方法 ~andThen~ 和 ~compose~ 可以组合不同的函数：
     #+BEGIN_SRC java
       Function<Integer, Integer> f = x -> x + 1;
       Function<Integer, Integer> g = x -> x * 2;

       Function<Integer, Integer> gf = f.andThen(g);  // g(f(x))
       Function<Integer, Integer> fg = f.compose(g);  // f(g(x))
     #+END_SRC

* Java Import
** 导入名称
   使用外部类的两种方式：
   + import 导入命名空间， 然后直接使用类名
   + 全名 - 包名.类名

   *NOTE:* java.lang 会自动导入， 因此可以直接使用类名

   *PS:* javax 开头的函数库曾经是扩展， 后来虽然并入标准库， 但是为了兼容程序没有修改名称。
  
** static import
   使用 static import 的作用是 *少打一些字*.

   如：
   #+BEGIN_SRC java
     import static java.lang.System.out;
     import static java.lang.Math.*;

     class WithStatic {
       public static void main(String[] args) {
         out.println("sqrt" + sqrt(2.0));
       }
     }
   #+END_SRC

   可以看到， 省略了前面的 *名称空间.类*, 直接使用导入的 *静态成员*.
 
* 块作用域
  块作用域是由大括号确定的作用域：
  #+BEGIN_SRC java
    public class Test {
      public static void main(String[] args) {
        {
          int num = 10;  // ok
        }

        int num = 10;    // ok

        {
          int num = 10;  // error
        }
      }
    }
  #+END_SRC

* 注意事项
  + Java 没有无符号数
  + 定义 ~float~ 的数值需要加 ~f~ 后缀， 如： ~float f = 32.45f~, 否则小数会默认当做 ~double~ 处理
  + 隐式类型转换只允许在不会有数据丢失的情况下进行， 即: ~int~ 不能和 ~float~ 直接转换。
    也不能使用类似 ~byte x = 128~ 的语句。
  + 除此之外的类型的变量都是对一个对象的 *引用*, *对象* 实例保存在可回收垃圾的堆上
  + 所有引用变量的大小都一样， 不一样的是内存中的实例大小
  + 引用变量的空值为 ~null~
  + 和 ~Python~ 一样， 当一个实例对象的引用数为 0 时， 这个对象就可以被回收。
  + 实例对象通常通过 ~new~ 创建， 这会在内存中创建唯一的对象实例
  + 数组也是对象， 数组名是引用类型变量
  + 注意引用类型数组的初始化：
    #+BEGIN_SRC java
      Dog[] dog;  // 声明数组 dog
      dog = new Dog[7];  // 为 dog 分配内存

      for (int i = 0; i < 7; ++i) {
        dog[i] = new Dog();  // 为数组元素分配内存
      }
    #+END_SRC
  + String 不是 Java 关键字
  + 没有初始化的数值类型（包括 char） 默认为 0, 布尔类型默认为 false, 引用默认为 null.
  + 局部变量没有默认值， 使用前必须初始化
  + 可以使用 == 来判断两个主数据类型是否相对， 会判断两个引用是否引用同一个对象
  + ~switch~ 语句支持的类型为： 原始数据类型 byte, short, char, int 及对应的包装类；字符串 ~String~ 和 枚举 ~Enum~.
  + Java 方法签名值包括方法名称和参数类型，不包括返回值类型及访问修饰符。
  + 根据 Java 语言规范，main 方法必须声明为 public
  + 字符 $ 在 Java 中虽然合法，但是只用在 Java 编译器工具生成的名字中
  + const 是 Java 保留的关键字，但目前并没有使用，因此必须使用 final 关键字定义常量
  + Java 不使用逗号运算符
  + 格式化字符串时，s 转换符对于实现了 Formattable 接口的对象会调用 formatTo 方法，否则调用 toString
  + 命令行参数中，程序名并没有保存在 args 数组中
  + 打印二维数组 Arrays.deepToString()
  + 编译器在编译源文件是不检查目录结构，但是不合适的目录结构会导致找不到类
  + 未指定访问修饰符的域可以被包内所有成员访问
  + 覆盖方法时，子类方法不能低于超类方法的可见性
  + 将超类转换为子类之前应该用 instanceof 进行检查
  + null instanceof type 返回 false
  + 抄写类可以包含具体数据和具体方法
  + 默认访问级别对子类不可见
  + 比较枚举值使用 == 就可以了
  + 接口中的所有方法自动为 public
  + 接口中的域自动设为 public static final
  + 伴随类 - Path/Paths，伴随类包含静态方法
  + 默认方法冲突 - 超类优先，接口冲突就必须手动覆盖
  + 所有数组类型都有一个 public 的 clone 方法，可以建立一个新数组，包含源数组所有元素的副本
  + 函数式接口注释 - FunctionalInterface
  + 非静态内部类不能有 static 方法
  + 内部类的所有静态域都必须是 final
  + 局部类不能用访问修饰符修饰
  + 内部类访问的局部变量必须为事实上的 final
  + 静态内部类可以有静态域和静态方法
  + 声明在接口中的内部类自动成为 static 和 public 类
  + user.dir 是 java 运行环境的启动路径
  + 默认类路径包含当前目录，设置后就不一定了

