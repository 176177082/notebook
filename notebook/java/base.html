<!DOCTYPE html>
<html lang="zh-CN">
<head>
<!-- 2021-01-09 周六 19:46 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Java 基础</title>
<meta name="generator" content="Org mode">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="https://rgb-24bit.github.io/blog/misc/style.css">
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-125860001-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-125860001-1');
</script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="https://rgb-24bit.github.io/notebook/"> UP </a>
 |
 <a accesskey="H" href="https://rgb-24bit.github.io"> HOME </a>
</div><div id="content">
<h1 class="title">Java 基础</h1>
<div id="table-of-contents">
<h2>&#30446;&#24405;</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org2be1ecb">1. 数据类型</a></li>
<li><a href="#orge35a837">2. 数组相关</a>
<ul>
<li><a href="#org18baee9">2.1. 数组的类型</a></li>
<li><a href="#orgd855e47">2.2. 数组的克隆</a></li>
</ul>
</li>
<li><a href="#org77ae43d">3. 面向对象</a>
<ul>
<li><a href="#org54e0df6">3.1. 继承</a></li>
<li><a href="#orgdf59c38">3.2. 抽象</a></li>
<li><a href="#org0c2ca7a">3.3. 封装</a></li>
<li><a href="#orgbb90523">3.4. 多态</a></li>
</ul>
</li>
<li><a href="#org0be2904">4. 注解</a>
<ul>
<li><a href="#orgdedc1a2">4.1. 简单使用</a></li>
<li><a href="#orgafdf710">4.2. RetentionPolicy</a></li>
<li><a href="#orge5a0791">4.3. 通过反射获取</a></li>
</ul>
</li>
<li><a href="#org1867d9e">5. 枚举</a></li>
<li><a href="#org8d79c3b">6. 异常</a>
<ul>
<li><a href="#org73aa6e2">6.1. 注意事项</a></li>
</ul>
</li>
<li><a href="#org9a6c47b">7. 术语</a></li>
<li><a href="#org46a6f99">8. 其他</a></li>
<li><a href="#orgc442bd0">9. Tips</a></li>
</ul>
</div>
</div>

<div id="outline-container-org2be1ecb" class="outline-2">
<h2 id="org2be1ecb"><span class="section-number-2">1</span> 数据类型</h2>
<div class="outline-text-2" id="text-1">
<p>
Java 中存在 8 种 Primitive Type，它们的取值范围为：
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-right">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">类型</th>
<th scope="col" class="org-right">位数</th>
<th scope="col" class="org-left">值域</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">boolean</td>
<td class="org-right">Java 虚拟机决定</td>
<td class="org-left">true or false</td>
</tr>

<tr>
<td class="org-left">char</td>
<td class="org-right">16</td>
<td class="org-left">0 ~ 65535</td>
</tr>

<tr>
<td class="org-left">byte</td>
<td class="org-right">8</td>
<td class="org-left">-128 ~ 127</td>
</tr>

<tr>
<td class="org-left">short</td>
<td class="org-right">16</td>
<td class="org-left">-32768 ~ 32767</td>
</tr>

<tr>
<td class="org-left">int</td>
<td class="org-right">32</td>
<td class="org-left">-2147483648 ~ 2147483647</td>
</tr>

<tr>
<td class="org-left">long</td>
<td class="org-right">64</td>
<td class="org-left">-很大 ~ +很大</td>
</tr>

<tr>
<td class="org-left">float</td>
<td class="org-right">32</td>
<td class="org-left">范围规模可变</td>
</tr>

<tr>
<td class="org-left">double</td>
<td class="org-right">64</td>
<td class="org-left">范围规模可变</td>
</tr>
</tbody>
</table>

<p>
Java 中布尔类型支持部分运算符操作，也就是布尔代数相关的操作：
</p>
<div class="org-src-container">
<pre class="src src-java">System.out.println(<span class="org-constant">true</span> | <span class="org-constant">false</span>);
System.out.println(<span class="org-constant">true</span> &amp; <span class="org-constant">false</span>);
System.out.println(<span class="org-constant">true</span> ^ <span class="org-constant">false</span>);
</pre>
</div>

<p>
Java 中 byte 进行移位运算时会自动升为 int，这有可能会导致一些意料之外的结果，参考：
</p>
<ul class="org-ul">
<li><a href="https://stackoverflow.com/questions/3948220/behaviour-of-unsigned-right-shift-applied-to-byte-variable#">java - Behaviour of unsigned right shift applied to byte variable - Stack Overflow</a></li>
</ul>
</div>
</div>

<div id="outline-container-orge35a837" class="outline-2">
<h2 id="orge35a837"><span class="section-number-2">2</span> 数组相关</h2>
<div class="outline-text-2" id="text-2">
<p>
数组的声明和初始化方式都存在多种：
</p>
<div class="org-src-container">
<pre class="src src-java"><span class="org-comment-delimiter">// </span><span class="org-comment">&#22768;&#26126;&#25968;&#32452;</span>
<span class="org-type">dataType</span>[] <span class="org-variable-name">arrayRefVar</span>;   <span class="org-comment-delimiter">// </span><span class="org-comment">&#39318;&#36873;&#30340;&#26041;&#27861;</span>
<span class="org-type">dataType</span> <span class="org-variable-name">arrayRefVar</span>[];   <span class="org-comment-delimiter">// </span><span class="org-comment">&#25928;&#26524;&#30456;&#21516;&#65292;&#20294;&#19981;&#26159;&#39318;&#36873;&#26041;&#27861;</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">&#21019;&#24314;&#25968;&#32452;&#23454;&#20363;</span>
<span class="org-type">dataType</span>[] <span class="org-variable-name">arrayRefVar</span> = <span class="org-keyword">new</span> <span class="org-type">dataType</span>[arraySize];
<span class="org-type">dataType</span>[] <span class="org-variable-name">arrayRefVar</span> = {value0, value1, ..., valuek};  <span class="org-comment-delimiter">// </span><span class="org-comment">&#21482;&#33021;&#22312;&#22768;&#26126;&#30340;&#21516;&#26102;&#20351;&#29992;</span>
<span class="org-type">dataType</span>[] <span class="org-variable-name">arrayRefVar</span> = <span class="org-keyword">new</span> <span class="org-type">dataType</span>[] {value0, value1, ..., valuek};
</pre>
</div>

<p>
数组对象除了拥有 <code>Object</code> 对象的所有方法以外，还拥有 <code>length</code> 字段和 <code>T[] clone()</code> 方法。
</p>

<p>
需要注意的是，Java 数组会保存存储的元素的类型信息，虽然父类型的数组引用可以引用子类型的数组的实例，而且往该引用中存入父类型实例的操作可以通过编译器的检查，但是会在运行期间抛出异常。
</p>

<p>
也就是说，下面的写法能够通过编译器的检查，但是会在运行期间抛出异常：
</p>
<div class="org-src-container">
<pre class="src src-java"><span class="org-type">Child</span>[] <span class="org-variable-name">arr</span> = <span class="org-keyword">new</span> <span class="org-type">Child</span>[10];
<span class="org-type">Parent</span>[] <span class="org-variable-name">parr</span> = arr;
parr[0] = <span class="org-keyword">new</span> <span class="org-type">Parent</span>();
</pre>
</div>
</div>

<div id="outline-container-org18baee9" class="outline-3">
<h3 id="org18baee9"><span class="section-number-3">2.1</span> 数组的类型</h3>
<div class="outline-text-3" id="text-2-1">
<ul class="org-ul">
<li><b>Primitive arrays</b> are instance of Object and self type. e.g. int[] is type of Object and int[]. Both comparison returns true.</li>
<li><b>Object arrays</b> are types of Object, Object array, classtype array, parent class type array. e.g. Integer[] is type of Object,
Object[], Integer[] and Number[] (Integer extends Number).</li>
</ul>

<p>
也就是说，int[] 仅仅只是 int[] 和 Object 的实例，而 int[][] 才是 Object[] 的实例，当 int[] 作为 Arrays.asList 方法的参数时，将其类型擦除为 Object 后，Object 就是 int[] 了，而不是我们想要的 int.
</p>
</div>
</div>

<div id="outline-container-orgd855e47" class="outline-3">
<h3 id="orgd855e47"><span class="section-number-3">2.2</span> 数组的克隆</h3>
<div class="outline-text-3" id="text-2-2">
<p>
数组对象的 <code>clone()</code> 方法会返回一个新的数组对象，这个数组对象包含和原数组中相同的元素。
</p>

<p>
对于 Primitive 数据类型的数组来说，由于数组元素是值，因此，克隆出来的数组和原数组互不干扰。
</p>

<p>
对于其他类型的数组，克隆出来的数组和原数组中的对象是一样的，修改一个就会影响另一个。
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="org-type">int</span>[] <span class="org-variable-name">a</span> = {1, 2, 3};
<span class="org-type">int</span>[] <span class="org-variable-name">b</span> = a.clone();

System.out.println(a == b ? <span class="org-string">"Same Instance"</span>:<span class="org-string">"Different Instance"</span>);
<span class="org-comment-delimiter">//</span><span class="org-comment">Outputs different instance</span>

System.out.println(myDogs[0] == myDogsClone[0] ? <span class="org-string">"Same"</span>:<span class="org-string">"Different"</span>);
System.out.println(myDogs[1] == myDogsClone[1] ? <span class="org-string">"Same"</span>:<span class="org-string">"Different"</span>);
System.out.println(myDogs[2] == myDogsClone[2] ? <span class="org-string">"Same"</span>:<span class="org-string">"Different"</span>);
System.out.println(myDogs[3] == myDogsClone[3] ? <span class="org-string">"Same"</span>:<span class="org-string">"Different"</span>);
<span class="org-comment-delimiter">//</span><span class="org-comment">Outputs Same (4 Times)</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org77ae43d" class="outline-2">
<h2 id="org77ae43d"><span class="section-number-2">3</span> 面向对象</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-org54e0df6" class="outline-3">
<h3 id="org54e0df6"><span class="section-number-3">3.1</span> 继承</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Java 中，子类可以覆盖父类的 <b>实例</b> 方法，覆盖父类方法时需要注意：
</p>
<ol class="org-ol">
<li>方法在覆盖时的可见性不能 <b>低于</b> 父类，可以高于</li>
<li>子类方法抛出的异常不能比父类的更通用，如果父类方法没有抛出异常那么子类的也不能抛出</li>
</ol>
</div>
</div>

<div id="outline-container-orgdf59c38" class="outline-3">
<h3 id="orgdf59c38"><span class="section-number-3">3.2</span> 抽象</h3>
<div class="outline-text-3" id="text-3-2">
<p>
使用抽象类和抽象方法时需要注意：
</p>
<ol class="org-ol">
<li>抽象类与抽象方法使用关键字 abstract 修饰</li>
<li>抽象类不能被实例化</li>
<li>抽象方法在具体类中必须被实现，但可以在抽象类中传递</li>
<li>抽象方法只能在抽象类中定义</li>
<li>抽象方法没有方法体</li>
</ol>

<p>
使用接口时需要注意：
</p>
<ol class="org-ol">
<li>接口不能被实例化， 但是可以被实现</li>
<li>接口没有构造方法</li>
<li>接口中所有的方法默认(必须)为 <code>public abstract</code></li>
<li>接口中的字段默认都是 <code>static final</code></li>
</ol>
</div>
</div>

<div id="outline-container-org0c2ca7a" class="outline-3">
<h3 id="org0c2ca7a"><span class="section-number-3">3.3</span> 封装</h3>
<div class="outline-text-3" id="text-3-3">
<p>
私有字段可以在内部直接访问，不管是不是当前实例：
</p>
<div class="org-src-container">
<pre class="src src-java"><span class="org-keyword">public</span> <span class="org-keyword">class</span> <span class="org-type">TestP</span> {
  <span class="org-keyword">private</span> <span class="org-type">int</span> <span class="org-variable-name">val</span> = 10;

  <span class="org-keyword">public</span> <span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">main</span>(<span class="org-type">String</span>[] <span class="org-variable-name">args</span>) {
    <span class="org-type">TestP</span> <span class="org-variable-name">t</span> = <span class="org-keyword">new</span> <span class="org-type">TestP</span>();
    t.val = 100;
    System.out.println(t.val);
  }
}
</pre>
</div>

<p>
私有类只是针对内部类而言的，外部类没有这种说法。
</p>
</div>
</div>

<div id="outline-container-orgbb90523" class="outline-3">
<h3 id="orgbb90523"><span class="section-number-3">3.4</span> 多态</h3>
<div class="outline-text-3" id="text-3-4">
<p>
方法的重载有时会和多态搞混，但是需要明白的是，方法的重载和多态并没有关系：
</p>
<ul class="org-ul">
<li>重载是指两个方法名称相同但方法签名不同</li>
<li>多态是可以利用父类型的引用引用子类型的实例</li>
</ul>

<p>
对于重载来说：
</p>
<ul class="org-ul">
<li>方法签名由参数类型与顺序决定</li>
<li>不能只修改返回值类型</li>
<li>可以更改存取权限</li>
</ul>

<p>
对于多态来说：
</p>
<ul class="org-ul">
<li>编译器根据 <b>引用类型</b> 来判断有哪些 <code>method</code> 可以调用，而不是 <code>Object</code> 确实的类型</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org0be2904" class="outline-2">
<h2 id="org0be2904"><span class="section-number-2">4</span> 注解</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-orgdedc1a2" class="outline-3">
<h3 id="orgdedc1a2"><span class="section-number-3">4.1</span> 简单使用</h3>
<div class="outline-text-3" id="text-4-1">
<p>
自定义注解：
</p>
<div class="org-src-container">
<pre class="src src-java"><span class="org-keyword">@interface</span> <span class="org-type">ClassPreamble</span> {
  <span class="org-type">String</span> <span class="org-function-name">author</span>();
  <span class="org-type">String</span> <span class="org-function-name">date</span>();
  <span class="org-type">int</span> <span class="org-function-name">currentRevision</span>() <span class="org-keyword">default</span> 1;
  <span class="org-type">String</span> <span class="org-function-name">lastModified</span>() <span class="org-keyword">default</span> <span class="org-string">"N/A"</span>;
  <span class="org-type">String</span> <span class="org-function-name">lastModifiedBy</span>() <span class="org-keyword">default</span> <span class="org-string">"N/A"</span>;
  <span class="org-comment-delimiter">// </span><span class="org-comment">Note use of array</span>
  <span class="org-type">String</span>[] <span class="org-function-name">reviewers</span>();
}
</pre>
</div>

<p>
使用注解：
</p>
<div class="org-src-container">
<pre class="src src-java"><span class="org-c-annotation">@ClassPreamble</span> (
    author = <span class="org-string">"John Doe"</span>,
    date = <span class="org-string">"3/17/2002"</span>,
    currentRevision = 6,
    lastModified = <span class="org-string">"4/12/2004"</span>,
    lastModifiedBy = <span class="org-string">"Jane Doe"</span>,
    <span class="org-comment-delimiter">// </span><span class="org-comment">Note array notation</span>
    reviewers = {<span class="org-string">"Alice"</span>, <span class="org-string">"Bob"</span>, <span class="org-string">"Cindy"</span>}
)
<span class="org-keyword">public</span> <span class="org-keyword">class</span> <span class="org-type">Generation3List</span> <span class="org-keyword">extends</span> <span class="org-type">Generation2List</span> {
  <span class="org-comment-delimiter">// </span><span class="org-comment">class code goes here</span>
}
</pre>
</div>

<p>
对定义自己的注解类很有帮助的包：
</p>
<ul class="org-ul">
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/package-summary.html">java.lang.annotation</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgafdf710" class="outline-3">
<h3 id="orgafdf710"><span class="section-number-3">4.2</span> RetentionPolicy</h3>
<div class="outline-text-3" id="text-4-2">
<p>
RetentionPolicy 共定义了三种反射策略：
</p>
<ul class="org-ul">
<li>CLASS - 注解由编译器记录在类文件中，但 VM 在运行时无需保留</li>
<li>RUNTIME - 注解由编译器记录在类文件中，并在运行时由 VM 保留，因此可以通过反射方式读取它们</li>
<li>SOURCE - 注解被编译器丢弃</li>
</ul>

<p>
因此，只有反射策略为 RUNTIME 的才能通过反射的方式读取。
</p>
</div>
</div>

<div id="outline-container-orge5a0791" class="outline-3">
<h3 id="orge5a0791"><span class="section-number-3">4.3</span> 通过反射获取</h3>
<div class="outline-text-3" id="text-4-3">
<p>
Spring 用多了给了我一种 Java 默认支持组合注解的错觉，看了源码后才发现，Spring 解析注解时会不断解析注解上的注解。而在实际的使用中，通过 <code>Class.getAnnotation</code> 方法只能获取到指定类型的注解，如果该注解被定义为 <code>@Inherited</code> 的，那么，还会寻找该类的父类。
</p>

<p>
但是，不会自动的寻找注解上的注解。
</p>
</div>
</div>
</div>

<div id="outline-container-org1867d9e" class="outline-2">
<h2 id="org1867d9e"><span class="section-number-2">5</span> 枚举</h2>
<div class="outline-text-2" id="text-5">
<p>
枚举类型的声明可以在 <b>类外部</b> 或 <b>类内部</b>, 但是不能在 <b>方法内部</b>.
</p>

<p>
枚举类型的简单声明和使用：
</p>
<div class="org-src-container">
<pre class="src src-java"><span class="org-keyword">public</span> <span class="org-keyword">enum</span> <span class="org-type">Members</span> {<span class="org-variable-name">JOB</span>, <span class="org-variable-name">ALICE</span>, <span class="org-variable-name">PHIL</span>}

<span class="org-type">Members</span> <span class="org-variable-name">member</span> = <span class="org-constant">Members</span>.ALICE;  <span class="org-comment-delimiter">// </span><span class="org-comment">default is null</span>
</pre>
</div>

<p>
枚举类型自动继承 <code>java.lang.Enum</code>, 即： 所有枚举类型都是 <code>Enum</code> 的子类。
</p>

<p>
不同枚举变量之间的比较可以用 <code>==</code> 或 <code>equals</code>, 但 <code>==</code> 是一个更好的方式。
</p>

<p>
枚举类型中定义的的每个值都是该枚举类型的 <b>实例</b>, 可以为这些实例定义属性和方法。
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="org-keyword">public</span> <span class="org-keyword">enum</span> <span class="org-type">Names</span> {
  <span class="org-function-name">JERRY</span>(<span class="org-string">"lead guitar"</span>) {
    <span class="org-keyword">public</span> <span class="org-type">String</span> <span class="org-function-name">sings</span>() {
      <span class="org-keyword">return</span> <span class="org-string">"JERRY"</span>;
    }
  },

  BOBBY(<span class="org-string">"bass"</span>);

  <span class="org-keyword">private</span> <span class="org-type">String</span> <span class="org-variable-name">instrument</span>;

  Names(<span class="org-type">String</span> <span class="org-variable-name">instrument</span>) {
    <span class="org-keyword">this</span>.instrument = instrument;
  }

  <span class="org-keyword">public</span> <span class="org-type">String</span> <span class="org-function-name">getInstrument</span>() {
    <span class="org-keyword">return</span> <span class="org-keyword">this</span>.instrument;
  }

  <span class="org-keyword">public</span> <span class="org-type">String</span> <span class="org-function-name">sings</span>() {
    <span class="org-keyword">return</span> <span class="org-string">"Default"</span>;
  }
}
</pre>
</div>

<p>
<code>BOBBY("bass")</code> 调用构造函数 <code>Names</code>.
</p>

<p>
如下代码定义之自己的 <code>sings</code> 方法。
</p>
<div class="org-src-container">
<pre class="src src-java">JERRY(<span class="org-string">"lead guitar"</span>) {
  <span class="org-keyword">public</span> <span class="org-type">String</span> <span class="org-function-name">sings</span>() {
    <span class="org-keyword">return</span> <span class="org-string">"JERRY"</span>;
  }
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-java"><span class="org-keyword">for</span> (<span class="org-type">Names</span> <span class="org-variable-name">name</span> : Names.value()) {  <span class="org-comment-delimiter">// </span><span class="org-comment">Enum.value()</span>
  System.out.println(name.sing());
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org8d79c3b" class="outline-2">
<h2 id="org8d79c3b"><span class="section-number-2">6</span> 异常</h2>
<div class="outline-text-2" id="text-6">
<p>
异常分为：检查型异常和非检查型（运行时）异常。
</p>

<p>
其中，如果抛出的异常类型为 <b>检查型异常</b>, 那么就必需在方法声明时通过 <code>throws</code> 声明可能抛出的异常，同时在调用该方法时，使用 <code>try/catch</code> 或 <code>ducking</code> 处理异常。
</p>

<p>
如果抛出的异常类型为 <b>非检查型异常</b>, 那么可以不声明或包含在 <code>try/catch</code> 代码块中。当然，做了也没影响。
</p>

<p>
其中， 非检查型异常是 <code>RuntimeException</code> 类型或其子类类型的异常， 而检查型异常是除了 <code>RuntimeException</code> 以外的所有异常。
</p>

<p>
其中， <code>RuntimeException</code> 也是 <code>Exception</code> 的子类， 不过比较特殊。
</p>

<p>
使用 <code>finally</code> 代码块来存放无论如何都要执行的部分。 既是在 <code>try/catch</code> 代码块中存在 <code>return</code> 语句， <code>finally</code> 代码块也依然会执行！流程会跳到 <code>finally</code> 然后在回到 <code>return</code> 语句。finally 子句的返回值也会覆盖原本的返回值。
</p>

<p>
通过如下方式声明多个异常：
</p>
<div class="org-src-container">
<pre class="src src-java"><span class="org-keyword">public</span> <span class="org-type">int</span> <span class="org-function-name">function</span>() <span class="org-keyword">throws</span> <span class="org-type">IOException</span>, <span class="org-type">InterruptedException</span> {
  <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
}
</pre>
</div>

<p>
通过多个 <code>catch</code> 块捕获多个异常， 也可以通过多个异常的父类同时捕获多个异常（声明异常也一样， 通过异常父类同时声明多个异常）
</p>

<p>
异常也是对象， 因此也支持多态， 所以应该：
</p>
<ul class="org-ul">
<li>以异常的父型来声明会抛出的远程</li>
<li>以所抛出的异常父型来捕获异常</li>
<li>可以用 <code>Exception</code> 捕获所有异常， 但不代表应该这么做</li>
<li>为每个需要单独处理的异常编写不同的 catch 块</li>
<li>有多个 catch 块时， 要从小排到大（子类到父类）， 否则会无法通过编译</li>
</ul>

<p>
如果不想处理异常， 那么只需要在方法声明时 <b>再次 throws</b> 可能的异常即可：
</p>
<div class="org-src-container">
<pre class="src src-java"><span class="org-keyword">public</span> <span class="org-type">int</span> <span class="org-function-name">functionA</span>() <span class="org-keyword">throws</span> <span class="org-type">Exception</span> {
  <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
}

<span class="org-keyword">public</span> <span class="org-type">int</span> <span class="org-function-name">functionB</span>() <span class="org-keyword">throws</span> <span class="org-type">Exception</span> {  <span class="org-comment-delimiter">// </span><span class="org-comment">&#20877;&#27425; throws</span>
  functionA();
}
</pre>
</div>

<p>
如果连 <code>main</code> 函数也 duck 调异常， 那么当遇到异常时， Java 虚拟机会当场去世。
</p>

<p>
因此， 对于 <b>检查型异常</b>, 有两种处理方式：
</p>
<ol class="org-ol">
<li>使用 <code>try/catch</code> 处理异常</li>
<li>使用 <code>duck</code> 逃避异常</li>
</ol>

<p>
异常处理规则：
</p>
<ol class="org-ol">
<li>catch 与 finally 不能没有 try</li>
<li>try 与 catch 之间不能有程序</li>
<li>try 一定要有 catch 或 finally</li>
<li>只带有 finally 的 try 必须声明异常 - duck</li>
</ol>

<p>
异常的使用规则：
</p>
<ul class="org-ul">
<li>早抛出晚捕获</li>
</ul>

<p>
Throwable 是所有异常的父类，它拥有的构造函数和方法：
</p>
<div class="org-src-container">
<pre class="src src-java">Throwable()
Throwable(<span class="org-type">String</span> <span class="org-variable-name">message</span>);
<span class="org-type">String</span> <span class="org-function-name">getMessage</span>();
</pre>
</div>

<p>
创建自己的异常可以通过如下方式实现：
</p>
<div class="org-src-container">
<pre class="src src-java"><span class="org-keyword">public</span> <span class="org-keyword">class</span> <span class="org-type">MyException</span> <span class="org-keyword">extends</span> <span class="org-type">Exception</span> {
  <span class="org-keyword">public</span> <span class="org-function-name">MyException</span>() {}
  <span class="org-keyword">public</span> <span class="org-function-name">MyException</span>(<span class="org-type">String</span> <span class="org-variable-name">message</span>) {
    <span class="org-keyword">super</span>(message);
  }
}
</pre>
</div>

<p>
捕获多个异常是异常变量隐含为 final 变量：
</p>
<div class="org-src-container">
<pre class="src src-java"><span class="org-keyword">catch</span> (E1 | E2 e)
</pre>
</div>

<p>
可以在创建异常时指定导致该异常的原因，形成异常链：
</p>
<div class="org-src-container">
<pre class="src src-java"><span class="org-keyword">catch</span> (<span class="org-type">Exception</span> <span class="org-variable-name">e</span>) {
  <span class="org-keyword">throws</span> <span class="org-keyword">new</span> <span class="org-type">Exception</span>(e);
}
</pre>
</div>

<p>
可以通过如下方式解耦 finally 和 catch：
</p>
<div class="org-src-container">
<pre class="src src-java"><span class="org-keyword">try</span> {
  <span class="org-keyword">try</span> {} <span class="org-keyword">finally</span> {}
} <span class="org-keyword">catch</span> (<span class="org-type">Throwable</span> <span class="org-variable-name">e</span>) {
  e.printStackTrace();
}
</pre>
</div>

<p>
从 JDK 7 开始支持，实现 <code>AutoCloseable</code> 和 <code>CloseAble</code> 接口的对象都可以使用带资源的 try 语句。
</p>

<p>
其中 <code>io.CloseAble</code> 是 <code>lang.AutoCloseable</code> 的子接口。
</p>

<ul class="org-ul">
<li>通过 Thread.dumpStack 获取堆栈情况</li>
<li>通过 java -verbose 观察类的加载过程</li>
<li>通过 -Xlint 选项对常见问题进行检查</li>
</ul>
</div>

<div id="outline-container-org73aa6e2" class="outline-3">
<h3 id="org73aa6e2"><span class="section-number-3">6.1</span> 注意事项</h3>
<div class="outline-text-3" id="text-6-1">
<ul class="org-ul">
<li>通过 <code>catch</code> 捕获受查异常时，try 语句块中必须可能抛出该受查异常才行</li>
<li><code>Throwable</code> 同样属于受查异常</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org9a6c47b" class="outline-2">
<h2 id="org9a6c47b"><span class="section-number-2">7</span> 术语</h2>
<div class="outline-text-2" id="text-7">
<p>
向上向下转型：
</p>
<div class="org-src-container">
<pre class="src src-java"><span class="org-comment-delimiter">// </span><span class="org-comment">&#21521;&#19978;&#36716;&#22411;</span>
<span class="org-type">SuperClass</span> <span class="org-variable-name">ref</span> = <span class="org-keyword">new</span> <span class="org-type">SubClass</span>();

<span class="org-comment-delimiter">// </span><span class="org-comment">&#21521;&#19979;&#36716;&#22411;</span>
<span class="org-type">SubClass</span> <span class="org-variable-name">ref</span> = (<span class="org-type">SubClass</span>) SuperClassRef;
</pre>
</div>
</div>
</div>

<div id="outline-container-org46a6f99" class="outline-2">
<h2 id="org46a6f99"><span class="section-number-2">8</span> 其他</h2>
<div class="outline-text-2" id="text-8">
<ul class="org-ul">
<li><p>
块作用域是由大括号确定的作用域：
</p>
<div class="org-src-container">
<pre class="src src-java"><span class="org-keyword">public</span> <span class="org-keyword">class</span> <span class="org-type">Test</span> {
  <span class="org-keyword">public</span> <span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">main</span>(<span class="org-type">String</span>[] <span class="org-variable-name">args</span>) {
    {
      <span class="org-type">int</span> <span class="org-variable-name">num</span> = 10;  <span class="org-comment-delimiter">// </span><span class="org-comment">ok</span>
    }

    <span class="org-type">int</span> <span class="org-variable-name">num</span> = 10;    <span class="org-comment-delimiter">// </span><span class="org-comment">ok</span>

    {
      <span class="org-type">int</span> <span class="org-variable-name">num</span> = 10;  <span class="org-comment-delimiter">// </span><span class="org-comment">error</span>
    }
  }
}
</pre>
</div></li>
<li><code>strictfp</code> 关键字可应用于类、接口或方法。使用 <code>strictfp</code> 关键字声明一个方法时，该方法中所有的 float 和 double 表达式都严格遵守 FP-strict 的限制，符合 IEEE-754 规范。当对一个类或接口使用 <code>strictfp</code> 关键字时，该类中的所有代码，包括嵌套类型中的初始设定值和代码，都将严格地进行计算。严格约束意味着所有表达式的结果都必须是 IEEE 754 算法对操作数预期的结果，以单精度和双精度格式表示。</li>
<li>当串行化某个对象时，如果该对象的某个变量是 transient，那么这个变量不会被串行化进去</li>
<li><p>
<code>break</code> 和 <code>continue</code> 后面允许跟一个 <code>label</code>, 各自的作用为：
</p>
<ol class="org-ol">
<li>带 label 的 break 会终止指定 label 所对应的循环体，可用于跳出多层循环</li>
<li>带 label 的 continue 会跳过标记为 label 的循环体中的本次循环的执行，并执行 label 标记位置的下一个循环</li>
</ol>

<p>
参考：<a href="https://www.jianshu.com/p/7954b61bc6ee">java 中 break continue label的使用 - 简书</a>
</p></li>
</ul>
</div>
</div>

<div id="outline-container-orgc442bd0" class="outline-2">
<h2 id="orgc442bd0"><span class="section-number-2">9</span> Tips</h2>
<div class="outline-text-2" id="text-9">
<ul class="org-ul">
<li>Java 没有无符号数</li>
<li>定义 <code>float</code> 的数值需要加 <code>f</code> 后缀，如： <code>float f = 32.45f</code>, 否则小数会默认当做 <code>double</code> 处理</li>
<li>隐式类型转换只允许在不会有数据丢失的情况下进行，不能使用类似 <code>byte x = 128</code> 的语句</li>
<li>所有引用变量的大小都一样，不一样的是内存中的实例大小</li>
<li>String 不是 Java 关键字</li>
<li>没有初始化的值类型默认为 0，布尔类型默认为 false，引用默认为 null</li>
<li>根据 Java 语言规范，main 方法必须声明为 public</li>
<li>字符 $ 在 Java 中虽然合法，但是通常只用在 Java 编译器工具生成的名字中</li>
<li>const 是 Java 保留的关键字，但目前并没有使用，因此必须使用 final 关键字定义常量</li>
<li>格式化字符串时，s 转换符对于实现了 Formattable 接口的对象会调用 formatTo 方法，否则调用 toString</li>
<li>命令行参数中，程序名并没有保存在 args 数组中</li>
<li>打印二维数组 Arrays.deepToString()</li>
<li>编译器在编译源文件时不检查目录结构，但是不合适的目录结构会导致找不到类</li>
<li>未指定访问修饰符的 <code>default</code> 域可以被包内所有成员访问</li>
<li><code>null instanceof type</code> 返回 false</li>
<li>默认访问级别对子类不可见</li>
<li>比较枚举值使用 == 就可以了</li>
<li>接口中的所有方法自动为 public</li>
<li><b>接口中的域自动设为 public static final</b></li>
<li>伴随类 - Path/Paths，伴随类包含静态方法</li>
<li>默认方法冲突 - 超类优先，接口冲突就必须手动覆盖</li>
<li>函数式接口注释 - FunctionalInterface</li>
<li>非静态内部类不能有 static 方法</li>
<li>内部类的所有静态域都必须是 final</li>
<li>局部类不能用访问修饰符修饰</li>
<li>内部类访问的局部变量必须为事实上的 final</li>
<li>静态内部类可以有静态域和静态方法</li>
<li>声明在接口中的内部类自动成为 static 和 public 类</li>
<li>user.dir 是 java 运行环境的启动路径</li>
<li>默认类路径包含当前目录，设置后就不一定了</li>
<li>在使用和 Java 相关的工具的时候，常常会要求设置一些环境变量，虽然有时不设置也可以用，但是还是设置了比较好</li>
<li>声明后要使用的局部变量必须初始化，否则可以留空</li>
<li>私有内部类的方法及时是 public 的其他类即使持有内部类实例也无法访问方法</li>
<li>理解：迭代器 Iterator 位于两个元素之间</li>
<li>自定义集合类是可以继承 AbstractXXX</li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
版权声明：本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
<div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_shortname = 'rgb-24bit';
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
</div>
</body>
</html>
