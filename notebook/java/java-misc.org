#+TITLE:      Java Misc

* 目录                                                    :TOC_4_gh:noexport:
- [[#spi][SPI]]
- [[#jcp][JCP]]
- [[#异常层次结构][异常层次结构]]
- [[#时间格式化][时间格式化]]
- [[#collections][Collections]]
- [[#comparator][Comparator]]

* SPI
  SPI 的全称为 (Service Provider Interface) ，是 JDK 内置的一种服务提供发现机制。主要由工具类 ~java.util.ServiceLoader~ 提供相应的支持。

  其中的两个角色为：
  + Service - 服务，通常为一个接口或一个抽象类，具体类虽然也可以，但是一般不建议那样做
  + Service Provider - 服务提供者，服务的具体实现类

  使用时，需要在 ~META-INF/services~ 下创建和服务的全限定名相同的文件，然后在该文件中写入服务提供者的全限定名，可以用 ~#~ 作为注释。

  然后，就可以通过 ~ServiceLoader~ 来获取这些服务提供者。由于 ServiceLoader 并没有提供直接获取服务提供者的方法，因此，只能通过迭代的方式获取：
  #+begin_src java
    ServiceLoader<Service> loader = ServiceLoader.load(Service.class, getClassLoader());

    for (Service service : loader) {
      // ...
    }
  #+end_src
  
  参考：[[https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html][ServiceLoader (Java Platform SE 8 )]]

* JCP
  JCP（Java Community Process）成立于 1998 年，是使有兴趣的各方参与定义 Java 的特征和未来版本的正式过程。
  
  JCP 使用 JSR（Java 规范请求，Java Specification Requests）作为正式规范文档，描述被提议加入到 Java 体系中的的规范和技术。

  参考：
  + [[https://en.wikipedia.org/wiki/Java_Community_Process][Java Community Process - Wikipedia]]

* 异常层次结构
  可以根据通用异常 -> 库异常 -> 业务异常的层次创建 ~asset~ 工具类，抛出相应层次的异常，便于管理。

* 时间格式化
  作为 Java 程序员，作为偶尔还会写一点前端的 Java 程序员，可能会遇到需要使用多种时间格式的情况，主要有 Java、Moment(ISO 8601) 和 strftime 这几种格式。

  三种格式的文档可以参考：
  + [[https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html][DateTimeFormatter (Java Platform SE 8 )]]
  + [[https://momentjs.com/docs/#/displaying/format/][Format - Moment.js | Docs]]
  + [[https://zh.cppreference.com/w/c/chrono/strftime][strftime - cppreference.com]]

  常用的时间模式符：
  |--------------+----------------------------------------------+---------------------------+---------------------------|
  | 时间         | Java                                         | Moment                    | strftime                  |
  |--------------+----------------------------------------------+---------------------------+---------------------------|
  | Year         | yy: 69, yyyy: 1969                           | YY: 69, YYYY: 1969        | %y: 69, %Y: 1969          |
  | Month        | M: 7, MM: 07, MMM: Jul, MMMM: July, MMMMM: J | M:7, MM: 07, MMM: Jul     | %m: 07, %b: Jul, %B: July |
  | Day of Month | d: 6, dd: 06                                 | D: 6, DD: 06              | %d: 06                    |
  | Day of Week  | E: Wed, EEE: Wednesday, EEEE: W              | ddd: Wed, dddd: Wednesday | %a: Wed, %A: Wednesday    |
  | Hour         | H: 9, HH: 09                                 | H: 9, HH: 09              | %H: 09                    |
  | Minute       | mm: 02                                       | mm: 02                    | %M: 02                    |
  | Second       | ss: 00                                       | ss: 00                    | %S: 00                    |
  |--------------+----------------------------------------------+---------------------------+---------------------------|

  NOTE: Java 以前的版本中提供了 SimpleDateFormat 这个方便的日期格式化类，但是这个类是线程不安全的，因此，考虑使用 Java8 中的 DateTimeFormatter 替换。

* Collections
  Java JDK 中的 Collections 提供了很多用于创建新集合的方法，大致可以分为如下几类：
  #+begin_src java
    checkedXXX();       // 创建类型安全的集合
    emptyXXX();         // 空集合
    singletonXXX();     // 单元素集合
    synchronizedXXX();  // 并发安全的集合
    unmodifiableXXX();  // 不可修改的集合
  #+end_src

  参考：
  + [[https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html][Collections (Java Platform SE 8 )]]

* Comparator
  Comparator 接口提供了很多默认方法来构建 Comparator 实例，比如说需要根据需要排序二维数组：
  #+begin_src java
    int[][] arr = {
      {1, 2, 3},
      {4, 5, 6},
      {7, 8, 9}
    };
    Arrays.sort(arr, Comparator.comparing(item -> item[0] % 2));
  #+end_src

  只不过需要注意在数组类型上的使用，特别是设计到基本数据类型和多维数组的时候，可以参考：
  + [[https://www.baeldung.com/java-8-comparator-comparing][Guide to Java 8 Comparator.comparing() | Baeldung]]

