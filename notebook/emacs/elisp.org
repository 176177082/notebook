#+TITLE:      Emacs - Emacs Lisp

* 目录                                                    :TOC_4_gh:noexport:
- [[#interactive][interactive]]
- [[#quote--backquote][Quote & Backquote]]
- [[#有用的函数][有用的函数]]
- [[#autoload][autoload]]
- [[#setq--setq-default][setq & setq-default]]
- [[#启用-minor-mode][启用 minor-mode]]
- [[#let--let][let & let*]]
- [[#type-predicates][Type Predicates]]
- [[#alist--plist][alist & plist]]
- [[#keyword][Keyword]]
- [[#关于符号][关于符号]]
- [[#hooks][Hooks]]

* interactive
  ~Emacs~ 中存在 *两种函数*:
  1) 可以作为命令执行的函数
  2) 不能作为命令执行的普通函数

  如果要让定义的函数可以作为命令执行， 需要在函数中添加 ~interactive~:
  #+BEGIN_SRC emacs-lisp
    (defun hello-world ()
      (interactive)
      (insert "hello, world"))
  #+END_SRC

  同时可以在 ~interactive~ 中获取函数调用时需要的参数：
  #+BEGIN_SRC emacs-lisp
    (defun c-malloc (name value)
      (interactive
       (list (read-string "name")
             (read-string "value"))
       (insert (format "%s = %s" name value)))
  #+END_SRC

* Quote & Backquote
  通过 quote 包裹的对象将不会执行，而是直接返回：
  #+BEGIN_SRC elisp
    '( a b c)  ; => (a b c)
  #+END_SRC

  反引号内部可以通过 ~,~ 和 ~,@~ 进行计算：
  #+BEGIN_SRC elisp
    `(1 2 ,(+ 3 4))  ; => (1 2 7)
    `(1 2 ,@(+ 3 4)) ; => (1 2 . 7)
  #+END_SRC

  + [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Quoting.html][Quoting - GNU Emacs Lisp Reference Manual]]
  + [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Backquote.html#Backquote][Backquote - GNU Emacs Lisp Reference Manual]]

* 有用的函数
  + 获取 Emacs 已启动时间长度：
    #+BEGIN_SRC elisp
      (emacs-uptime)
    #+END_SRC

  + 消息摘要算法的支持
    #+BEGIN_SRC elisp
      (md5 "str")
      (secure-hash 'sha256 "123")
    #+END_SRC

    参考：[[https://www.gnu.org/software/emacs/manual/html_node/elisp/Checksum_002fHash.html][Checksum/Hash - GNU Emacs Lisp Reference Manual]]
    
* autoload
  通过如下格式的注释声明某个函数为自动加载的：
  #+BEGIN_SRC elisp
    ;;;###autoload
    (defun doctor ()
      "Switch to *doctor* buffer and start giving psychotherapy."
      (interactive)
      (switch-to-buffer "*doctor*")
      (doctor-mode))
  #+END_SRC

* setq & setq-default
  Emacs 中有些变量是 buffer-local 的，通过 setq 设置 buffer-local 变量时，
  只会影响该缓冲区，而 setq-default 会设置全局的值。

  简单的说，就是：
  + setq：设置的值可能只影响当前缓冲区
  + setq-default：设置的值是全局的，影响所有的缓冲区

* 启用 minor-mode
  *概念：* ~Non-nil~ 指的是所有非 ~nil~ 的值，包括 ~0~ 和负数。

  *Minor Modes*:
  #+BEGIN_SRC elisp
    (minor-mode &optional ARG)
  #+END_SRC

  如果参数 ~ARG~ 存在，那么：
  + 如果 ~ARG~ 为正，就启用 ~minor-mode~
  + 其他情况就禁用 ~minor-mode~
  
  如果参数 ~ARG~ 不存在为 ~ARG~ 为 ~nil~, 也启动 ~minor-mode~.

  #+BEGIN_SRC elisp
    ;; enable
    (blink-cursor-mode)           ; Omitted argument
    (blink-cursor-mode 1)         ; Positive argument
    (blink-cursor-mode t)         ; True argument
    (blink-cursor-mode nil)       ; nil argument (don't use this)

    ;; disable
    (blink-cursor-mode 0)         ; Non-positive argument
    (blink-cursor-mode -1)        ; Negative argument
  #+END_SRC

* let & let*
  ~let~ 的参数列表中，后序的参数不能使用前面定义的参数，而 ~let*~ 可以：
  #+BEGIN_SRC elisp
    ELISP> (let ((num 10) (n num)))
    ,*** Eval error ***  Symbol’s value as variable is void: num
    ELISP> (let* ((num 10) (n num)))
    nil
  #+END_SRC  

* Type Predicates
  通过函数 ~type-of~ 判断一个对象的类型：
  #+BEGIN_SRC elisp
    (type-of '(1 2 3))  ; => cons
  #+END_SRC

  + [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Type-Predicates.html][Type Predicates - GNU Emacs Lisp Reference Manual]]
    
* alist & plist
  alist 的常见的两种形式：
  #+BEGIN_SRC elisp
    '((a . 1) ("b" 2 3))
    '((rose red) (lily white) (buttercup yellow))
  #+END_SRC

  plist 常见的形式：
  #+BEGIN_SRC elisp
    (plist-get '(foo 4) 'foo)     ;; ⇒ 4
    (plist-get '(foo 4 bad) 'foo) ;; ⇒ 4
    (plist-get '(foo 4 bad) 'bad) ;; ⇒ nil
    (plist-get '(foo 4 bad) 'bar) ;; ⇒ nil
  #+END_SRC

  可见两者的本质是相同的：
  #+BEGIN_SRC elisp
    ELISP> (type-of '(foo 4))
    cons
    ELISP> (type-of '((foo 4)))
    cons
  #+END_SRC

  + [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Association-Lists.html][Association Lists - GNU Emacs Lisp Reference Manual]]
  + [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Plist-Access.html#Plist-Access][Plist Access - GNU Emacs Lisp Reference Manual]]
  + [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Dotted-Pair-Notation.html][Dotted Pair Notation - GNU Emacs Lisp Reference Manual]]

* Keyword
  Elisp 中以符号 *:* 开头的符号属于 *关键字*, 声明一个 *:xxx* 形式的变量会主动出击关键字：
  #+BEGIN_SRC elisp
    ELISP> (intern-soft ":key-1")
    nil
    ELISP> :key-1
    :key-1
    ELISP> (intern-soft ":key-1")
    :key-1
  #+END_SRC

  可以通 ~keywordp~ 判断一个符号是否是关键字：
  #+BEGIN_SRC elisp
    (keywordp :key-1)  ; => t
  #+END_SRC

* 关于符号
  #+BEGIN_SRC elisp
    ;; 符号列表
    (setq lst '(symbolA symbolB symbolC))
    (symbolp (car lst))  ;; => t

    ;; 符号根据不同的使用场景，使用其代表的 值、函数、符号
    (symbol x x x)       ;; => 函数
    (+ symbolA symbolB)  ;; => 值
    'symbol              ;; => 符号
  #+END_SRC

* Hooks  
  Hook 是 Emacs 中重要的扩展机制，是一个函数列表，会在执行某些操作后执行这个列表中的函数。

  + [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Hooks.html][Hooks - GNU Emacs Manual]]

