#+TITLE:      Linux I/O 模型

* 目录                                                    :TOC_4_gh:noexport:
- [[#同步异步阻塞非阻塞][同步、异步、阻塞、非阻塞]]

* 同步、异步、阻塞、非阻塞
  一般情况下 I/O 指的都是用户空间的 I/O，而用户空间的 I/O 操作主要分为两个阶段：
  1. 将数据从外部 I/O 设备拷贝到内核中，等待数据准备就绪
  2. 将数据从内核拷贝到进程中
     
  而同步、异步、阻塞、非阻塞的概念便是相对于这两个过程来说的：
  1. Blocking I/O，在阻塞 I/O 中，当用户进程发起 =read= 系统调用后，在数据从 I/O 设备到内核，在从内核到用户空间这两个阶段都是阻塞的
  2. Non-blocking I/O，在非阻塞 I/O 中，当用户进程发起 =read= 系统调用后，如果内核中数据还没有准备好，那么就会立即返回，反之，就会阻塞等待数据拷贝到用户空间
  3. Asynchronous I/O，在异步 I/O 中，当用户进程发起 ~aio_read~ 系统调用后，用户进程并不会阻塞，反之会等待数据拷贝到用户空间后由操作系统发出信号通知用户进程处理
  4. Synchronous I/O，阻塞、非阻塞、多路 I/O 复用都是同步 I/O，两者的区别就在于 Synchronous I/O 做 IO operation 的时候会将用户空间的进程阻塞
  
  对于多路 I/O 复用来说，和阻塞 I/O 一样会在两个阶段阻塞，只不过，第一个阶段是 ~select~ 系统调用，可以等到多个 I/O 操作，第二个阶段才是 =read= 操作。
  因此，在 I/O 并发量低的时候，多路 I/O 复用并不一定比多线程阻塞 I/O 有更好的表现。

  参考：
  + [[http://flyflypeng.github.io/linux/2017/07/10/Linux-IO%E6%A8%A1%E5%9E%8B.html][Linux I/O 模型详解]]

