#+TITLE:      JavaScript

* 目录                                                    :TOC_4_gh:noexport:
- [[#定时器][定时器]]
- [[#json][JSON]]
- [[#相关技巧][相关技巧]]
  - [[#javascript-变量的命名][JavaScript 变量的命名]]
  - [[#让返回值变成-undefined][让返回值变成 undefined]]
  - [[#显示所有元素的-outline][显示所有元素的 outline]]
  - [[#iife][IIFE]]
- [[#相关问题][相关问题]]
  - [[#通过-innerhtml-的方式为-table-添加行失败][通过 innerHTML 的方式为 table 添加行失败]]
  - [[#浏览器中-es6-模块化的语法不能使用][浏览器中 ES6 模块化的语法不能使用]]
  - [[#怎样获取用户使用的语言][怎样获取用户使用的语言]]
  - [[#不使用-jquery-的入口函数][不使用 jQuery 的入口函数]]

* 定时器  
  可以通过函数 ~setInterval()~ 执行需要循环定时执行的代码：
  #+BEGIN_SRC javascript
    var timer = setInterval(function() {
      console.log(2);
    }, 1000)
  #+END_SRC

* JSON
  #+BEGIN_SRC js
    > JSON.parse('{"id": 123456, "name": "rgb-24bit"}')
    {id: 123456, name: "rgb-24bit"}
    > JSON.stringify({id: 123456, name: "rgb-24bit"})
    "{"id":123456,"name":"rgb-24bit"}"
  #+END_SRC

* 相关技巧
** JavaScript 变量的命名
   JavaScript 的标识符允许大多数的 Unicode 字符，因此，你甚至可以使用颜文字来编写程序。
** 让返回值变成 undefined
   在浏览器地址栏执行函数时这个技巧挺有用的，可以避免因为函数返回值进行跳转：
   #+BEGIN_SRC js
     javascript:void window.prompt("Copy to clipboard: Ctrl+C, Enter", `[[${window.location.href}][${document.title}]]`)
   #+END_SRC  

   直接通过关键字 void 将值覆盖。

** 显示所有元素的 outline
   控制台中 $$ 相当于 document.querySelectorAll
   #+BEGIN_SRC js
     $$("*").forEach(
       e => e.style.outline = "1px solid #" + (~~(Math.random() * (1<<24))).toString(16)
     )
   #+END_SRC

** IIFE
   IIFE（立即调用函数表达式）是一个在定义时就会立即执行的 JavaScript 函数。

   这是一个被称为自执行匿名函数的设计模式，主要包含两部分:
   + 第一部分是包围在圆括号运算符 () 里的一个匿名函数，这个匿名函数拥有独立的词法作用域。
     这不仅避免了外界访问此 IIFE 中的变量，而且又不会污染全局作用域。
   + 第二部分再一次使用 () 创建了一个立即执行函数表达式，JavaScript 引擎到此将直接执行函数。

   #+BEGIN_SRC javascript
     (function () { 
       var name = "Barry";
     })();
   #+END_SRC

* 相关问题
** 通过 innerHTML 的方式为 table 添加行失败
   通过 innerHTML 属性设置 HTML 时，底层引擎会自动关闭未关闭的标签，并修复其他错误的 HTML。

   而单独的 <tr> 标签将被视作为关闭的标签，因此，通过 innerHTML 的方式为 table 添加行会失败。

   解决方案：
   #+BEGIN_SRC js
     let table = document.createElement('table');
     for (let i = 0; i < 3; ++i) {
       let row = table.insertRow(i);
       let text = document.createTextNode(i.toString());
       let cell = row.insertCell(0);
       cell.appendChild(text);
     }
   #+END_SRC

** 浏览器中 ES6 模块化的语法不能使用
   需要使用如下形式的 script 标签：
   #+BEGIN_SRC html
     <script type="module" src="...">
   #+END_SRC

   参考：[[http://es6.ruanyifeng.com/#docs/module][Module 的语法 - ECMAScript 6入门]]

** 怎样获取用户使用的语言
   在 ~Firefox~ 和 ~Chrome~ 中可以使用如下方式获取：
   #+BEGIN_SRC js
     var language;
     if (window.navigator.languages) {
       language = window.navigator.languages[0];
     } else {
       language = window.navigator.userLanguage || window.navigator.language;
     }
   #+END_SRC

   参考：
   + [[https://stackoverflow.com/questions/25606730/get-current-locale-of-chrome/42070353][javascript - Get current locale of chrome - Stack Overflow]]
   + [[https://www.w3schools.com/jsref/obj_navigator.asp][Navigator Object]]

** 不使用 jQuery 的入口函数
   在所有内容，包括外部图片之类的文件加载完后，才会执行的函数：
   #+BEGIN_SRC javascript
     window.onload = function () {
       // ...
     }
   #+END_SRC

