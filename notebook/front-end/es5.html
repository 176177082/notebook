<!DOCTYPE html>
<html lang="zh-CN">
<head>
<!-- 2021-01-09 周六 19:46 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>ECMAScript 5</title>
<meta name="generator" content="Org mode">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="https://rgb-24bit.github.io/blog/misc/style.css">
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-125860001-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-125860001-1');
</script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="https://rgb-24bit.github.io/notebook/"> UP </a>
 |
 <a accesskey="H" href="https://rgb-24bit.github.io"> HOME </a>
</div><div id="content">
<h1 class="title">ECMAScript 5</h1>
<div id="table-of-contents">
<h2>&#30446;&#24405;</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgb0c5b44">1. 基础概念</a>
<ul>
<li><a href="#org98dbcec">1.1. 宿主环境</a></li>
</ul>
</li>
<li><a href="#org91fd12e">2. 数据类型</a></li>
<li><a href="#org36fc9a8">3. 属性描述符</a></li>
<li><a href="#org156926b">4. 对象字面量</a></li>
<li><a href="#orga223c1d">5. 数据类型的转换</a></li>
<li><a href="#org590cd84">6. 面向对象</a>
<ul>
<li><a href="#org8bf7506">6.1. 类型判断</a></li>
</ul>
</li>
<li><a href="#org93cbdf2">7. this 指针</a></li>
<li><a href="#orgf064612">8. 事件机制</a></li>
<li><a href="#orgc66ab78">9. 相关技巧</a>
<ul>
<li><a href="#org1118aa9">9.1. JavaScript 变量的命名</a></li>
<li><a href="#org5227922">9.2. 让返回值变成 undefined</a></li>
<li><a href="#orgc8e1022">9.3. 显示所有元素的 outline</a></li>
<li><a href="#orgf1aa94c">9.4. IIFE</a></li>
<li><a href="#orgae7e719">9.5. 数值运算符</a></li>
<li><a href="#orgfe77455">9.6. 函数参数列表</a></li>
</ul>
</li>
<li><a href="#org51ea6ff">10. 相关问题</a>
<ul>
<li><a href="#orgfa745e2">10.1. 通过 innerHTML 的方式为 table 添加行失败</a></li>
<li><a href="#orgae8d51d">10.2. 浏览器中 ES6 模块化的语法不能使用</a></li>
<li><a href="#orgeb9c9ae">10.3. 怎样获取用户使用的语言</a></li>
<li><a href="#org871d156">10.4. JavaScript 的入口函数？</a></li>
<li><a href="#orgd9ec0f5">10.5. 如何清空一个数组中的内容</a></li>
<li><a href="#org7754b81">10.6. 变量提升的规则</a></li>
<li><a href="#orge44e6e8">10.7. window.onload 和 document.onload</a></li>
<li><a href="#org62cb7de">10.8. 普通函数和构造函数的区别</a></li>
<li><a href="#org8eb3758">10.9. 怎样实现字符串的 replaceAll 操作</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgb0c5b44" class="outline-2">
<h2 id="orgb0c5b44"><span class="section-number-2">1</span> 基础概念</h2>
<div class="outline-text-2" id="text-1">
<p>
JavaScript 本身不提供任何与 I/O 相关的 API，这些都要靠宿主环境提供，比如浏览器、Node.js 这些。
</p>

<p>
JavaScript 的学习可以分为三个部分：
</p>
<ol class="org-ol">
<li>基本的语法构造，比如操作符、控制结构、语句等</li>
<li>标准库，就是一系列具有各种功能的对象比如 Array、Date、Math 等</li>
<li>各种宿主环境提供额外的 API</li>
</ol>

<p>
JavaScript 常用的宿主环境为浏览器，浏览器提供的额外接口可以分为三类：
</p>
<ol class="org-ol">
<li>浏览器控制类，用于操作浏览器</li>
<li>DOM 类，用于操作网页的各种元素</li>
<li>Web 类，用于实现互联网的各种功能</li>
</ol>

<p>
JavaScript 的核心语法不难，其复杂性体现在另外两个方面：
</p>
<ol class="org-ol">
<li>涉及的大量的外部 API</li>
<li>语言的一些设计缺陷</li>
</ol>

<p>
ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现。在日常场合，这两个词是可以互换的。
</p>

<p>
其中，ECMAScript 只用来标准化 JavaScript 这种语言的基本语法结构，与部署环境相关的标准都由其他标准规定，比如 DOM 的标准就是由 W3C 组织制定的。
</p>

<p>
参考：
</p>
<ul class="org-ul">
<li><a href="https://wangdoc.com/javascript/index.html">JavaScript 教程 - 网道</a></li>
</ul>
</div>

<div id="outline-container-org98dbcec" class="outline-3">
<h3 id="org98dbcec"><span class="section-number-3">1.1</span> 宿主环境</h3>
<div class="outline-text-3" id="text-1-1">
<p>
在学习 JavaScript 的时候需要注意区分不同的宿主环境，因为在不同的环境下 JavaScript 的表现多多少少还是存在一些区别。
</p>

<p>
最常见的宿主环境应该是浏览器，提供了很多额外的接口，另外一个现在常用的宿主环境的是 Node.js，其中，Node 是 JavaScript 语言的服务器运行环境，提供大量工具库，使得 JavaScript 语言与操作系统互动。其中，Node 内部采用 Google 公司的 V8 引擎作为 JavaScript 语言解释器，通过自行开发的 libuv 库，调用操作系统资源。
</p>

<p>
不同类型的宿主环境在 JavaScript 的实现上存在区别，不一定完全匹配 ECMAScript 标准，比如说，Node.js 中模块系统使用的便是 CommonJS 标准。
</p>

<p>
同一类型的宿主环境在 JavaScript 的实现上同样存在差异，比如说 IE 浏览器，因此，往往需要一些工具将高版本的 JS 编译为兼容低版本的 JS，
Babel 便是用来完成这一工作的。
</p>

<p>
参考：
</p>
<ul class="org-ul">
<li><a href="https://javascript.ruanyifeng.com/nodejs/basic.html">Node.js 概述 &#x2013; JavaScript 标准参考教程 (alpha)</a></li>
<li><a href="https://wangdoc.com/javascript/basic/introduction.html">导论 - JavaScript 教程 - 网道</a></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org91fd12e" class="outline-2">
<h2 id="org91fd12e"><span class="section-number-2">2</span> 数据类型</h2>
<div class="outline-text-2" id="text-2">
<p>
JavaScript 中除了 ES6 新增的 Symbol 以外存在六种数据类型，分别为：数值、布尔值、字符串、undefined、null 和 对象。其中对象又可以分为狭义的对象、数组和函数。
</p>

<p>
JavaScript 可以通过三种方法来判断对象的类型：
</p>
<ul class="org-ul">
<li><code>typeof</code> 运算符</li>
<li><code>instanceof</code> 运算符</li>
<li><code>Object.prototype.toString</code> 方法</li>
</ul>

<p>
如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了 undefined、null、false、0、NaN 和空字符串这六个值被转为 false，其他值都视为 true。
</p>

<p>
JavaScript 内部，所有数字都是以 64 位浮点数形式储存，即使整数也是如此。这就是说，JavaScript 语言的底层根本没有整数，所有数字都是小数（64 位浮点数）。容易造成混淆的是，某些运算只有整数才能完成，此时 JavaScript 会自动把 64 位浮点数，转成 32 位整数，然后再进行运算。
</p>

<p>
JavaScript 内部实际上存在 2 个0：一个是 +0，一个是 -0，几乎所有场合，正零和负零都会被当作正常的 0，除了在作为分母时。除以正零得到 +Infinity，除以负零得到 -Infinity。
</p>

<p>
由于 NaN 和 Infinity 这两个特殊数值和自动转换规则的存在，使得 JavaScript 数值运算几乎不会出现异常，只会得到让你一脸懵逼的结构 @_@
</p>

<p>
和数值操作相关的全局函数：
</p>
<ul class="org-ul">
<li><code>parseInt</code> 方法用于将字符串转为整数</li>
<li><code>parseFloat</code> 方法用于将字符串转为浮点数</li>
<li><code>isNaN</code> 方法可以用来判断一个值是否为 <code>NaN</code></li>
<li><code>isFinite</code> 方法返回一个布尔值，表示某个值是否为正常的数值，只有 Infinity、-Infinity、NaN 和 undefined 这几个值会返回 false。</li>
</ul>

<p>
JavaScript 提供了两个原生方法 <code>btoa</code> 和 <code>atob</code> 来转换还原 Base64 字符串，这两个方法仅适用于 ASCII 字符。要将非 ASCII 码字符转为 Base64 编码，必须中间插入一个转码环节，再使用这两个方法：
</p>
<div class="org-src-container">
<pre class="src src-js"><span class="org-keyword">function</span> <span class="org-function-name">b64Encode</span>(<span class="org-variable-name">str</span>) {
  <span class="org-keyword">return</span> btoa(encodeURIComponent(str));
}

<span class="org-keyword">function</span> <span class="org-function-name">b64Decode</span>(<span class="org-variable-name">str</span>) {
  <span class="org-keyword">return</span> decodeURIComponent(atob(str));
}
</pre>
</div>

<p>
可以通过 <code>Object.keys</code> 方法来查看对象的所有属性，同时可以通过 <code>delete</code> 命令删除对象的属性。而 <code>in</code> 运算符可以检查对象是否包含某个属性，但是不能识别哪些属性是对象自身的，哪些属性是继承的，这时，可以使用对象的 <code>hasOwnProperty</code> 方法判断一下，是否为对象自身的属性。
</p>

<p>
可以通过 <code>for...in</code> 循环遍历一个对象的全部属性，需要注意的是：
</p>
<ol class="org-ol">
<li>它遍历的是对象所有可遍历的属性，会跳过不可遍历的属性</li>
<li>它不仅遍历对象自身的属性，还遍历继承的属性</li>
</ol>

<p>
JavaScript 中的函数可以被多次声明，后面的声明就会覆盖前面的声明，这和变量不一样，变量多此声明时，如果不赋初始值，后面的声明就是无效的。也许，函数声明即有值，因此后面的会覆盖前面的。
</p>

<p>
JavaScript 引擎将函数名视同变量名，所以采用 function 命令声明函数时， <b>整个函数</b> 会像变量声明一样，被提升到代码头部，但是，如果采用赋值语句定义函数，就会存在问题：
</p>
<div class="org-src-container">
<pre class="src src-js"><span class="org-keyword">var</span> <span class="org-variable-name">f</span> = <span class="org-keyword">function</span> () {
  console.log(<span class="org-string">'1'</span>);
}

<span class="org-keyword">function</span> <span class="org-function-name">f</span>() {
  console.log(<span class="org-string">'2'</span>);
}

f()
</pre>
</div>

<p>
上面的代码经过变量提升后就变成了：
</p>
<div class="org-src-container">
<pre class="src src-js"><span class="org-keyword">var</span> <span class="org-variable-name">f</span>;

<span class="org-keyword">function</span> <span class="org-function-name">f</span>() {
  console.log(<span class="org-string">'2'</span>);
}

<span class="org-keyword">var</span> <span class="org-variable-name">f</span> = <span class="org-keyword">function</span> () {
  console.log(<span class="org-string">'1'</span>);
}

f() <span class="org-comment-delimiter">// </span><span class="org-comment">1</span>
</pre>
</div>

<p>
最后得到的就是通过赋值语句声明的函数，因此，如果同时采用 function 命令和赋值语句声明同一个函数，最后总是采用赋值语句的定义。
</p>

<p>
函数的属性和方法：
</p>
<ul class="org-ul">
<li>函数的 <code>name</code> 属性返回函数的名字</li>
<li>函数的 <code>length</code> 属性返回函数预期传入的参数个数，即函数定义之中的参数个数</li>
<li>函数的 <code>toString</code> 方法返回一个字符串，内容是函数的源码，包含注释</li>
</ul>

<p>
在 ES5 中，作用域可以分为全局作用域和函数（局部）作用域，其中，函数内部定义的变量，会在该作用域内覆盖同名全局变量。
</p>

<p>
JavaScript 中，函数参数不是必需的，JavaScript 允许省略参数，即使函数签名中有参数。另外，你多传参数也没有问题，JavaScript 会在填满参数列表后忽略后面的参数。
</p>

<p>
如果函数签名中有同名的参数，则取最后出现的那个值。
</p>

<p>
由于 JavaScript 中函数参数的不确定性，所以需要一种机制，可以在函数体内部读取所有参数。这就是 arguments 对象的由来。arguments 对象包含了函数运行时的所有参数，
arguments[0] 就是第一个参数，arguments[1] 就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。
</p>

<p>
正常模式下，arguments 对象可以在运行时修改，而在严格模式下，严格模式下，arguments 对象与函数参数不具有联动关系。需要注意的是，arguments 对象虽然很像数组，但不是数组。
</p>

<p>
arguments 对象带有一个 callee 属性，可以返回它所对应的原函数，这个属性在严格模式里面是禁用的，因此不建议使用。
</p>

<p>
JavaScript 中数组是一种特殊的对象，数组的索引是通过对应的属性来实现的，即 <code>0 - N</code> 的索引其实是存在 <code>0 - N</code> 的属性，只不过，数字属性不能通过 <code>obj.attr</code> 的方式访问，于是便通过 <code>obj[attr]</code> 的方式来操作了。
</p>

<p>
JavaScript 中数组可以存在空位，比如说 <code>[1, ,3]</code> 的形式中间便存在一个空位，可以通过 <code>delete</code> 命令删除数组元素，此时会在原数组上生成一个空位。
</p>

<p>
如果一个对象的所有键名都是正整数或零，并且有 <code>length</code> 属性，那么这个对象就很像数组，语法上称为类似数组的对象，可以通过 <code>Array.prototype.slice.call</code> 将类似数组的对象变成真正的数组。
</p>
</div>
</div>

<div id="outline-container-org36fc9a8" class="outline-2">
<h2 id="org36fc9a8"><span class="section-number-2">3</span> 属性描述符</h2>
<div class="outline-text-2" id="text-3">
<p>
JavaScript 提供了一个内部数据结构 - 属性描述符来描述对象的属性，对象里目前存在的属性描述符有两种主要形式：
</p>
<ul class="org-ul">
<li>数据描述符：数据描述符是一个具有值的属性，该值可能是可写的，也可能不是可写的</li>
<li>存取描述符：存取描述符是由 <code>getter-setter</code> 函数对描述的属性</li>
</ul>

<p>
描述符必须是这两种形式之一，不能同时是两者。
</p>

<p>
用于描述符本身的属性：
</p>
<ul class="org-ul">
<li><code>configurable</code> - 该属性描述符是否可以被改变，当值为 false 时，该属性描述符不能被修改，同时对应的属性也不能删除</li>
<li><code>enumerable</code> - 该属性能否被枚举，当属性不能被枚举时，for&#x2026;in 和 Object.keys 会跳过该属性</li>
</ul>

<p>
用于数据描述符的属性：
</p>
<ul class="org-ul">
<li><code>value</code> - 该属性对应的值</li>
<li><code>writable</code> - 该属性是否可写</li>
</ul>

<p>
用于存取描述符的属性：
</p>
<ul class="org-ul">
<li><code>get</code> - 该属性的 <code>getter</code> 方法</li>
<li><code>set</code> - 该属性的 <code>setter</code> 方法</li>
</ul>

<p>
PS：可以通过 <code>Proxy</code> 对象拦截所有属性的 <code>getter</code> 和 <code>setter</code> 操作
</p>

<p>
参考：
</p>
<ul class="org-ul">
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty#%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6">Object.defineProperty() - JavaScript | MDN</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties">Object.defineProperties() - JavaScript | MDN</a></li>
<li><a href="https://wangdoc.com/javascript/stdlib/attributes.html">属性描述对象 - JavaScript 教程 - 网道</a></li>
<li><a href="https://es6.ruanyifeng.com/#docs/proxy">Proxy - ECMAScript 6入门</a></li>
</ul>
</div>
</div>

<div id="outline-container-org156926b" class="outline-2">
<h2 id="org156926b"><span class="section-number-2">4</span> 对象字面量</h2>
<div class="outline-text-2" id="text-4">
<p>
在 ES2015，对象字面值扩展支持：
</p>
<ul class="org-ul">
<li>在创建时设置原型</li>
<li>简写了 <code>foo: foo</code> 形式的属性赋值</li>
<li>方法定义</li>
<li>父方法调用</li>
<li>使用表达式动态计算属性名</li>
</ul>

<p>
例子:
</p>
<div class="org-src-container">
<pre class="src src-js"><span class="org-keyword">var</span> <span class="org-variable-name">obj</span> = {
  <span class="org-comment-delimiter">// </span><span class="org-comment">__proto__</span>
  __proto__: theProtoObj,
  <span class="org-comment-delimiter">// </span><span class="org-comment">Shorthand for &#8216;handler: handler&#8217;</span>
  handler,
  <span class="org-comment-delimiter">// </span><span class="org-comment">Methods</span>
  toString() {
    <span class="org-comment-delimiter">// </span><span class="org-comment">Super calls</span>
    <span class="org-keyword">return</span> <span class="org-string">"d "</span> + <span class="org-keyword">super</span>.toString();
  },
  <span class="org-comment-delimiter">// </span><span class="org-comment">Computed (dynamic) property names</span>
  [ <span class="org-string">'prop_'</span> + (() =&gt; 42)() ]: 42
};
</pre>
</div>

<p>
属性的 getter 和 setter 也可以简写：
</p>
<div class="org-src-container">
<pre class="src src-js"><span class="org-keyword">const</span> <span class="org-variable-name">cart</span> = {
  _wheels: 4,

  get wheels () {
    <span class="org-keyword">return</span> <span class="org-constant">this</span>._wheels;
  },

  set wheels (value) {
    <span class="org-keyword">if</span> (value &lt; <span class="org-constant">this</span>._wheels) {
      <span class="org-keyword">throw</span> <span class="org-keyword">new</span> <span class="org-type">Error</span>(<span class="org-string">'&#25968;&#20540;&#22826;&#23567;&#20102;&#65281;'</span>);
    }
    <span class="org-constant">this</span>._wheels = value;
  }
}
</pre>
</div>

<p>
参考：
</p>
<ul class="org-ul">
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Grammar_and_types">语法和数据类型 - JavaScript | MDN</a></li>
<li><a href="https://es6.ruanyifeng.com/#docs/object">对象的扩展 - ECMAScript 6入门</a></li>
</ul>
</div>
</div>

<div id="outline-container-orga223c1d" class="outline-2">
<h2 id="orga223c1d"><span class="section-number-2">5</span> 数据类型的转换</h2>
<div class="outline-text-2" id="text-5">
<p>
JavaScript 中的数据类型转换规则是我目前见过的所有语言中最复杂的一个，其中，自动类型转换是通过调用 Boolean、String 和 Number 函数完成的。
</p>

<p>
同时，自动类型转换又往往和比较运算符扯在一起，详细规则可以见：
</p>
<ul class="org-ul">
<li><a href="https://wangdoc.com/javascript/features/conversion.html">数据类型的转换 - JavaScript 教程 - 网道</a></li>
<li><a href="https://wangdoc.com/javascript/operators/comparison.html#%E7%9B%B8%E7%AD%89%E8%BF%90%E7%AE%97%E7%AC%A6">比较运算符 - JavaScript 教程 - 网道</a></li>
</ul>
</div>
</div>

<div id="outline-container-org590cd84" class="outline-2">
<h2 id="org590cd84"><span class="section-number-2">6</span> 面向对象</h2>
<div class="outline-text-2" id="text-6">
<p>
JavaScript 中的原型链和我想象中的存在一点区别，大致存在三个层次：
</p>
<pre class="example">
              ConstructorA      ConstructorB      ConstructorC
                   |                 |                 |
Instance       prototype         prototype         prototype
    |       /      |         /       |         /       |
    |      /       |        /        |        /        |
__proto__       __proto__         __proto__         __proto__
</pre>

<p>
这和 Python 的存在区别，之前一直按 Python 中的 <code>__class__</code> 类比理解的：
</p>
<pre class="example">
Instance         ClassA         ClassB         ClassB   
    |        /      |       /      |       /      |  
    |       /       |      /       |      /       |
__class__       __class__      __class__      __class__
</pre>

<p>
通过 <code>instanceof</code> 判断对象类型的时候，会判断右值的 <code>prototype</code> 是否在左值的原型链上，当左值的类型为以下类型时直接返回 Fasle：
</p>
<blockquote>
<p>
Boolean Null Undefined Number BigInt String Symbol
</p>
</blockquote>

<p>
获取原型链：
</p>
<div class="org-src-container">
<pre class="src src-js"><span class="org-keyword">function</span> <span class="org-function-name">getPrototypes</span>(<span class="org-variable-name">obj</span>) {
  prototypes = []
  <span class="org-keyword">while</span> (obj) {
    prototypes.push(obj.__proto__)
    obj = obj.__proto__
  }
  <span class="org-keyword">return</span> prototypes
}
</pre>
</div>

<p>
这里我一直也理解错了，以为 JavaScript 和 Python 一样，一切皆是对象，结果 JavaScript 中居然还有 primitive 类型，只不过在 primitive 调用方法时会自动包装为对象。
</p>

<p>
参考：
</p>
<ul class="org-ul">
<li><a href="https://segmentfault.com/q/1010000004457932">javascript - `1 instanceof Number` 为啥是 false? - SegmentFault 思否</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures">JavaScript data types and data structures - JavaScript | MDN</a></li>
<li><a href="https://wangdoc.com/javascript/oop/prototype.html">对象的继承 - JavaScript 教程 - 网道</a></li>
</ul>
</div>

<div id="outline-container-org8bf7506" class="outline-3">
<h3 id="org8bf7506"><span class="section-number-3">6.1</span> 类型判断</h3>
<div class="outline-text-3" id="text-6-1">
<p>
JavaScript 中可以通过 typeof、instanceof、constructor 和 toString 来判断对象的类型，其中：
</p>
<ol class="org-ol">
<li><p>
typeof 判断对象类型是通过对象的底层表示形式来判断的，这就导致了一个问题，typeof null 会被判断为 object，参考：
</p>
<div class="org-src-container">
<pre class="src src-js"><span class="org-keyword">typeof</span> <span class="org-string">''</span>;              <span class="org-comment-delimiter">// </span><span class="org-comment">string</span>
<span class="org-keyword">typeof</span> 1;               <span class="org-comment-delimiter">// </span><span class="org-comment">number</span>
<span class="org-keyword">typeof</span> 1n;              <span class="org-comment-delimiter">// </span><span class="org-comment">bigint</span>
<span class="org-keyword">typeof</span> Symbol();        <span class="org-comment-delimiter">// </span><span class="org-comment">symbol</span>
<span class="org-keyword">typeof</span> <span class="org-constant">true</span>;            <span class="org-comment-delimiter">// </span><span class="org-comment">boolean</span>
<span class="org-keyword">typeof</span> <span class="org-constant">undefined</span>;       <span class="org-comment-delimiter">// </span><span class="org-comment">undefined</span>
<span class="org-keyword">typeof</span> <span class="org-keyword">new</span> <span class="org-type">Function</span>();  <span class="org-comment-delimiter">// </span><span class="org-comment">function</span>

<span class="org-keyword">typeof</span> <span class="org-constant">null</span>;            <span class="org-comment-delimiter">// </span><span class="org-comment">object</span>
<span class="org-keyword">typeof</span> [] ;             <span class="org-comment-delimiter">// </span><span class="org-comment">object</span>
<span class="org-keyword">typeof</span> <span class="org-keyword">new</span> <span class="org-type">Date</span>();      <span class="org-comment-delimiter">// </span><span class="org-comment">object</span>
<span class="org-keyword">typeof</span> <span class="org-keyword">new</span> <span class="org-type">RegExp</span>();    <span class="org-comment-delimiter">// </span><span class="org-comment">object</span>
</pre>
</div>

<p>
返回值其实是有规律的：
</p>
<ol class="org-ol">
<li>primitive type 类型中，除了 null 以外都可以得到正确的判断</li>
<li>function 是特殊的对象，单独给个底层表示形式不过分</li>
<li>其他的都是 object 就可以了</li>
</ol>

<p>
参考：
</p>
<ol class="org-ol">
<li><a href="https://segmentfault.com/q/1010000011846328">JavaScript 中 typeof 原理探究？ - SegmentFault 思否</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof">typeof - JavaScript | MDN</a></li>
</ol></li>
<li>instanceof 通过原型链来判断对象类型，当一个对象的原型就是 null 时，它不能作为 instanceof 操作符的右值，而左值类型为 primitive 时会直接返回 false</li>
<li><p>
原型对象的 constructor 属性指向构造器本身，因此，这种判断方式本质上还是在使用原型链：
</p>
<div class="org-src-container">
<pre class="src src-js">obj = <span class="org-keyword">new</span> <span class="org-type">Dog</span>()
obj.constructor == Dog
</pre>
</div></li>
<li><p>
方法 Object.prototype.toString 会返回对象的 <code>[[Class]]</code> 属性，其格式为 <code>[object Xxx]</code>, 其中 <code>Xxx</code> 就是对象的类型
</p>
<div class="org-src-container">
<pre class="src src-js">Object.<span class="org-constant">prototype</span>.toString.call(<span class="org-string">''</span>)              <span class="org-comment-delimiter">// </span><span class="org-comment">[object String]</span>
Object.<span class="org-constant">prototype</span>.toString.call(1)               <span class="org-comment-delimiter">// </span><span class="org-comment">[object Number]</span>
Object.<span class="org-constant">prototype</span>.toString.call(<span class="org-constant">true</span>)            <span class="org-comment-delimiter">// </span><span class="org-comment">[object Boolean]</span>
Object.<span class="org-constant">prototype</span>.toString.call(Symbol())        <span class="org-comment-delimiter">// </span><span class="org-comment">[object Symbol]</span>
Object.<span class="org-constant">prototype</span>.toString.call(<span class="org-constant">undefined</span>)       <span class="org-comment-delimiter">// </span><span class="org-comment">[object Undefined]</span>
Object.<span class="org-constant">prototype</span>.toString.call(<span class="org-constant">null</span>)            <span class="org-comment-delimiter">// </span><span class="org-comment">[object Null]</span>
Object.<span class="org-constant">prototype</span>.toString.call(newFunction())   <span class="org-comment-delimiter">// </span><span class="org-comment">[object Function]</span>
Object.<span class="org-constant">prototype</span>.toString.call(newDate())       <span class="org-comment-delimiter">// </span><span class="org-comment">[object Date]</span>
Object.<span class="org-constant">prototype</span>.toString.call([])              <span class="org-comment-delimiter">// </span><span class="org-comment">[object Array]</span>
Object.<span class="org-constant">prototype</span>.toString.call(newRegExp())     <span class="org-comment-delimiter">// </span><span class="org-comment">[object RegExp]</span>
</pre>
</div></li>
</ol>

<p>
总的来说，JavaScript 中类型判断的坑很多，感觉其中一个原因大概就是存在 primitive 类型但是有没有类型系统的锅，像 Python 那样，一切皆是对象，直接一条原型链搞定。
</p>

<p>
参考：
</p>
<ul class="org-ul">
<li><a href="https://www.cnblogs.com/onepixel/p/5126046.html">判断 JS 数据类型的四种方法 - 一像素 - 博客园</a></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org93cbdf2" class="outline-2">
<h2 id="org93cbdf2"><span class="section-number-2">7</span> this 指针</h2>
<div class="outline-text-2" id="text-7">
<p>
在全局执行环境下 <code>this</code> 指针指向全局对象，也就是 <code>window</code> 或 <code>global</code> 对象：
</p>
<div class="org-src-container">
<pre class="src src-js">console.log(<span class="org-constant">this</span> === window);  <span class="org-comment-delimiter">// </span><span class="org-comment">true</span>

a = 37;
console.log(window.a);         <span class="org-comment-delimiter">// </span><span class="org-comment">37</span>

<span class="org-constant">this</span>.b = <span class="org-string">"MDN"</span>;
console.log(window.b)          <span class="org-comment-delimiter">// </span><span class="org-comment">"MDN"</span>
console.log(b)                 <span class="org-comment-delimiter">// </span><span class="org-comment">"MDN"</span>
</pre>
</div>

<p>
在函数内部 <code>this</code> 指针的值取决于函数被调用的方式：
</p>
<dl class="org-dl">
<dt>简单调用</dt><dd><p>
即在全局环境下直接调用，不在严格模式下时 <code>this</code> 指针指向全局对象，严格模式下 <code>this</code> 将保持他进入执行环境时的值，此时该值为 <code>undefined</code>:
</p>
<div class="org-src-container">
<pre class="src src-js"><span class="org-keyword">function</span> <span class="org-function-name">f1</span>() {
  <span class="org-keyword">return</span> <span class="org-constant">this</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">window or global</span>
}

<span class="org-keyword">function</span> <span class="org-function-name">f2</span>() {
  <span class="org-string">"use strict"</span>;
  <span class="org-keyword">return</span> <span class="org-constant">this</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">undefined</span>
}
</pre>
</div>

<p>
需要注意的是，函数的直接调用 <code>f2()</code> 和类似 <code>window.f2()</code> 的调用是不同的，通过 <code>window.f2()</code> 调用时会返回 <code>window</code> 对象。
</p>

<p>
如果要想把 this 的值从一个环境传到另一个，就要用 <code>call</code> 或者 <code>apply</code> 方法：
</p>
<div class="org-src-container">
<pre class="src src-js"><span class="org-comment-delimiter">// </span><span class="org-comment">&#23558;&#19968;&#20010;&#23545;&#35937;&#20316;&#20026; call &#21644; apply &#30340;&#31532;&#19968;&#20010;&#21442;&#25968;&#65292;this &#20250;&#34987;&#32465;&#23450;&#21040;&#36825;&#20010;&#23545;&#35937;</span>
<span class="org-keyword">var</span> <span class="org-variable-name">obj</span> = {a: <span class="org-string">'Custom'</span>};

<span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#20010;&#23646;&#24615;&#26159;&#22312;&#20840;&#23616;&#23545;&#35937;&#23450;&#20041;&#30340;</span>
<span class="org-keyword">var</span> <span class="org-variable-name">a</span> = <span class="org-string">'Global'</span>;

<span class="org-keyword">function</span> <span class="org-function-name">whatsThis</span>(<span class="org-variable-name">arg</span>) {
  <span class="org-keyword">return</span> <span class="org-constant">this</span>.a;  <span class="org-comment-delimiter">// </span><span class="org-comment">this &#30340;&#20540;&#21462;&#20915;&#20110;&#20989;&#25968;&#30340;&#35843;&#29992;&#26041;&#24335;</span>
}

whatsThis();          <span class="org-comment-delimiter">// </span><span class="org-comment">'Global'</span>
whatsThis.call(obj);  <span class="org-comment-delimiter">// </span><span class="org-comment">'Custom'</span>
whatsThis.apply(obj); <span class="org-comment-delimiter">// </span><span class="org-comment">'Custom'</span>
</pre>
</div>

<p>
使用 <code>call</code> 和 <code>apply</code> 函数的时候要注意，如果传递给 this 的值不是一个对象，JavaScript 会尝试使用内部 <code>ToObject</code> 操作将其转换为对象。
</p></dd>

<dt>bind 方法</dt><dd><p>
ECMAScript 5 引入了 <code>Function.prototype.bind()</code> 函数，调用 <code>f.bind(someObject)</code> 会创建一个与 <code>f</code> 具有相同函数体和作用域的函数，但是在这个新函数中，this 将永久地被绑定到了 <code>bind</code> 的第一个参数，无论这个函数是如何被调用的。
</p>
<div class="org-src-container">
<pre class="src src-js"><span class="org-keyword">function</span> <span class="org-function-name">f</span>(){
  <span class="org-keyword">return</span> <span class="org-constant">this</span>.a;
}

<span class="org-keyword">var</span> <span class="org-variable-name">g</span> = f.bind({a:<span class="org-string">"azerty"</span>});
console.log(g());                       <span class="org-comment-delimiter">// </span><span class="org-comment">azerty</span>

<span class="org-keyword">var</span> <span class="org-variable-name">h</span> = g.bind({a:<span class="org-string">'yoo'</span>});              <span class="org-comment-delimiter">// </span><span class="org-comment">bind &#21482;&#29983;&#25928;&#19968;&#27425;&#65281;</span>
console.log(h());                       <span class="org-comment-delimiter">// </span><span class="org-comment">azerty</span>

<span class="org-keyword">var</span> <span class="org-variable-name">o</span> = {a:37, f:f, g:g, h:h};
console.log(o.a, o.f(), o.g(), o.h());  <span class="org-comment-delimiter">// </span><span class="org-comment">37, 37, azerty, azerty</span>
</pre>
</div></dd>

<dt>箭头函数</dt><dd><p>
在箭头函数中，this 与 <b>封闭词法环境</b> 的 this 保持一致。在全局代码中，它将被设置为全局对象：
</p>
<div class="org-src-container">
<pre class="src src-js"><span class="org-keyword">var</span> <span class="org-variable-name">globalObject</span> = <span class="org-constant">this</span>;
<span class="org-keyword">var</span> <span class="org-variable-name">foo</span> = () =&gt; <span class="org-constant">this</span>;
console.log(foo() === globalObject); <span class="org-comment-delimiter">// </span><span class="org-comment">true</span>
</pre>
</div>

<p>
如果将 this 传递给 call、bind、或者 apply 来调用箭头函数，它将被忽略。
</p>

<p>
更为复杂的例子：
</p>
<div class="org-src-container">
<pre class="src src-js"><span class="org-keyword">var</span> <span class="org-variable-name">obj</span> = {
  <span class="org-function-name">f1</span>: <span class="org-keyword">function</span>() {
    <span class="org-keyword">return</span> x = () =&gt; <span class="org-constant">this</span>
  },
  <span class="org-function-name">f2</span>: <span class="org-keyword">function</span>() {
    <span class="org-string">'use strict'</span>
    <span class="org-keyword">return</span> x = () =&gt; <span class="org-constant">this</span>
  }
};

obj.f1()()  <span class="org-comment-delimiter">// </span><span class="org-comment">&#27492;&#26102; f1 &#30340; this &#20026; obj&#65292;&#22240;&#27492;&#36820;&#22238;&#20540;&#20026; obj</span>
obj.f2()()  <span class="org-comment-delimiter">// </span><span class="org-comment">&#27492;&#26102; f2 &#30340; this &#20026; obj&#65292;&#22240;&#27492;&#36820;&#22238;&#20540;&#20026; obj</span>

<span class="org-keyword">var</span> <span class="org-variable-name">f1</span> = obj.f1
f1()()     <span class="org-comment-delimiter">// </span><span class="org-comment">&#38750;&#20005;&#26684;&#27169;&#24335;&#65292;&#27492;&#26102; f1 &#30340; this &#25351;&#21521;&#20840;&#23616;&#23545;&#35937;&#65292;&#20063;&#23601;&#26159; window</span>

<span class="org-keyword">var</span> <span class="org-variable-name">f2</span> = obj.f2
f2()()     <span class="org-comment-delimiter">// </span><span class="org-comment">&#20005;&#26684;&#27169;&#24335;&#65292;&#27492;&#26102; f2 &#30340; this &#25351;&#21521; undefined</span>
</pre>
</div></dd>

<dt>作为对象的方法</dt><dd><p>
当函数作为对象里的方法被调用时，它们的 <code>this</code> 指向调用该函数的对象：
</p>
<div class="org-src-container">
<pre class="src src-js"><span class="org-keyword">var</span> <span class="org-variable-name">o</span> = {
  prop: 37,
  <span class="org-function-name">f</span>: <span class="org-keyword">function</span>() {
    <span class="org-keyword">return</span> <span class="org-constant">this</span>.prop;
  }
};

console.log(o.f()); <span class="org-comment-delimiter">// </span><span class="org-comment">37</span>
</pre>
</div>

<p>
同时，这样的行为，不受函数定义方式或位置的影响：
</p>
<div class="org-src-container">
<pre class="src src-js"><span class="org-keyword">var</span> <span class="org-variable-name">o</span> = {prop: 37};

<span class="org-keyword">function</span> <span class="org-function-name">independent</span>() {
  <span class="org-keyword">return</span> <span class="org-constant">this</span>.prop;
}

o.f = independent;

console.log(o.f()); <span class="org-comment-delimiter">// </span><span class="org-comment">37</span>
</pre>
</div>

<p>
同时，this 的绑定只受最靠近的成员引用的影响：
</p>
<div class="org-src-container">
<pre class="src src-js">o.b = {g: independent, prop: 42};
console.log(o.b.g()); <span class="org-comment-delimiter">// </span><span class="org-comment">42</span>
</pre>
</div></dd>

<dt>原型链中的 this</dt><dd><p>
对于在对象原型链上某处定义的方法，同样的概念也适用。如果该方法存在于一个对象的原型链上，那么 this 指向的是调用这个方法的对象，就像该方法在对象上一样：
</p>
<div class="org-src-container">
<pre class="src src-js"><span class="org-keyword">var</span> <span class="org-variable-name">o</span> = {
  <span class="org-function-name">f</span>: <span class="org-keyword">function</span>() { 
    <span class="org-keyword">return</span> <span class="org-constant">this</span>.a + <span class="org-constant">this</span>.b; 
  }
};
<span class="org-keyword">var</span> <span class="org-variable-name">p</span> = Object.create(o);
p.a = 1;
p.b = 4;

console.log(p.f()); <span class="org-comment-delimiter">// </span><span class="org-comment">5</span>
</pre>
</div>

<p>
就是说依然遵循上一个规则。
</p></dd>

<dt>getter 与 setter 中的 this</dt><dd><p>
用作 getter 或 setter 的函数都会把 this 绑定到设置或获取属性的对象：
</p>
<div class="org-src-container">
<pre class="src src-js"><span class="org-keyword">function</span> <span class="org-function-name">sum</span>() {
  <span class="org-keyword">return</span> <span class="org-constant">this</span>.a + <span class="org-constant">this</span>.b + <span class="org-constant">this</span>.c;
}

<span class="org-keyword">var</span> <span class="org-variable-name">o</span> = {
  a: 1,
  b: 2,
  c: 3,
  get average() {
    <span class="org-keyword">return</span> (<span class="org-constant">this</span>.a + <span class="org-constant">this</span>.b + <span class="org-constant">this</span>.c) / 3;
  }
};

Object.defineProperty(o, <span class="org-string">'sum'</span>, {
  get: sum, enumerable: <span class="org-constant">true</span>, configurable: <span class="org-constant">true</span>});

console.log(o.average, o.sum); <span class="org-comment-delimiter">// </span><span class="org-comment">logs 2, 6</span>
</pre>
</div></dd>

<dt>作为构造函数</dt><dd><p>
当一个函数用作构造函数时，它的 this 被绑定到正在构造的新对象：
</p>
<div class="org-src-container">
<pre class="src src-js"><span class="org-keyword">function</span> <span class="org-function-name">C</span>(){
  <span class="org-constant">this</span>.a = 37;
}

<span class="org-keyword">var</span> <span class="org-variable-name">o</span> = <span class="org-keyword">new</span> <span class="org-type">C</span>();
console.log(o.a); <span class="org-comment-delimiter">// </span><span class="org-comment">logs 37</span>
</pre>
</div></dd>

<dt>作为一个 DOM 事件处理函数</dt><dd><p>
当函数被用作事件处理函数时，它的 this 指向触发事件的元素（一些浏览器在使用非 addEventListener 的函数动态添加监听函数时不遵守这个约定）：
</p>
<div class="org-src-container">
<pre class="src src-js"><span class="org-comment-delimiter">// </span><span class="org-comment">&#34987;&#35843;&#29992;&#26102;&#65292;&#23558;&#20851;&#32852;&#30340;&#20803;&#32032;&#21464;&#25104;&#34013;&#33394;</span>
<span class="org-keyword">function</span> <span class="org-function-name">bluify</span>(<span class="org-variable-name">e</span>){
  console.log(<span class="org-constant">this</span> === e.currentTarget); <span class="org-comment-delimiter">// </span><span class="org-comment">&#24635;&#26159; true</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#24403; currentTarget &#21644; target &#26159;&#21516;&#19968;&#20010;&#23545;&#35937;&#26102;&#20026; true</span>
  console.log(<span class="org-constant">this</span> === e.target);        
  <span class="org-constant">this</span>.style.backgroundColor = <span class="org-string">'#A5D9F3'</span>;
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#33719;&#21462;&#25991;&#26723;&#20013;&#30340;&#25152;&#26377;&#20803;&#32032;&#30340;&#21015;&#34920;</span>
<span class="org-keyword">var</span> <span class="org-variable-name">elements</span> = document.getElementsByTagName(<span class="org-string">'*'</span>);

<span class="org-comment-delimiter">// </span><span class="org-comment">&#23558; bluify &#20316;&#20026;&#20803;&#32032;&#30340;&#28857;&#20987;&#30417;&#21548;&#20989;&#25968;&#65292;&#24403;&#20803;&#32032;&#34987;&#28857;&#20987;&#26102;&#65292;&#23601;&#20250;&#21464;&#25104;&#34013;&#33394;</span>
<span class="org-keyword">for</span>(<span class="org-keyword">var</span> <span class="org-variable-name">i</span>=0 ; i&lt;elements.length ; i++){
  elements[i].addEventListener(<span class="org-string">'click'</span>, bluify, <span class="org-constant">false</span>);
}
</pre>
</div></dd>

<dt>作为一个内联事件处理函数</dt><dd><p>
当代码被内联 <code>on-event</code> 处理函数调用时，它的 this 指向监听器所在的 DOM 元素：
</p>
<div class="org-src-container">
<pre class="src src-html">&lt;<span class="org-function-name">button</span> <span class="org-variable-name">onclick</span>=<span class="org-string">"alert(this.tagName.toLowerCase());"</span>&gt;
  Show this
&lt;/<span class="org-function-name">button</span>&gt;
</pre>
</div></dd>

<dt>setTimeout</dt><dd><p>
由 <code>setTimeout()</code> 调用的代码运行在与所在函数完全分离的执行环境上。这会导致，这些代码中包含的 this 关键字在非严格模式会指向全局对象，严格模式下为 undefined。
</p>

<p>
同时，即使是在严格模式下，setTimeout() 的回调函数里面的 this 仍然默认指向 window 对象，并不是 undefined。
</p>

<p>
PS：在 Chrome 上的测试结果是，无论是否是严格模式，函数和代码中的 this 都指向 window
</p></dd>
</dl>

<p>
参考：
</p>
<ul class="org-ul">
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this">this - JavaScript | MDN</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setTimeout">window.setTimeout - Web API 接口参考 | MDN</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgf064612" class="outline-2">
<h2 id="orgf064612"><span class="section-number-2">8</span> 事件机制</h2>
<div class="outline-text-2" id="text-8">
<ul class="org-ul">
<li>通过 <code>addEventListener</code> 方法可以为同一个事件添加多个不同的监听函数。这些函数按照添加顺序触发，即先添加先触发。如果为同一个事件多次添加同一个监听函数，该函数只会执行一次，多余的添加将自动被去除。</li>
<li>事件 <code>Event</code> 对象的 <code>timeStamp</code> 属性的值为打开当前页面后到触发该事件的事件长度，通过 <code>+new Date()</code> 减去该值便可以得到打开页面的时间</li>
</ul>
</div>
</div>

<div id="outline-container-orgc66ab78" class="outline-2">
<h2 id="orgc66ab78"><span class="section-number-2">9</span> 相关技巧</h2>
<div class="outline-text-2" id="text-9">
</div>
<div id="outline-container-org1118aa9" class="outline-3">
<h3 id="org1118aa9"><span class="section-number-3">9.1</span> JavaScript 变量的命名</h3>
<div class="outline-text-3" id="text-9-1">
<p>
JavaScript 的标识符允许大多数的 Unicode 字符，因此，你甚至可以使用颜文字来编写程序。
</p>
</div>
</div>

<div id="outline-container-org5227922" class="outline-3">
<h3 id="org5227922"><span class="section-number-3">9.2</span> 让返回值变成 undefined</h3>
<div class="outline-text-3" id="text-9-2">
<p>
在浏览器地址栏执行函数时这个技巧挺有用的，可以避免因为函数返回值进行跳转：
</p>
<div class="org-src-container">
<pre class="src src-js">javascript:<span class="org-keyword">void</span> <span class="org-variable-name">window</span>.prompt(<span class="org-string">"Copy to clipboard: Ctrl+C, Enter"</span>, <span class="org-string">`[[${window.location.href}][${document.title}]]`</span>)
</pre>
</div>

<p>
直接通过关键字 void 将值覆盖。
</p>
</div>
</div>

<div id="outline-container-orgc8e1022" class="outline-3">
<h3 id="orgc8e1022"><span class="section-number-3">9.3</span> 显示所有元素的 outline</h3>
<div class="outline-text-3" id="text-9-3">
<p>
控制台中 $$ 相当于 document.querySelectorAll
</p>
<div class="org-src-container">
<pre class="src src-js">$$(<span class="org-string">"*"</span>).forEach(
  e =&gt; e.style.outline = <span class="org-string">"1px solid #"</span> + (~~(Math.random() * (1&lt;&lt;24))).toString(16)
)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf1aa94c" class="outline-3">
<h3 id="orgf1aa94c"><span class="section-number-3">9.4</span> IIFE</h3>
<div class="outline-text-3" id="text-9-4">
<p>
IIFE（立即调用函数表达式）是一个在定义时就会立即执行的 JavaScript 函数。
</p>

<p>
这是一个被称为自执行匿名函数的设计模式，主要包含两部分:
</p>
<ul class="org-ul">
<li>第一部分是包围在圆括号运算符 () 里的一个匿名函数，这个匿名函数拥有独立的词法作用域。这不仅避免了外界访问此 IIFE 中的变量，而且又不会污染全局作用域。</li>
<li>第二部分再一次使用 () 创建了一个立即执行函数表达式，JavaScript 引擎到此将直接执行函数。</li>
</ul>

<div class="org-src-container">
<pre class="src src-javascript">(<span class="org-keyword">function</span> () { 
  <span class="org-keyword">var</span> <span class="org-variable-name">name</span> = <span class="org-string">"Barry"</span>;
})();
</pre>
</div>
</div>
</div>

<div id="outline-container-orgae7e719" class="outline-3">
<h3 id="orgae7e719"><span class="section-number-3">9.5</span> 数值运算符</h3>
<div class="outline-text-3" id="text-9-5">
<p>
数值运算符虽然使用加号，但它是一元运算符，作用在于可以将任何值转为数值，比如将 <code>Date</code> 转换为 Unix 时间戳：
</p>
<div class="org-src-container">
<pre class="src src-js"><span class="org-keyword">let</span> <span class="org-variable-name">timestamp</span> = +<span class="org-keyword">new</span> <span class="org-type">Date</span>();
</pre>
</div>

<p>
与之相应的是负数值运算符，使用减号，参考：
</p>
<ul class="org-ul">
<li><a href="https://wangdoc.com/javascript/operators/arithmetic.html#%E6%95%B0%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%8C%E8%B4%9F%E6%95%B0%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6">算术运算符 - 数值运算符 - JavaScript 教程 - 网道</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgfe77455" class="outline-3">
<h3 id="orgfe77455"><span class="section-number-3">9.6</span> 函数参数列表</h3>
<div class="outline-text-3" id="text-9-6">
<p>
JavaScript 中参数列表中参数的数量并不影响我参数的传递，多和少都是无所谓的。
</p>
</div>
</div>
</div>

<div id="outline-container-org51ea6ff" class="outline-2">
<h2 id="org51ea6ff"><span class="section-number-2">10</span> 相关问题</h2>
<div class="outline-text-2" id="text-10">
</div>
<div id="outline-container-orgfa745e2" class="outline-3">
<h3 id="orgfa745e2"><span class="section-number-3">10.1</span> 通过 innerHTML 的方式为 table 添加行失败</h3>
<div class="outline-text-3" id="text-10-1">
<p>
通过 innerHTML 属性设置 HTML 时，底层引擎会自动关闭未关闭的标签，并修复其他错误的 HTML。
</p>

<p>
而单独的 &lt;tr&gt; 标签将被视作为关闭的标签，因此，通过 innerHTML 的方式为 table 添加行会失败。
</p>

<p>
解决方案：
</p>
<div class="org-src-container">
<pre class="src src-js"><span class="org-keyword">let</span> <span class="org-variable-name">table</span> = document.createElement(<span class="org-string">'table'</span>);
<span class="org-keyword">for</span> (<span class="org-keyword">let</span> <span class="org-variable-name">i</span> = 0; i &lt; 3; ++i) {
  <span class="org-keyword">let</span> <span class="org-variable-name">row</span> = table.insertRow(i);
  <span class="org-keyword">let</span> <span class="org-variable-name">text</span> = document.createTextNode(i.toString());
  <span class="org-keyword">let</span> <span class="org-variable-name">cell</span> = row.insertCell(0);
  cell.appendChild(text);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgae8d51d" class="outline-3">
<h3 id="orgae8d51d"><span class="section-number-3">10.2</span> 浏览器中 ES6 模块化的语法不能使用</h3>
<div class="outline-text-3" id="text-10-2">
<p>
需要使用如下形式的 script 标签：
</p>
<div class="org-src-container">
<pre class="src src-html">&lt;<span class="org-function-name">script</span> <span class="org-variable-name">type</span>=<span class="org-string">"module"</span> <span class="org-variable-name">src</span>=<span class="org-string">"..."</span>&gt;
</pre>
</div>

<p>
参考：<a href="http://es6.ruanyifeng.com/#docs/module">Module 的语法 - ECMAScript 6入门</a>
</p>
</div>
</div>

<div id="outline-container-orgeb9c9ae" class="outline-3">
<h3 id="orgeb9c9ae"><span class="section-number-3">10.3</span> 怎样获取用户使用的语言</h3>
<div class="outline-text-3" id="text-10-3">
<p>
在 <code>Firefox</code> 和 <code>Chrome</code> 中可以使用如下方式获取：
</p>
<div class="org-src-container">
<pre class="src src-js"><span class="org-keyword">var</span> <span class="org-variable-name">language</span>;
<span class="org-keyword">if</span> (window.navigator.languages) {
  language = window.navigator.languages[0];
} <span class="org-keyword">else</span> {
  language = window.navigator.userLanguage || window.navigator.language;
}
</pre>
</div>

<p>
参考：
</p>
<ul class="org-ul">
<li><a href="https://stackoverflow.com/questions/25606730/get-current-locale-of-chrome/42070353">javascript - Get current locale of chrome - Stack Overflow</a></li>
<li><a href="https://www.w3schools.com/jsref/obj_navigator.asp">Navigator Object</a></li>
</ul>
</div>
</div>

<div id="outline-container-org871d156" class="outline-3">
<h3 id="org871d156"><span class="section-number-3">10.4</span> JavaScript 的入口函数？</h3>
<div class="outline-text-3" id="text-10-4">
<p>
在所有内容，包括外部图片之类的文件加载完后，才会执行的函数：
</p>
<div class="org-src-container">
<pre class="src src-javascript">window.onload = <span class="org-keyword">function</span> () {
  <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd9ec0f5" class="outline-3">
<h3 id="orgd9ec0f5"><span class="section-number-3">10.5</span> 如何清空一个数组中的内容</h3>
<div class="outline-text-3" id="text-10-5">
<p>
我们可以使用如下五种方法来清空一个数组中的内容：
</p>
<ol class="org-ol">
<li><p>
创建一个新的空数组，应该保证其他地方没有引用原来的数组：
</p>
<div class="org-src-container">
<pre class="src src-js">A = [];
</pre>
</div></li>

<li><p>
将数组的 <code>length</code> 属性置为 0：
</p>
<div class="org-src-container">
<pre class="src src-js">A.length = 0;
</pre>
</div></li>

<li><p>
使用数组的 <code>splice</code> 方法：
</p>
<div class="org-src-container">
<pre class="src src-js">A.splice(0, A.length);
</pre>
</div></li>

<li><p>
暴力点，整一个循环：
</p>
<div class="org-src-container">
<pre class="src src-js"><span class="org-keyword">while</span> (A.length &gt; 0) {
  A.pop();
}
</pre>
</div></li>

<li><p>
再整一个循环：
</p>
<div class="org-src-container">
<pre class="src src-js"><span class="org-keyword">while</span> (A.length &gt; 0) {
  A.shift();
}
</pre>
</div></li>
</ol>

<p>
其中，最具可用性的是 <code>2</code> 和 <code>3</code> 这两种方式，它们两个的性能也差不多。
</p>

<p>
参考：
</p>
<ul class="org-ul">
<li><a href="https://stackoverflow.com/questions/1232040/how-do-i-empty-an-array-in-javascript">How do I empty an array in JavaScript? - Stack Overflow</a></li>
</ul>
</div>
</div>

<div id="outline-container-org7754b81" class="outline-3">
<h3 id="org7754b81"><span class="section-number-3">10.6</span> 变量提升的规则</h3>
<div class="outline-text-3" id="text-10-6">
<p>
JavaScript 中的变量提升给我的感觉是一种略显尴尬的功能，主要原因大概就是它只提升声明不提升初始化，使得发生以下情况：
</p>
<div class="org-src-container">
<pre class="src src-js"><span class="org-keyword">var</span> <span class="org-variable-name">x</span> = 1;                 <span class="org-comment-delimiter">// </span><span class="org-comment">&#22768;&#26126; + &#21021;&#22987;&#21270; x</span>
console.log(x + <span class="org-string">" "</span> + y);  <span class="org-comment-delimiter">// </span><span class="org-comment">'1 undefined'</span>
<span class="org-keyword">var</span> <span class="org-variable-name">y</span> = 2;                 <span class="org-comment-delimiter">// </span><span class="org-comment">&#22768;&#26126; + &#21021;&#22987;&#21270; y</span>


<span class="org-comment-delimiter">//</span><span class="org-comment">&#19978;&#38754;&#30340;&#20195;&#30721;&#21644;&#19979;&#38754;&#30340;&#20195;&#30721;&#26159;&#19968;&#26679;&#30340; </span>
<span class="org-keyword">var</span> <span class="org-variable-name">x</span> = 1;                 <span class="org-comment-delimiter">// </span><span class="org-comment">&#22768;&#26126; + &#21021;&#22987;&#21270; x</span>
<span class="org-keyword">var</span> <span class="org-variable-name">y</span>;                     <span class="org-comment-delimiter">//</span><span class="org-comment">&#22768;&#26126; y</span>
console.log(x + <span class="org-string">" "</span> + y);  <span class="org-comment-delimiter">//</span><span class="org-comment">y &#26159;&#26410;&#23450;&#20041;&#30340;</span>
y = 2;                     <span class="org-comment-delimiter">// </span><span class="org-comment">&#21021;&#22987;&#21270;  y </span>
</pre>
</div>

<p>
同时，对于函数来说，通过赋值语句定义的函数提升规则和普通变量相同：
</p>
<div class="org-src-container">
<pre class="src src-js">f();
<span class="org-keyword">var</span> <span class="org-variable-name">f</span> = <span class="org-keyword">function</span> () {};
<span class="org-comment-delimiter">// </span><span class="org-comment">TypeError: undefined is not a function</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">&#19978;&#38754;&#30340;&#20195;&#30721;&#31561;&#21516;&#20110;&#19979;&#38754;&#30340;&#24418;&#24335;</span>
<span class="org-keyword">var</span> <span class="org-variable-name">f</span>;
f();
f = <span class="org-keyword">function</span> () {};
</pre>
</div>

<p>
参考：
</p>
<ul class="org-ul">
<li><a href="https://wangdoc.com/javascript/types/function.html#%E5%87%BD%E6%95%B0%E5%90%8D%E7%9A%84%E6%8F%90%E5%8D%87">函数名的提升 - JavaScript 教程 - 网道</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Hoisting">变量提升 - 术语表 | MDN</a></li>
</ul>
</div>
</div>

<div id="outline-container-orge44e6e8" class="outline-3">
<h3 id="orge44e6e8"><span class="section-number-3">10.7</span> window.onload 和 document.onload</h3>
<div class="outline-text-3" id="text-10-7">
<p>
window.onload 触发在页面资源加载完成后，包括图像和脚本资源，而 document.onload 可以触发在图像和其他额外资源加载完成之前。
</p>

<p>
参考：
</p>
<ul class="org-ul">
<li><a href="https://stackoverflow.com/questions/588040/window-onload-vs-document-onload">javascript - window.onload vs document.onload - Stack Overflow</a></li>
</ul>
</div>
</div>

<div id="outline-container-org62cb7de" class="outline-3">
<h3 id="org62cb7de"><span class="section-number-3">10.8</span> 普通函数和构造函数的区别</h3>
<div class="outline-text-3" id="text-10-8">
<p>
JS 中通过 <code>new function</code> 的方式来创建对象的方式让人多少有些不习惯，但是其本质还是很简单的，通过构造函数创建对象时会发生：
</p>
<div class="org-src-container">
<pre class="src src-js"><span class="org-comment-delimiter">// </span><span class="org-comment">1. &#21019;&#24314;&#19968;&#20010;&#31354;&#23545;&#35937;</span>
<span class="org-keyword">var</span> <span class="org-variable-name">_obj</span> = {}

<span class="org-comment-delimiter">// </span><span class="org-comment">2. this &#21464;&#37327;&#25351;&#21521;&#23545;&#35937; _obj</span>
Constructor.call(_obj)

<span class="org-comment-delimiter">// </span><span class="org-comment">3. _obj &#32487;&#25215;&#20102;&#26500;&#36896;&#20989;&#25968; Constructor() &#30340;&#21407;&#22411;</span>
_obj.__proto__ = Constructor.<span class="org-constant">prototype</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">4. &#25191;&#34892;&#26500;&#36896;&#20989;&#25968; Constructor() &#20869;&#30340;&#20195;&#30721;</span>
</pre>
</div>

<p>
普通函数和构造函数的关键区别就在于 <code>this</code> 指针的指向。
</p>

<p>
参考：
</p>
<ul class="org-ul">
<li><a href="https://segmentfault.com/a/1190000008615288">普通函数和构造函数的区别 - 前端学习之路 - SegmentFault 思否</a></li>
<li><a href="https://wangdoc.com/javascript/oop/prototype.html">对象的继承 - JavaScript 教程 - 网道</a></li>
<li><a href="https://interactive-examples.mdn.mozilla.net/pages/js/function-call.html">JavaScript Demo: Function.call()</a></li>
</ul>
</div>
</div>

<div id="outline-container-org8eb3758" class="outline-3">
<h3 id="org8eb3758"><span class="section-number-3">10.9</span> 怎样实现字符串的 replaceAll 操作</h3>
<div class="outline-text-3" id="text-10-9">
<p>
两种较为实用的方式为：
</p>
<div class="org-src-container">
<pre class="src src-js">str.split(<span class="org-string">'abc'</span>).join(<span class="org-string">''</span>)
str.replace(<span class="org-string">/abc/</span>g, <span class="org-string">''</span>)
</pre>
</div>

<p>
参考：
</p>
<ul class="org-ul">
<li><a href="https://stackoverflow.com/questions/1144783/how-to-replace-all-occurrences-of-a-string">javascript - How to replace all occurrences of a string? - Stack Overflow</a></li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
版权声明：本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
<div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_shortname = 'rgb-24bit';
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
</div>
</body>
</html>
