#+TITLE:      Misc

* 目录                                                    :TOC_4_gh:noexport:
- [[#整数分解][整数分解]]
- [[#base64-编码][Base64 编码]]
- [[#lru-cache][LRU Cache]]

* 整数分解
  *整数分解(integer factorization)* 将一个正整数写成几个约数的乘积，这样的分解结果应该是独一无二的。

  给出两个大约数，很容易就能将它们两个相乘。但是，给出它们的乘积，找出它们的因子就显得不是那么容易了。
  这就是许多现代密码系统的关键所在。

  + [[https://zh.wikipedia.org/wiki/%E6%95%B4%E6%95%B0%E5%88%86%E8%A7%A3][整数分解 - 维基百科，自由的百科全书]]

* Base64 编码
  *Base64* 是一种基于 64 个可打印字符来表示二进制数据的表示方法。由于 2 ** 6 = 64，所以每 6 个比特为一个单元，对应某个可打印字符。

  转换方式：
  + 首先，对二进制数据进行处理，每 3 个字节一组，一共是 3 x 8 = 24bit，划为 4 组，每组正好 6 个 bit：
    #+HTML: <img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001399415038305edba53df7d784a7fa76c6b7f6526873b000">

  + 得到 4 个数字作为索引，然后查表，获得相应的 4 个字符，就是编码后的字符串

  + 如果要编码的二进制数据不是 3 的倍数，可以用 \x00 字节在末尾补足后，再在编码的末尾加上 1 个或 2 个 = 号，表示补了多少字节

  简单的实现：
  #+BEGIN_SRC js
    function base64_encode (s)
    {
      // the result/encoded string, the padding string, and the pad count
      var base64chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      var r = "";
      var p = "";
      var c = s.length % 3;

      // add a right zero pad to make this string a multiple of 3 characters
      if (c > 0) {
        for (; c < 3; c++) {
          p += '=';
          s += "\0";
        }
      }

      // increment over the length of the string, three characters at a time
      for (c = 0; c < s.length; c += 3) {

        // we add newlines after every 76 output characters, according to the MIME specs
        if (c > 0 && (c / 3 * 4) % 76 == 0) {
          r += "\r\n";
        }

        // these three 8-bit (ASCII) characters become one 24-bit number
        var n = (s.charCodeAt(c) << 16) + (s.charCodeAt(c+1) << 8) + s.charCodeAt(c+2);

        // this 24-bit number gets separated into four 6-bit numbers
        n = [(n >>> 18) & 63, (n >>> 12) & 63, (n >>> 6) & 63, n & 63];

        // those four 6-bit numbers are used as indices into the base64 character list
        r += base64chars[n[0]] + base64chars[n[1]] + base64chars[n[2]] + base64chars[n[3]];
      }
       // add the actual padding string, after removing the zero pad
      return r.substring(0, r.length - p.length) + p;
    }

    function base64_decode (s)
    {
      var base64chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      // remove/ignore any characters not in the base64 characters list
      //  or the pad character -- particularly newlines
      s = s.replace(new RegExp('[^'+base64chars.split("")+'=]', 'g'), "");

      // replace any incoming padding with a zero pad (the 'A' character is zero)
      var p = (s.charAt(s.length-1) == '=' ?
              (s.charAt(s.length-2) == '=' ? 'AA' : 'A') : "");
      var r = "";
      s = s.substr(0, s.length - p.length) + p;

      // increment over the length of this encoded string, four characters at a time
      for (var c = 0; c < s.length; c += 4) {

        // each of these four characters represents a 6-bit index in the base64 characters list
        //  which, when concatenated, will give the 24-bit number for the original 3 characters
        var n = (base64inv[s.charAt(c)] << 18) + (base64inv[s.charAt(c+1)] << 12) +
                (base64inv[s.charAt(c+2)] << 6) + base64inv[s.charAt(c+3)];

        // split the 24-bit number into the original three 8-bit (ASCII) characters
        r += String.fromCharCode((n >>> 16) & 255, (n >>> 8) & 255, n & 255);
      }
       // remove any zero pad that was added to make this a multiple of 24 bits
      return r.substring(0, r.length - p.length);
    }
  #+END_SRC

  + [[https://en.wikibooks.org/wiki/Algorithm_Implementation/Miscellaneous/Base64][Algorithm Implementation/Miscellaneous/Base64 - Wikibooks, open books for an open world]]

* LRU Cache
  LRU Cache 可以借助散列表和链表实现，基本思路如下：
  1. 通过双向链表来存储所有的 *值*
  2. 通过散列表来存储所有的 *键 - 链表节点* 对
  3. 访问键时获取对应的节点，如果节点存在便将该节点移到链表一端，同时返回值
  4. 增加键时判断是否达到容量上限，如果达到就删除链表另一端的节点

  简易的实现：
  #+BEGIN_SRC java
    public class LRUCache<K, V> {
      class Node<K, V> {
        Node<K, V> prev;
        Node<K, V> next;
        K key;
        V val;

        Node(K key, V val) {
          this.key = key;
          this.val = val;
        }
      }

      private Map<K, Node<K, V>> map = new HashMap<>();
      private Node<K, V> head;
      private Node<K, V> tail;

      private int capacity;

      public LRUCache(int capacity) {
        this.capacity = capacity;
        this.head = new Node<>(null, null);
        this.tail = new Node<>(null, null);
        head.next = tail;
        tail.prev = head;
      }

      public V get(K key) {
        Node<K, V> node = map.get(key);
        if (node != null) {
          node.prev.next = node.next;
          node.next.prev = node.prev;
          appendTail(node);
          return node.val;
        }
        return null;
      }

      public void set(K key, V val) {
        Node<K, V> node = map.get(key);

        if (node != null) {
          node.val = val;
          // map.put(key, node);
          node.prev.next = node.next;
          node.next.prev = node.prev;
          appendTail(node);
        } else {
          if (map.size() == capacity) {
            Node<K, V> temp = head.next;
            head.next = head.next.next;
            head.next.prev = head;
            map.remove(temp.key);
          }

          node = new Node<>(key, val);
          appendTail(node);
          map.put(key, node);
        }
      }

      private void appendTail(Node<K, V> node) {
        node.next = tail;
        node.prev = tail.prev;
        tail.prev.next = node;
        tail.prev = node;
      }
    }
  #+END_SRC

  同时，可以借助 Java 中的 LinkedHashMap 快速实现：
  #+BEGIN_SRC java
    public class LRUCache<K, V> extends LinkedHashMap<K, V> {
      private int maxSize;

      public LRUCache(int initialCapcity, float loadFactor, int maxSize) {
        super(initialCapcity, loadFactor, true);
        this.maxSize = maxSize;
      }

      protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
        return size() > maxSize;
      }
    }
  #+END_SRC

  参考：[[https://yikun.github.io/2015/04/03/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AALRU-Cache%EF%BC%9F/][如何设计实现一个 LRU Cache | Yikun]]

