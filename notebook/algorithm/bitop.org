#+TITLE:      位运算

* 目录                                                    :TOC_4_gh:noexport:
- [[#相关概念][相关概念]]
- [[#整数操作][整数操作]]
- [[#字节对齐][字节对齐]]
- [[#其他操作][其他操作]]

* 相关概念
  + 数字 ~0-9~ 的 ~ASCII~ 码为： ~0x30 - 0x39~.
  + 字母 ~a-z~ 的 ~ASCII~ 码为： ~0x61 - 0x7A~.
  + 算术和逻辑左移：高位遗弃，低位补 0
  + 算术右移：低位遗弃，高位补符号位的值
  + 逻辑右移：低位遗弃，高位补 0
  + 掩码运算：掩码 ~0xFF~ 获取一个二进制数据的最低 8 位数据，其他位置为 0

* 整数操作
  可以通过按位与运算判断整数的奇偶性：
  #+BEGIN_SRC C
    num & 1;  // 偶数为 0，奇数为 1
  #+END_SRC

  可以通过位运算获得整数类型的最大值最小值：
  #+BEGIN_SRC C
    int INT_MAX = (1 << 31) - 1;  // ~(1 << 31)
    int INT_MIX = 1 << 31;
  #+END_SRC

  通过移位操作乘以或除以 ~2~ 的 ~n~ 次幂：
  #+BEGIN_SRC C
    num << n;  // 乘
    num >> n;  // 除
  #+END_SRC

  异或自身和异或 ~0~ 的效果：
  #+BEGIN_SRC C
    a ^ a = 0;  // 异或自身得 0
    a ^ 0 = a;  // 异或 0 的自身
  #+END_SRC

* 字节对齐
  通过如下方式使得 size 为 4 的倍数，其中，4 的倍数最后两位必然为 0：
  #+BEGIN_SRC C
    size_t alingn4(size_t size) {
      if (size & 0x3 == 0) {
        return size;
      }
      return ((size >> 2) + 1) << 2;
    }
  #+END_SRC
    
  通过如下方式使得 size 为 8 的倍数，其中，8 的倍数最后三位必然为 0：
  #+BEGIN_SRC C
    size_t align8(size_t size) {
      if (size & 0x7 == 0) {
        return size;
      }
      return ((size >> 3) + 1) << 3;
    }
  #+END_SRC

* 其他操作
  通过如下的方式使得将某一为置为 1：
  #+BEGIN_SRC C
    int to1(int x, int n) {
      if (n == 0) {
        return x;
      }
      return x | (1 << n);
    }
  #+END_SRC

