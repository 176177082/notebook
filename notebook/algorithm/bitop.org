#+TITLE:      位运算

* 目录                                                    :TOC_4_gh:noexport:
- [[#概念][概念]]
- [[#技巧][技巧]]
  - [[#整数运算][整数运算]]
  - [[#字节对齐][字节对齐]]
  - [[#位操作][位操作]]

* 概念
  + 数字 ~0-9~ 的 ~ASCII~ 码为： ~0x30 - 0x39~.
  + 字母 ~a-z~ 的 ~ASCII~ 码为： ~0x61 - 0x7A~.
  + 算术和逻辑左移：高位遗弃，低位补 0
  + 算术右移：低位遗弃，高位补符号位的值
  + 逻辑右移：低位遗弃，高位补 0
  + 掩码运算：掩码 ~0xFF~ 获取一个二进制数据的最低 8 位数据，其他位置为 0

* 技巧
** 整数运算
   + 通过位运算判断整数的奇偶性：
     #+BEGIN_SRC C
       num & 1;  // 偶数为 0，奇数为 1
     #+END_SRC

   + 通过位运算获得 ~int~ 类型的最大值最小值：
     #+BEGIN_SRC C
       int INT_MAX = (1 << 31) - 1;  // ~(1 << 31)
       int INT_MIX = 1 << 31;
     #+END_SRC

   + 乘以或除以 ~2~ 的 ~n~ 次幂：
     #+BEGIN_SRC C
       num << n;  // 乘
       num >> n;  // 除
     #+END_SRC

   + 异或自身和异或 ~0~ 的效果：
     #+BEGIN_SRC C
       a ^ a = 0;  // 异或自身得 0
       a ^ 0 = a;  // 异或 0 的自身
     #+END_SRC

** 字节对齐
   + 4 字节对齐 - 使得 size 为 4 的倍数：
     #+BEGIN_SRC C
       size_t alingn4(size_t size) {
         if (size & 0x3 == 0) {
           return size;
         }
         return ((size >> 2) + 1) << 2;
       }
     #+END_SRC
    
     4 的倍数最后两位必然为 0, 0x3 为 11.

   + 8 字节对齐 - 使得 size 为 8 的倍数：
     #+BEGIN_SRC C
       size_t align8(size_t size) {
         if (size & 0x7 == 0) {
           return size;
         }
         return ((size >> 3) + 1) << 3;
       }
     #+END_SRC

     8 的倍数最后三位必然为 0, 0x7 为 111.

** 位操作
   + 置某一位为 1：
     #+BEGIN_SRC C
       int to1(int x, int n) {
         if (n == 0) {
           return x;
         }
         return x | (1 << n);
       }
     #+END_SRC

