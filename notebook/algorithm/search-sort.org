#+TITLE:      查找与排序算法

* 目录                                                    :TOC_4_gh:noexport:
- [[#二分查找][二分查找]]
- [[#遗传算法][遗传算法]]
- [[#归并排序][归并排序]]
- [[#埃拉托斯特尼筛法][埃拉托斯特尼筛法]]

* 二分查找
  基础实现：
  #+BEGIN_SRC python
    def binary_search(array, size, target):
        left, right = 0, size - 1
        while left <= right:
            mid = floor((left + right) / 2)
            if array[mid] > target:
                right = mid - 1
            elif array[mid] < target:
                left = mid + 1
            else:
                return mid
        return -1
  #+END_SRC

  基础实现的变种，可以减少每次比较的次数，但是需要多进行一次迭代：
  #+BEGIN_SRC python
    def binary_search(array, size, target):
        left, right = 0, size - 1
        while not left == right:
            mid = ceil((left + right) / 2)
            if array[mid] > target:
                right = mid - 1
            else:
                left = mid

        if array[left] == target:
            return left
        return -1
  #+END_SRC
  
  当序列中存在重复元素时，寻找最左匹配元素：
  #+BEGIN_SRC python
    def binary_search_leftmost(array, size, target):
        left, right = 0, size
        while left < right:
            mid = floor((left + right) / 2)
            if array[mid] < target:
                left = mid + 1
            else:
                right = mid
        return left
  #+END_SRC

  当序列中存在重复元素时，寻找最右匹配元素：
  #+BEGIN_SRC python
    def binary_search_leftmost(array, size, target):
        left, right = 0, size
        while left < right:
            mid = floor((left + right) / 2)
            if array[mid] <= target:
                left = mid + 1
            else:
                right = mid
        return left - 1
  #+END_SRC

  计算时避免溢出：
  #+BEGIN_SRC C
    (low + high) / 2 == low + (high - low) / 2
  #+END_SRC  

  + [[https://en.wikipedia.org/wiki/Binary_search_algorithm][Binary search algorithm - Wikipedia]]

* 遗传算法
  *遗传算法(genetic algorithm (GA))* 是计算数学中用于解决最佳化的 *搜索算法*, 是进化算法的一种。
  
  + [[https://zh.wikipedia.org/wiki/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95][遗传算法 - 维基百科，自由的百科全书]]

* 归并排序
  归并排序是一个比较容易理解的排序方式，主要利用了递归的思想实现：
  #+BEGIN_SRC python :results output
    def merge_sort(nums, left, right):
        def merge(na, nb):
            i, j, nr = 0, 0, []
            while i < len(na) and j < len(nb):
                if na[i] < nb[j]:
                    nr.append(na[i])
                    i += 1
                else:
                    nr.append(nb[j])
                    j += 1
            nr.extend(na[i:])
            nr.extend(nb[j:])
            return nr
        if left < right:
            center = (left + right) // 2
            na = merge_sort(nums, left, center)
            nb = merge_sort(nums, center + 1, right)
            return merge(na, nb)
        return nums[left:right+1]

    nums = [1,23,4,5,6,2,6,7,3,45,3456,23,546,3,53,634,63,534,3]
    print(merge_sort(nums, 0, len(nums)))
  #+END_SRC

  #+RESULTS:
  : [1, 2, 3, 3, 3, 4, 5, 6, 6, 7, 23, 23, 45, 53, 63, 534, 546, 634, 3456]

  这也许是写的最丑的归并排序 @_@

* 埃拉托斯特尼筛法
  *埃拉托斯特尼筛法* 可以用来找出一定范围内所有的素数，是一种简单且历史悠久的筛法。

  代码实现：
  #+BEGIN_SRC python
    def eratosthenes(n):
        IsPrime = [True] * (n + 1)
        IsPrime[1] = False  #1不为素数
        for i in range(2, int(n ** 0.5) + 1):
            if IsPrime[i]:
                for j in range(i * i, n + 1, i):
                    IsPrime[j] = False
        return {x for x in range(2, n + 1) if IsPrime[x]}

    if __name__ == "__main__":
        print(eratosthenes(120))
  #+END_SRC

  原理图解：
  #+HTML: <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b9/Sieve_of_Eratosthenes_animation.gif/350px-Sieve_of_Eratosthenes_animation.gif">

  + [[https://zh.wikipedia.org/wiki/%E5%9F%83%E6%8B%89%E6%89%98%E6%96%AF%E7%89%B9%E5%B0%BC%E7%AD%9B%E6%B3%95][埃拉托斯特尼筛法 - 维基百科，自由的百科全书]]

