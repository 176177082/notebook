#+TITLE:      数据结构与算法分析 - 编码

* 目录                                                    :TOC_4_gh:noexport:
- [[#base64-编码][Base64 编码]]

* Base64 编码
  *Base64* 是一种基于 64 个可打印字符来表示二进制数据的表示方法。由于 2 ** 6 = 64，所以每 6 个比特为一个单元，对应某个可打印字符。

  转换方式：
  + 首先，对二进制数据进行处理，每 3 个字节一组，一共是 3 x 8 = 24bit，划为 4 组，每组正好 6 个 bit：
    #+HTML: <img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001399415038305edba53df7d784a7fa76c6b7f6526873b000">

  + 得到 4 个数字作为索引，然后查表，获得相应的 4 个字符，就是编码后的字符串

  + 如果要编码的二进制数据不是 3 的倍数，可以用 \x00 字节在末尾补足后，再在编码的末尾加上 1 个或 2 个 = 号，表示补了多少字节

  简单的实现：
  #+BEGIN_SRC js
    function base64_encode (s)
    {
      // the result/encoded string, the padding string, and the pad count
      var base64chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      var r = "";
      var p = "";
      var c = s.length % 3;

      // add a right zero pad to make this string a multiple of 3 characters
      if (c > 0) {
        for (; c < 3; c++) {
          p += '=';
          s += "\0";
        }
      }

      // increment over the length of the string, three characters at a time
      for (c = 0; c < s.length; c += 3) {

        // we add newlines after every 76 output characters, according to the MIME specs
        if (c > 0 && (c / 3 * 4) % 76 == 0) {
          r += "\r\n";
        }

        // these three 8-bit (ASCII) characters become one 24-bit number
        var n = (s.charCodeAt(c) << 16) + (s.charCodeAt(c+1) << 8) + s.charCodeAt(c+2);

        // this 24-bit number gets separated into four 6-bit numbers
        n = [(n >>> 18) & 63, (n >>> 12) & 63, (n >>> 6) & 63, n & 63];

        // those four 6-bit numbers are used as indices into the base64 character list
        r += base64chars[n[0]] + base64chars[n[1]] + base64chars[n[2]] + base64chars[n[3]];
      }
       // add the actual padding string, after removing the zero pad
      return r.substring(0, r.length - p.length) + p;
    }

    function base64_decode (s)
    {
      var base64chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      // remove/ignore any characters not in the base64 characters list
      //  or the pad character -- particularly newlines
      s = s.replace(new RegExp('[^'+base64chars.split("")+'=]', 'g'), "");

      // replace any incoming padding with a zero pad (the 'A' character is zero)
      var p = (s.charAt(s.length-1) == '=' ?
              (s.charAt(s.length-2) == '=' ? 'AA' : 'A') : "");
      var r = "";
      s = s.substr(0, s.length - p.length) + p;

      // increment over the length of this encoded string, four characters at a time
      for (var c = 0; c < s.length; c += 4) {

        // each of these four characters represents a 6-bit index in the base64 characters list
        //  which, when concatenated, will give the 24-bit number for the original 3 characters
        var n = (base64inv[s.charAt(c)] << 18) + (base64inv[s.charAt(c+1)] << 12) +
                (base64inv[s.charAt(c+2)] << 6) + base64inv[s.charAt(c+3)];

        // split the 24-bit number into the original three 8-bit (ASCII) characters
        r += String.fromCharCode((n >>> 16) & 255, (n >>> 8) & 255, n & 255);
      }
       // remove any zero pad that was added to make this a multiple of 24 bits
      return r.substring(0, r.length - p.length);
    }
  #+END_SRC

  + [[https://en.wikibooks.org/wiki/Algorithm_Implementation/Miscellaneous/Base64][Algorithm Implementation/Miscellaneous/Base64 - Wikibooks, open books for an open world]]
