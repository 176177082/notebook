#+TITLE:      ECF: 异常控制流

* 目录                                                    :TOC_4_gh:noexport:
- [[#ecf-异常控制流][ECF: 异常控制流]]
- [[#异常][异常]]
- [[#try--catch--throw][try & catch & throw]]
- [[#进程][进程]]
  - [[#并发流][并发流]]
  - [[#用户模式和内核模式][用户模式和内核模式]]
- [[#信号][信号]]
  - [[#非本地跳转][非本地跳转]]

* ECF: 异常控制流
  + 控制流 :: 程序计时器假设的连续平滑的指令序列， 下一指令和上一条指令在内存中是相邻的， 上一条指令过渡到下一条指令为 *控制转移*.
  + 异常 :: 平滑控制流的突变， 两条指令在内存中不在相邻， 可能由跳转， 调用， 返回等指令造成
  + 异常控制流 :: 操作系统通过是控制流发生突变来对某些情况作出反应， 这些突变被称为 *突变控制流* - ECF
  + 异常控制流的层次 :: 异常、系统调用、 信号、 非本地跳转。 

* 异常
  异常是异常控制流的一种形式， 一部分由硬件实现， 一部分由操作系统实现。

  处理器的状态会被编码为不同的位和信号， 状态的 *变化* 被称为 *事件*.

  当处理器检测到有事件发生时， 会通过 *异常表* 进行一个间接过程调用， 到专门的异常处理程序处理这些事件， 然后可能会：
  1. 处理程序将控制返回给当前指令， 即事件发生时正在执行的指令
  2. 处理程序将控制返回给下一条指令
  3. 处理程序终止被中断的程序

  异常表的起始地址放在 *异常表基址寄存器* 中， 每一个表目包含了对应异常处理程序的地址。

  处理器检测到事件后， 会确定该事件的异常号， 然后通过异常号确定对应异常条目在 *异常表* 中的位置。

  异常可以分为：
  + 中断： 由硬件变化引起的异常， 不是有任何一条指令造成， 因此为 *异步* 的。

    处理流程为：
    1. 当前指令执行时， 硬件变化引起异常

    2. 当前指令执行完后， 处理器检测到异常， 将控制传递给处理程序

    3. 中断处理程序运行

    4. 处理程序将控制返回给下一条指令

  + 陷阱： 由系统调用指令一起， 是同步的。

    处理流程为：
    1. 应用程序执行系统调用指令

    2. 处理器将控制转移给对应的处理程序

    3. 陷阱处理程序运行

    4. 处理程序将控制返回给系统调用指令的下一条指令

  + 故障： 由错误引起， 这个错误可能被故障处理程序修正， 同步。

    处理流程为：
    1. 当前指令导致一个故障

    2. 控制传递给处理程序

    3. 故障处理程序运行

    4. 故障排除， 控制返回给当前指令， 故障排除失败， 程序终止

  + 终止： 不可恢复的致命错误， 直接终止程序， 同步。

* try & catch & throw
  + [[http://www.di.unipi.it/~nids/docs/longjump_try_trow_catch.html][Exceptions in C with Longjmp and Setjmp]]

  异常机制：
  + 异常机制通过非本地跳转实现
  + try 语句块中抛出异常， 触发非本地跳转
  + catch 语句块中为触发异常后的执行语句
  + 可能对某些信号处理程序进行了修改， 当收到这些信号时， 抛出一个异常而不是终止程序

* 进程
  异常是允许操作系统内核提供 *进程* 概念的基本构造块。

  进程轮流使用处理器， 进程的切换通过 *上下文切换* 完成。

** 并发流
   异常处理程序、 进程、 信号处理程序、 线程等都是 *逻辑流* 的例子。

   当一个逻辑流的 *执行时间(生命周期)* 与另一个流 *重叠*, 就说这两个流逝 *并发流*.

   两个流并发的运行在不同的处理器或计算机上时， 就说这两个流逝 *并行的*.

   因此， 并发流包含并行流。

** 用户模式和内核模式
   运行在 *内核模式* 中的进程可以执行任何指令， *用户模式* 中的进程必须通过系统接口间接的访问 *内核* 代码和数据。

   一个进程初始时是位于 *用户模式* 下的， 通过异常可以从 *用户模式* 切换到 *内核模式*.

   相当数量的功能都需要 *内核* 提供支持， 这些功能通过 *系统调用* 完成。

   某些系统调用会需要一定的时间， 如磁盘读取数据， 这时系统执行 *上下文切换*, 这段时间用于另一个进程的执行。

   磁盘读取数据完成是， 产生一个中断， 使得系统再次执行 *上下文切换*, 返回之前的进程。

   上下文切换时， 先进入 *内核模式*, 切换完成后进入 *用户模式*.

   因此， 上下文切换一般由 *系统调用* 或 *中断* 异常引起。

* 信号
  操作系统通过更行目标进程的 *上下文* 中的某个状态来向一个 *进程* 发送 *信号*.

  进程可以接受信号并进行处理， 每个信号都有默认的 *信号处理程序*.

  一个发出而没有被解释的信号叫做 *待处理信号*, 在任何时刻， *一种类型* 至多只会有一个待处理信号， 多于的
  信号会被丢弃。

  一个待处理信号最多只能被接受一次。

  信号的发送和对应信号处理程序的调用由 *操作系统* 完成， 我们可以显示的让操作系统发送信号， 也可以替换
  一些信号默认的信号处理程序。

  标准库头文件 ~<signal.h>~ 定义了相关的函数。

** 非本地跳转
   标准可头文件 ~<setjmp.h>~ 提供了实现非本地跳转的函数 ~setjmp~ 和 ~longjmp.~

   #+BEGIN_SRC C
     setjmp(jmp_buf env);

     longjmp(jmp_buf env, int val);
   #+END_SRC

   调用 ~setjmp~ 时， 会将当前的 *上下文* 信息保存在 ~env~ 中， 并返回数字 ~0~.

   调用 ~longjmp~ 时， 会根据 ~env~ 中的信息跳转到 *最近* 一次调用 ~setjmp~ 的位置， ~setjmp~ 返回 ~longjmp~ 的参数 ~val~ 的值。

   如果 ~val~ 是零， 那么 ~setjmp~ 会返回 ~1~.

   即： ~setjmp~ 调用一次， 返回两次。

   ~setjmp~ 的返回值不能赋给变量， 但是可以用于 *条件判断*.
